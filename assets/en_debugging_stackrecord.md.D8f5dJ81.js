import{_ as t,c as a,al as i,o}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"Run time stack statistics","description":"","frontmatter":{},"headers":[],"relativePath":"en/debugging/stackrecord.md","filePath":"en/debugging/stackrecord.md"}'),n={name:"en/debugging/stackrecord.md"};function s(c,e,r,l,d,u){return o(),a("div",null,e[0]||(e[0]=[i('<h1 id="run-time-stack-statistics" tabindex="-1">Run time stack statistics <a class="header-anchor" href="#run-time-stack-statistics" aria-label="Permalink to &quot;Run time stack statistics&quot;">​</a></h1><h2 id="introduce" tabindex="-1">Introduce <a class="header-anchor" href="#introduce" aria-label="Permalink to &quot;Introduce&quot;">​</a></h2><p>When debugging code, it is often necessary to focus on how to track the maximum stack usage of the calling functions in order to optimize the code structure and reduce stack usage. This article will introduce a method based on the running state to track the deepest call stack of all tasks.</p><h2 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h2><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CONFIG_SCHED_STACKRECORD=32</span></span>\n<span class="line"><span>CONFIG_ARCH_INSTRUMENT_ALL=y</span></span></code></pre></div></blockquote><p><code>`CONFIG_SCHED_STACKRECORD</code>[ is used to record the maximum stack usage of all tasks ]{.title-ref}<code>CONFIG_ARCH_INSTRUMENT_ALL</code>` is used to instrument all code.</p><p>Please note that CONFIG_ARCH_INSTRUMENT_ALL is not necessary. This configuration option will instrument all code, but if you only want to instrument specific functions, you can add &#39;-finstrument-functions&#39; to the corresponding makefile.</p><h2 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h2><ol><li><p><code>`./tools/configure.sh esp32c3-devkit:stack</code>`</p></li><li><p><code>`make -j20</code>`</p></li><li><p>flash the image to your board .. code-block :: bash</p><blockquote><p>nsh&gt; cat /proc/1/stack StackAlloc: 0x3fc8b5b0 StackBase: 0x3fc8b5e0 StackSize: 2000 MaxStackUsed:1344 Backtrace Size 0x42009198 32 0x42009200 48 0x420081a0 128 0x42008d18 64 0x4201da60 80 0x420199e0 80 0x42018c6c 48 0x420194f4 48 0x42017d30 32 0x4201634c 32 0x420163ac 48 0x42016408 32 0x420132c0 48 0x42010598 32 0x4200fd98 48 0x4200f5dc 80 0x4200f8e0 160</p></blockquote></li></ol><h2 id="implementation-details" tabindex="-1">Implementation details <a class="header-anchor" href="#implementation-details" aria-label="Permalink to &quot;Implementation details&quot;">​</a></h2><p>The specific principle is based on the instrumentation of gcc. In the TCB (Thread Control Block) of the corresponding task, the maximum value of the stack pointer (sp) is recorded at the entry of each function. If it is the maximum value, the backtrace is recorded.</p><h2 id="notice" tabindex="-1">Notice <a class="header-anchor" href="#notice" aria-label="Permalink to &quot;Notice&quot;">​</a></h2><p>Be cautious when using the CONFIG_ARCH_INSTRUMENT_ALL option: 1. It will instrument every function, which may have a risk of recursion. 2. It will also instrument entry functions, such as _start(). At this point, the bss segment and data segment have not been initialized, which may cause errors. The current implementation uses a magic number to avoid this, but it performs poorly during hot start. The solution is to mark the entry function with the noinstrument_function flag to prevent instrumentation.</p>',13)]))}const m=t(n,[["render",s]]);export{p as __pageData,m as default};
