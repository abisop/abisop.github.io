import{_ as r,c as o,al as t,o as i}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"Work Queues","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/os/wqueue.md","filePath":"en/reference/os/wqueue.md"}'),a={name:"en/reference/os/wqueue.md"};function s(u,e,n,h,l,d){return i(),o("div",null,e[0]||(e[0]=[t('<h1 id="work-queues" tabindex="-1">Work Queues <a class="header-anchor" href="#work-queues" aria-label="Permalink to &quot;Work Queues&quot;">​</a></h1><p><strong>Work Queues</strong>. NuttX provides <em>work queues</em>. Work queues are threads that service a queue of work items to be performed. They are useful for off-loading work to a different threading context, for delayed processing, or for serializing activities.</p><h2 id="classes-of-work-queues" tabindex="-1">Classes of Work Queues <a class="header-anchor" href="#classes-of-work-queues" aria-label="Permalink to &quot;Classes of Work Queues&quot;">​</a></h2><p>There are three different classes of work queues, each with different properties and intended usage. These classes of work queues along with the common work queue interface are described in the following paragraphs.</p><h3 id="high-priority-kernel-work-queue" tabindex="-1">High Priority Kernel Work queue <a class="header-anchor" href="#high-priority-kernel-work-queue" aria-label="Permalink to &quot;High Priority Kernel Work queue&quot;">​</a></h3><p>The dedicated high-priority work queue is intended to handle delayed processing from interrupt handlers. This work queue is required for some drivers but, if there are no complaints, can be safely disabled. The high priority worker thread also performs garbage collection -- completing any delayed memory deallocations from interrupt handlers. If the high-priority worker thread is disabled, then that clean up will be performed either by (1) the low-priority worker thread, if enabled, and if not (2) the IDLE thread instead (which runs at the lowest of priority and may not be appropriate if memory reclamation is of high priority)</p><p><strong>Device Driver Bottom Half</strong>. The high-priority worker thread is intended to serve as the <em>bottom half</em> for device drivers. As a consequence it must run at a very high, fixed priority rivalling the priority of the interrupt handler itself. Typically, the high priority work queue should be the highest priority thread in your system (the default priority is 224).</p><p><strong>Thread Pool</strong>. The work queues can be configured to support multiple, low-priority threads. This is essentially a <em>thread pool</em> that provides multi-threaded servicing of the queue work. This breaks the strict serialization of the &quot;queue&quot; (and hence, the work queue is no longer a queue at all).</p><p>Multiple worker threads are required to support, for example, I/O operations that stall waiting for input. If there is only a single thread, then the entire work queue processing would stall in such cases. Such behavior is necessary to support asynchronous I/O, AIO, for example.</p><p><strong>Compared to the Low Priority Kernel Work Queue</strong>. For less critical, lower priority, application oriented worker thread support, consider enabling the lower priority work queue. The lower priority work queue runs at a lower priority, of course, but has the added advantage that it supports <em>priority inheritance</em> (if <code>CONFIG_PRIORITY_INHERITANCE=y</code> is also selected): The priority of the lower priority worker thread can then be adjusted to match the highest priority client.</p><p><strong>Configuration Options</strong>.</p><ul><li><code>CONFIG_SCHED_HPWORK</code>. Enables the high priority work queue.</li><li><code>CONFIG_SCHED_HPNTHREADS</code>. The number of threads in the high-priority queue&#39;s thread pool. Default: 1</li><li><code>CONFIG_SCHED_HPWORKPRIORITY</code>. The execution priority of the high-priority worker thread. Default: 224</li><li><code>CONFIG_SCHED_HPWORKSTACKSIZE</code>. The stack size allocated for the worker thread in bytes. Default: 2048.</li></ul><h3 id="low-priority-kernel-work-queue" tabindex="-1">Low Priority Kernel Work Queue <a class="header-anchor" href="#low-priority-kernel-work-queue" aria-label="Permalink to &quot;Low Priority Kernel Work Queue&quot;">​</a></h3><p>This lower priority work queue is better suited for more extended, application oriented processing such as file system clean-up, memory garbage collection and asynchronous I/O operations.</p><p><strong>Compared to the High Priority Work Queue</strong>. The lower priority work queue runs at a lower priority than the high priority work queue, of course, and so is inappropriate to serve as a driver <em>bottom half</em>. It is, otherwise, very similar to the high priority work queue and most of the discussion above for the high priority work queue applies equally here. The lower priority work queue does have one important property, however, that makes it better suited for some tasks:</p><p><strong>Priority Inheritance</strong>. The lower priority worker thread(s) support <em>priority inheritance</em> (if &lt;config&gt; CONFIG_PRIORITY_INHERITANCE is also selected): The priority of the lower priority worker thread can then be adjusted to match the highest priority client.</p><blockquote><p><strong>NOTE:</strong> This priority inheritance feature is not automatic. The lower priority worker thread will always have a fixed priority unless additional logic calls <code>lpwork_boostpriority()</code> to raise the priority of the lower priority worker thread (typically called before scheduling the work) and then calls the matching <code>lpwork_restorepriority()</code> when the work is completed (typically called within the work handler at the completion of the work). Currently, only the NuttX asynchronous I/O logic uses this dynamic prioritization feature.</p></blockquote><p>The higher priority worker thread, on the other hand, is intended to serve as the <em>bottom half</em> for device drivers. As a consequence must run at a very high, fixed priority. Typically, it should be the highest priority thread in your system.</p><p><strong>Configuration Options</strong>.</p><ul><li><code>CONFIG_SCHED_LPWORK</code>. If CONFIG_SCHED_LPWORK is selected then a lower-priority work queue will be enabled.</li><li><code>CONFIG_SCHED_LPNTHREADS</code>. The number of threads in the low-priority queue&#39;s thread pool. Default: 1</li><li><code>CONFIG_SCHED_LPWORKPRIORITY</code>. The minimum execution priority of the lower priority worker thread. The priority of the all worker threads start at this priority. If priority inheritance is in effect, the priority may be boosted from this level. Default: 50.</li><li><code>CONFIG_SCHED_LPWORKPRIOMAX</code>. The maximum execution priority of the lower priority worker thread. Lower priority worker threads will be started at <code>CONFIG_SCHED_LPWORKPRIORITY</code> but their priority may be boosted due to priority inheritance. The boosted priority of the low priority worker thread will not, however, ever exceed <code>CONFIG_SCHED_LPWORKPRIOMAX</code>. This limit would be necessary, for example, if the higher priority worker thread were to defer work to the lower priority thread. Clearly, in such a case, you would want to limit the maximum priority of the lower priority work thread. Default: 176.</li><li><code>CONFIG_SCHED_LPWORKSTACKSIZE</code>. The stack size allocated for the lower priority worker thread. Default: 2048.</li></ul><h3 id="user-mode-work-queue" tabindex="-1">User-Mode Work Queue <a class="header-anchor" href="#user-mode-work-queue" aria-label="Permalink to &quot;User-Mode Work Queue&quot;">​</a></h3><p><strong>Work Queue Accessibility</strong>. The high- and low-priority worker threads are kernel-mode threads. In the normal, <em>flat</em> NuttX build, these work queues are useful to application code and may be shared. However, in the NuttX protected and kernel build modes, kernel mode code is isolated and cannot be accessed from user-mode code.</p><p><strong>User-Mode Work Queue</strong>. if either <code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code> are selected, then the option to enable a special user-mode work queue is enabled. The interface to the user-mode work queue is identical to that of the kernel-mode work queues and the user-mode work queue is functionally equivalent to the high priority work queue. It differs in that its implementation does not depend on internal, kernel-space facilities.</p><p><strong>Configuration Options</strong>.</p><ul><li><code>CONFIG_LIBC_USRWORK</code>. If CONFIG_LIBC_USRWORK is also defined then the user-mode work queue will be enabled.</li><li><code>CONFIG_LIBC_USRWORKPRIORITY</code>. The execution priority of the user-mode priority worker thread. Default: 100</li><li><code>CONFIG_LIBC_USRWORKSTACKSIZE</code>. The stack size allocated for the lower priority worker thread. Default: 2048.</li></ul><h2 id="common-work-queue-interfaces" tabindex="-1">Common Work Queue Interfaces <a class="header-anchor" href="#common-work-queue-interfaces" aria-label="Permalink to &quot;Common Work Queue Interfaces&quot;">​</a></h2><h3 id="work-queue-ids" tabindex="-1">Work Queue IDs <a class="header-anchor" href="#work-queue-ids" aria-label="Permalink to &quot;Work Queue IDs&quot;">​</a></h3><p><strong>Work queue IDs</strong>. All work queues use the identical interface functions (at least identical in terms of the function <em>signature</em>). The first parameter passed to the work queue interface function identifies the work queue:</p><p><strong>Kernel-Mode Work Queue IDs:</strong></p><ul><li><code>HPWORK</code>. This ID of the high priority work queue that should only be used for high-priority, time-critical, driver bottom-half functions.</li><li><code>LPWORK</code>. This is the ID of the low priority work queue that can be used for any purpose. If <code>CONFIG_SCHED_LPWORK</code> is not defined, then there is only one kernel work queue and <code>LPWORK</code> is equal to <code>HPWORK</code>.</li></ul><p><strong>User-Mode Work Queue IDs:</strong></p><ul><li><code>USRWORK</code>. This is the ID of the user-mode work queue that can be used for any purpose by applications. In a flat build, <code>USRWORK</code> is equal to <code>LPWORK</code> so that user applications will use the lower priority work queue (if there is one).</li></ul><h3 id="work-queue-interface-types" tabindex="-1">Work Queue Interface Types <a class="header-anchor" href="#work-queue-interface-types" aria-label="Permalink to &quot;Work Queue Interface Types&quot;">​</a></h3><ul><li><code>typedef void (*worker_t)(FAR void *arg);</code> Defines the type of the work callback.</li><li><code>struct work_s</code>. Defines one entry in the work queue. This is a client-allocated structure. Work queue clients should not reference any field in this structure since they are subject to change. The user only needs this structure in order to declare instances of the work structure. Handling of all fields is performed by the work queue interfaces described below.</li></ul><h3 id="work-queue-interfaces" tabindex="-1">Work Queue Interfaces <a class="header-anchor" href="#work-queue-interfaces" aria-label="Permalink to &quot;Work Queue Interfaces&quot;">​</a></h3>',35)]))}const f=r(a,[["render",s]]);export{p as __pageData,f as default};
