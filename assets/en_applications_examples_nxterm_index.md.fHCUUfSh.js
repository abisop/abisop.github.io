import{_ as t,c as a,al as o,o as i}from"./chunks/framework.NFAqBSgQ.js";const n="/assets/nxtermexample.DlkjR2ac.png",m=JSON.parse('{"title":"nxterm Display NuttShell (NSH) as NX Console","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/examples/nxterm/index.md","filePath":"en/applications/examples/nxterm/index.md"}'),s={name:"en/applications/examples/nxterm/index.md"};function r(d,e,l,c,h,p){return i(),a("div",null,e[0]||(e[0]=[o('<h1 id="nxterm-display-nuttshell-nsh-as-nx-console" tabindex="-1"><code>nxterm</code> Display NuttShell (NSH) as NX Console <a class="header-anchor" href="#nxterm-display-nuttshell-nsh-as-nx-console" aria-label="Permalink to &quot;`nxterm` Display NuttShell (NSH) as NX Console&quot;">​</a></h1><p><img src="'+n+`" alt="" class="align-center"></p><p>This directory contains yet another version of the NuttShell (NSH). This version uses the NX console device defined in <code>include/nuttx/nx/nxterm.h</code> for output. the result is that the NSH input still come from the standard console input (probably a serial console). But the text output will go to an NX winbdow. Prerequisite configuration settings for this test include:</p><ul><li><code>CONFIG_NX=y</code> -- NX graphics must be enabled</li><li><code>CONFIG_NXTERM=y</code> -- The NX console driver must be built</li><li><code>CONFIG_DISABLE_MQUEUE=n</code> -- Message queue support must be available.</li><li><code>CONFIG_DISABLE_PTHREAD=n</code> -- pthreads are needed</li><li><code>CONFIG_NX_BLOCKING=y</code> -- pthread APIs must be blocking</li><li><code>CONFIG_NSH_CONSOLE=y</code> -- NSH must be configured to use a console.</li></ul><p>The following configuration options can be selected to customize the test:</p><ul><li><code>CONFIG_EXAMPLES_NXTERM_BGCOLOR</code> -- The color of the background. Default Default is a darker royal blue.</li><li><code>CONFIG_EXAMPLES_NXTERM_WCOLOR</code> -- The color of the window. Default is a light slate blue.</li><li><code>CONFIG_EXAMPLES_NXTERM_FONTID</code> -- Selects the font (see font ID numbers in <code>include/nuttx/nx/nxfonts.h</code>).</li><li><code>CONFIG_EXAMPLES_NXTERM_FONTCOLOR</code> -- The color of the fonts. Default is black.</li><li><code>CONFIG_EXAMPLES_NXTERM_BPP</code> -- Pixels per pixel to use. Valid options include <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code>, <code>24</code> and <code>32</code>. Default is <code>32</code>.</li><li><code>CONFIG_EXAMPLES_NXTERM_TOOLBAR_HEIGHT</code> -- The height of the toolbar. Default: <code>16</code>.</li><li><code>CONFIG_EXAMPLES_NXTERM_TBCOLOR</code> -- The color of the toolbar. Default is a medium grey.</li><li><code>CONFIG_EXAMPLES_NXTERM_MINOR</code> -- The NX console device minor number. Default is <code>0</code> corresponding to <code>/dev/nxterm0</code>.</li><li><code>CONFIG_EXAMPLES_NXTERM_DEVNAME</code> -- The quoted, full path to the NX console device corresponding to <code>CONFIG_EXAMPLES_NXTERM_MINOR</code>. Default: <code>/dev/nxterm0</code>.</li><li><code>CONFIG_EXAMPLES_NXTERM_PRIO</code> -- Priority of the NxTerm task. Default: <code>SCHED_PRIORITY_DEFAULT</code>.</li><li><code>CONFIG_EXAMPLES_NXTERM_STACKSIZE</code> -- Stack size allocated for the NxTerm task. Default: <code>2048</code>.</li><li><code>CONFIG_EXAMPLES_NXTERM_STACKSIZE</code> -- The stacksize to use when creating the NX server. Default: <code>2048</code>.</li><li><code>CONFIG_EXAMPLES_NXTERM_CLIENTPRIO</code> -- The client priority. Default: <code>100</code>.</li><li><code>CONFIG_EXAMPLES_NXTERM_SERVERPRIO</code> -- The server priority. Default: <code>120</code>.</li><li><code>CONFIG_EXAMPLES_NXTERM_LISTENERPRIO</code> -- The priority of the event listener thread. Default: <code>80</code>.</li></ul><h2 id="initialization" tabindex="-1">Initialization <a class="header-anchor" href="#initialization" aria-label="Permalink to &quot;Initialization&quot;">​</a></h2><h3 id="nx-server" tabindex="-1">NX Server <a class="header-anchor" href="#nx-server" aria-label="Permalink to &quot;NX Server&quot;">​</a></h3><p>The NxTerm example initializes the NX Server through the following steps:</p><ul><li>Calls <code>boardctl(BOARDIOC_NX_START, 0)</code> to start the NX server, then</li><li>Calls <code>nx_connect()</code> to connect to the NX server.</li><li>It also creates a separate thread at entry <code>nxterm_listener()</code> to listen for NX server events.</li></ul><h3 id="window-creation" tabindex="-1">Window Creation <a class="header-anchor" href="#window-creation" aria-label="Permalink to &quot;Window Creation&quot;">​</a></h3><p>The Nxterm Example then initializes the Windows:</p><ul><li>Calls <code>nxtk_openwindow()</code> to create a bordered window,</li><li>Calls <code>nxtk_setposition()</code> and <code>nxtk_setsize()</code> to position the window in the display,</li><li>Calls <code>nxtk_opentoolbar()</code> to create a toolbar sub-window on the main window (This toolbar window is not used by the example, it is just for illustration).</li></ul><p>A more practical use case for, say, a handheld device with a single NxTerm display would be to use the background window. The background is a window like any other with these special properties: It cannot be moved; it is always positioned at (0,0). It cannot be resized; it is always the full size of the display. And it cannot be raised, it is always the lowest windows in the z-axis.</p><h3 id="nxterm-driver" tabindex="-1">NxTerm Driver <a class="header-anchor" href="#nxterm-driver" aria-label="Permalink to &quot;NxTerm Driver&quot;">​</a></h3><p>And binds the Nxterm driver to the permit drawing in the window. This is done when it:</p><ul><li>Calls <code>boardctl(BOARDIOC_NXTERM, (uintptr_t)&amp;nxcreate)</code></li></ul><h3 id="console-task" tabindex="-1">Console Task <a class="header-anchor" href="#console-task" aria-label="Permalink to &quot;Console Task&quot;">​</a></h3><p>Finally, it sets up the NxTerm and starts the console task:</p><ul><li>Opens the NxTerm driver,</li><li>It then re-directs stdout and stderr to the NxTerm driver. This will cause all standard output to be rendered into the main windows, and</li><li>It then starts a separate console daemon that inherits the re-directed output and exits.</li></ul><h2 id="character-i-o" tabindex="-1">Character I/O <a class="header-anchor" href="#character-i-o" aria-label="Permalink to &quot;Character I/O&quot;">​</a></h2><h3 id="normal-keyboard-input" tabindex="-1">Normal Keyboard Input <a class="header-anchor" href="#normal-keyboard-input" aria-label="Permalink to &quot;Normal Keyboard Input&quot;">​</a></h3><p>Keyboard and mouse inputs are received by the application through window callbacks, just like with the Xorg X server. Some listener needs to inject the keyboard input via <code>nx_kbdin()</code> (<code>libs/libnx/nx_kbdin.c</code>) which sends a message containing the keyboard input to the NX server. The NX server will forward that keyboard input to the window that has focus.</p><p>The Window application listens for NX server events by calling <code>nx_eventhandler()</code> (<code>libs/libnx/nx_eventhandler</code>) on another listener thread. If the window has focus when the key press is entered, <code>nx_eventhandler()</code> will forward the key press information to the registered window event handler.</p><p>In <code>apps/examples/nxterm</code>, <code>nxterm_listener.c</code> is the thread that drives <code>nx_eventhandler()</code>. The window NX keyboard callback is the function <code>nxwndo_kbdin()</code> in <code>nxterm_wndo.c</code>. That callback function is just a stub that writes the keyboard data to stdout. It is a stub because keyboard input is not received from the NxTerm in this example.</p><h3 id="the-apps-examples-nxterm-kludge" tabindex="-1">The apps/examples/nxterm/ Kludge <a class="header-anchor" href="#the-apps-examples-nxterm-kludge" aria-label="Permalink to &quot;The apps/examples/nxterm/ Kludge&quot;">​</a></h3><p><code>apps/examples/nxterm</code> does not do things in the normal way. NSH does not receive keyboard input from NX; it gets keyboard input directly from the default stdin which is probably not a keyboard at all but more likely the host PC serial console. This is okay because only a single window is used and that example does not need the help of NX to select the window that has focus.</p><h3 id="re-direction-of-stdout-and-stderr" tabindex="-1">Re-direction of stdout and stderr <a class="header-anchor" href="#re-direction-of-stdout-and-stderr" aria-label="Permalink to &quot;Re-direction of stdout and stderr&quot;">​</a></h3><p>stdin in and stderr are re-directed to the NxTerm character driver in <code>nxterm_main.c</code> just before starting the console task. That logic looks like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* Now re-direct stdout and stderr so that they use the NX console driver.</span></span>
<span class="line"><span> * Note that stdin is retained (file descriptor 0, probably the serial</span></span>
<span class="line"><span> * console).</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span></span></span>
<span class="line"><span> printf(&quot;nxterm_main: Starting the console task\\n&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> fflush(stdout);</span></span>
<span class="line"><span> fflush(stderr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> fclose(stdout);</span></span>
<span class="line"><span> fclose(stderr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> dup2(fd, 1);</span></span>
<span class="line"><span> dup2(fd, 2);</span></span></code></pre></div><p>Note that stdin is not re-directed in this example! This means that keyboard input does not come from the NxTerm driver but, rather, from whatever input device was previously configured for stdin, often a serial console.</p><p>There is a configuration option that determines if NxTerm receives keyboard input or not: <code>CONFIG_NXTERM_NXKBDIN</code>, For this NxTerm example, that option can be disabled.</p><h3 id="what-is-boardioc-nxterm-ioctl-and-where-is-it-used" tabindex="-1">What Is BOARDIOC_NXTERM_IOCTL and Where Is It Used? <a class="header-anchor" href="#what-is-boardioc-nxterm-ioctl-and-where-is-it-used" aria-label="Permalink to &quot;What Is BOARDIOC\\_NXTERM\\_IOCTL and Where Is It Used?&quot;">​</a></h3><p>The <code>boardctl()</code> command <code>BOARDIOC_NXTERM_IOCTL</code> allows an application to inject keyboard data into NX for forwarding to the window with focus. In <code>apps/examples/nxterm</code>, the <code>BOARDIOC_NXTERM_IOCTL</code> is only called for the case of a redraw event. A redraw event may happen when a window above the current window is moved and the text is exposed.</p><p>If you use only a single window for the NxTerm example, then that window will always have focus. It will always have focus and will never be redrawn and the <code>BOARDIOC_NXTERM_IOCTL</code> will never be used (Unless, perhaps, you choose to implement pop-up error messages or menus on top of the NxTerm window).</p><p>Redraw callbacks will not be received even in a multi-window configuration if you use per-window frame buffers, either. In that case, the system will automatically redraw windows as needed using the per-window frame buffer shadow memory. This is controlled by the option <code>CONFIG_NX_RAMBACKED</code>. This option is recommended for performance reasons if you have sufficient memory to support it.</p><h2 id="character-data-flow-keyboard-to-display" tabindex="-1">Character Data Flow: Keyboard to Display <a class="header-anchor" href="#character-data-flow-keyboard-to-display" aria-label="Permalink to &quot;Character Data Flow: Keyboard to Display&quot;">​</a></h2><h3 id="character-data-flow-in-apps-examples-nxterm" tabindex="-1">Character Data Flow in apps/examples/nxterm <a class="header-anchor" href="#character-data-flow-in-apps-examples-nxterm" aria-label="Permalink to &quot;Character Data Flow in apps/examples/nxterm&quot;">​</a></h3><ul><li>Character input driver receives input</li><li>NSH receives input on stdin and processes it (stdin is not redirected)</li><li>Data is output to stdout (redirected to the NxTerm driver)</li></ul><p>In this simple, single-window case, <code>BOARDIOC_NXTERM_IOCTL</code> will never be used.</p><h3 id="character-data-flow-in-the-generic-window-case" tabindex="-1">Character Data Flow in the Generic Window Case <a class="header-anchor" href="#character-data-flow-in-the-generic-window-case" aria-label="Permalink to &quot;Character Data Flow in the Generic Window Case&quot;">​</a></h3><p>See, for an example, <code>apps/graphics/nxwm/src/cnxterm.cxx</code>. In this case, the behavior will change, depending on the selection of <code>CONFIG_NXTERM_NXKBDIN</code>: If <code>CONFIG_NXTERM_NXKBDIN</code> is not selected, then the behavior will be similar to <code>apps/examples/nxterm</code>; stdin will not be redirected an keyboard input will come directly from the the system console.</p><p>But is <code>CONFIG_NXTERM_NXKBDIN</code> is select, NSH&#39;s stdin will be re-redirected to the to the NxTerm character driver. Keyboard input will arrive on stdin from the NxTerm driver rather than from the system console. The following sequence describes the keyboard input in this latter case:</p><ul><li>Character input driver receives input,</li><li>Some keyboard listener thread receives input and injects it into NX via a call to <code>nx_kbdin()</code>,</li><li>NX sends an event to the registered <code>kbdin()</code> method of the window that has focus, providing the keyboard input to the window application. In this case, the window application of interest is the window bound to the NxTerm character driver by the application. The <code>kbin()</code> callback provides the focused keyboard input to the NxTerm driver via <code>boardctl(BOARDIOC_NXTERM_IOCTL, (uintptr_t)&amp;iocargs)</code>,</li><li>The NxTerm character driver receives keyboard data, buffers it, and provides that keyboard input for the next read operation,</li><li>NSH receives input on stdin which was re-directed to the NxTerm character driver. NSH processes the input, and</li><li>,NSH outputs data to stdout which was re-directed to the NxTerm character driver.</li></ul>`,44)]))}const w=t(s,[["render",r]]);export{m as __pageData,w as default};
