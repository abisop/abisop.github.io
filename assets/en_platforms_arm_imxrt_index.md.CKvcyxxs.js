import{_ as r,c as o,al as a,j as e,a as i,o as l}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"NXP i.MX RT","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/imxrt/index.md","filePath":"en/platforms/arm/imxrt/index.md"}'),n={name:"en/platforms/arm/imxrt/index.md"};function s(d,t,c,h,u,p){return l(),o("div",null,t[0]||(t[0]=[a('<h1 id="nxp-i-mx-rt" tabindex="-1">NXP i.MX RT <a class="header-anchor" href="#nxp-i-mx-rt" aria-label="Permalink to &quot;NXP i.MX RT&quot;">​</a></h1><p>The i.MX RT series of chips from NXP Semiconductors is based around an ARM Cortex-M7 core running at 500 MHz, 600 MHz or 1 GHz based on particular MCUs</p><h2 id="supported-mcus" tabindex="-1">Supported MCUs <a class="header-anchor" href="#supported-mcus" aria-label="Permalink to &quot;Supported MCUs&quot;">​</a></h2><p>The following list includes MCUs from i.MX RT series and indicates whether they are supported in NuttX</p><p>MCU Support Core Frequency</p><hr><p>RT500 No Cortex-M33 200 MHz RT600 No Cortex-M33 300 MHz RT1010 No Cortex-M7 500 MHz RT1015 No Cortex-M7 500 MHz RT1020 Yes Cortex-M7 500 MHz RT1024 No Cortex-M7 500 MHz RT1050 Yes Cortex-M7 600 MHz RT1060 Yes Cortex-M7 600 MHz RT1064 Yes Cortex-M7 600 MHz RT1170 No Cortex-M7 + M4 1 GHz + 400 MHz</p><h2 id="data-and-instruction-cache" tabindex="-1">Data and Instruction Cache <a class="header-anchor" href="#data-and-instruction-cache" aria-label="Permalink to &quot;Data and Instruction Cache&quot;">​</a></h2><p>MCUs i.MX RT1010 and higher have separated caches for instructions and data. Data cache is initially set as write-through but can be changed to write-back via Kconfig. While write-back gives better performance than write-through, it is not supported for all peripherals in NuttX yet. Write-back data cache can not be selected while running Ethernet or serial port over USB.</p><h2 id="tickless-os" tabindex="-1">Tickless OS <a class="header-anchor" href="#tickless-os" aria-label="Permalink to &quot;Tickless OS&quot;">​</a></h2><p>With Tickless OS, the periodic, timer interrupt is eliminated and replaced with a one-shot, interval timer, that becomes event driven instead of polled. This allows to run the MCU with higher resolution without using more of the CPU bandwidth processing useless interrupts.</p>',11),e("p",null,[i("Only tickless via an alarm is currently supported for i.MX RT MCU, which can be selected by CONFIG_SCHED_TICKLESS_ALARM option. CONFIG_USEC_PER_TICK option determines the resolution of time reported by :c"),e("code",{class:"interpreted-text",role:"func"},"clock_systime_ticks()"),i(" and the resolution of times that can be set for certain delays including watchdog timers and delayed work. It is important that value set in CONFIG_USEC_PER_TICK represents the frequency of GPT timer that runs the tickless mode. Clock source of the timer is 16.6 MHz, which is then divided by the prescaler value from 1 to 4096. Possible values for CONFIG_USEC_PER_TICK are 10 or 100 for example.")],-1),a('<h2 id="peripheral-support" tabindex="-1">Peripheral Support <a class="header-anchor" href="#peripheral-support" aria-label="Permalink to &quot;Peripheral Support&quot;">​</a></h2><p>The following list indicates peripherals supported in NuttX:</p><p>Peripheral Support</p><hr><p>ACMP No ADC Yes CAN Yes CSI No DAC No eLCDIF Yes ENC Yes ENET Yes FlexIO No GPIO Yes I2S Yes PWM Yes SAI No SPDIF No SPI Yes UART Yes USB Yes</p><h3 id="acmp" tabindex="-1">ACMP <a class="header-anchor" href="#acmp" aria-label="Permalink to &quot;ACMP&quot;">​</a></h3><p>The circout for comparing two analog input voltages designed to operate across the full range of supply voltage (rail-to-rail operation).</p><h3 id="adc" tabindex="-1">ADC <a class="header-anchor" href="#adc" aria-label="Permalink to &quot;ADC&quot;">​</a></h3>',8),e("p",null,[i("ADC driver with the successive approximation analog/digital converter. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_adcinitialize"),i(".")],-1),e("p",null,"ADC module can use either continuous trigger (next conversion is started as soon as the previous is finished) or hardware trigger. This option is selected by IMXRT_ADCx_ETC (x = 1, 2) config option. If IMXRT_ADCx_ETC = -1 then continuous trigger is used. If corresponding XBAR number is put in IMXRT_ADCx_ETC then that signal is used to trigger the ADC conversion (for example PWM signal can be used as a source). For PWM XBAR options please refer to PWM chapter of this documentation.",-1),e("p",null,"Hardware triggering is currently limited to maximum of 8 channels. HW trigger is automatically disabled if there are more than 8 channels.",-1),e("p",null,"DMA is currently not supported for ADC modules.",-1),e("h3",{id:"can",tabindex:"-1"},[i("CAN "),e("a",{class:"header-anchor",href:"#can","aria-label":'Permalink to "CAN"'},"​")],-1),e("p",null,[i("FlexCAN driver is supported in MCUs i.MX RT1020 and higher. i.MX RT106x have both classical CAN and also one CAN FD while i.MX RT1170 have 3 CAN FD peripherals. FlexCAN driver in imxrt works beyond SocketCAN driver layout. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_cannitialize()"),i(".")],-1),e("p",null,[i("There is an booting option that automatically provides initialization of network interface in the early stages of booting and therefore calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_cannitialize()"),i(" via board specific logic is not necessary. This however works only when there is only one interface in the chip. For running more interfaces (like CAN and Ethernet), network late initialization must be turn on by CONFIG_NETDEV_LATEINIT and board specific logic must call lower-half part of drivers.")],-1),a('<h3 id="csi" tabindex="-1">CSI <a class="header-anchor" href="#csi" aria-label="Permalink to &quot;CSI&quot;">​</a></h3><p>CMOS Sensor interface which enables the chip to connect directly to external CMOS image sensors.</p><h3 id="dac" tabindex="-1">DAC <a class="header-anchor" href="#dac" aria-label="Permalink to &quot;DAC&quot;">​</a></h3><p>Digital/analog converter for external signal is only supported in i.MX RT1170 MCU. It is 12 bit lower power, general purpose DAC.</p><h3 id="elcdif" tabindex="-1">eLCDIF <a class="header-anchor" href="#elcdif" aria-label="Permalink to &quot;eLCDIF&quot;">​</a></h3><p>The enhanced Liquid Crystal Display interface (LCDIF) is a general purpose display controller.</p><h3 id="enc" tabindex="-1">ENC <a class="header-anchor" href="#enc" aria-label="Permalink to &quot;ENC&quot;">​</a></h3>',7),e("p",null,[i("The enhanced quadrature encoder/decoder module supported in i.MX RT1015 and higher. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_qeinitialize"),i(".")],-1),e("h3",{id:"enet",tabindex:"-1"},[i("ENET "),e("a",{class:"header-anchor",href:"#enet","aria-label":'Permalink to "ENET"'},"​")],-1),e("p",null,[i("Ethernet driver supported in i.MX RT1020 and higher. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_netnitialize"),i(".")],-1),e("p",null,[i("There is an booting option that automatically provides initialization of network interface in the early stages of booting and therefore calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_cannitialize()"),i(" via board specific logic is not necessary. This however works only when there is only one interface in the chip. For running more interfaces (like CAN and Ethernet), network late initialization must be turn on by CONFIG_NETDEV_LATEINIT and board specific logic must call lower-half part of drivers.")],-1),e("h3",{id:"flexio",tabindex:"-1"},[i("FlexIO "),e("a",{class:"header-anchor",href:"#flexio","aria-label":'Permalink to "FlexIO"'},"​")],-1),e("p",null,"A configurable module providing a range of functionality like emulation of a variety of serial/parallel communication protocols, flexible 16-bit timers or programmable logic blocks. This module is supported in i.MX RT1010 and higher.",-1),e("h3",{id:"gpio",tabindex:"-1"},[i("GPIO "),e("a",{class:"header-anchor",href:"#gpio","aria-label":'Permalink to "GPIO"'},"​")],-1),e("p",null,[i("Pins can be configured using :c"),e("code",null,"imxrt_config_gpio"),i('{.interpreted-text role="func"} function. Writing to pins is done by :c'),e("code",{class:"interpreted-text",role:"func"},"imxrt_gpio_write"),i(" function and reading is done by :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_gpio_read"),i(".")],-1),e("p",null,"MCUs i.MX RT1060 and higher includes both standard speed GPIOs (1-5) and high speed GPIOS (6-9). Regular and high speed GPIO share the same pins (GPIO1 is with GPIO6 etc), therefore IOMUXC_GPR_GPR26-29 registers are used to determine what module is used for the GPIO pins.",-1),e("h3",{id:"i2c",tabindex:"-1"},[i("I2C "),e("a",{class:"header-anchor",href:"#i2c","aria-label":'Permalink to "I2C"'},"​")],-1),e("p",null,[i("Inter-Integrated Circout module supporting an interface to an I2C bus as master and/or as a slave. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_i2cbus_initialize"),i(".")],-1),a('<h3 id="pwm" tabindex="-1">PWM <a class="header-anchor" href="#pwm" aria-label="Permalink to &quot;PWM&quot;">​</a></h3><p>Pulse width modulator supported in i.MX RT1010 and higher. Multiple channels option is available. Output on pin B is currently supported only as a complementary option to pin A. The lower-half of this driver is initialize by calling :c<code>imxrt_pwminitialize</code>{.interpreted-text role=&quot;func&quot;}.</p><p>PWM module can be synchronized by an external signal. The external signal used for synchronization is selected by IMXRT_FLEXPWMx_MODx_SYNC_SRC config option. The number in IMXRT_FLEXPWMx_MODx_SYNC_SRC corresponds with the XBAR number. Following numbers can be used for synchronization of PWMs with other PWM module when using iMXRT1020, iMXRT1050 or iMXRT1060.</p><ul><li>PWM1 Module 1 = 40</li><li>PWM1 Module 2 = 41</li><li>PWM1 Module 3 = 42</li><li>PWM1 Module 4 = 43</li><li>PWM2 Module 1 = 44</li><li>PWM2 Module 2 = 45</li><li>PWM2 Module 3 = 46</li><li>PWM2 Module 4 = 47</li><li>PWM3 Module 1 = 48</li><li>PWM3 Module 2 = 49</li><li>PWM3 Module 3 = 50</li><li>PWM3 Module 4 = 51</li><li>PWM4 Module 1 = 52</li><li>PWM4 Module 2 = 53</li><li>PWM4 Module 3 = 54</li><li>PWM4 Module 4 = 55</li></ul><p>iMXRT1170 has different XBAR connections:</p><ul><li>PWM1 Module 1 = 74</li><li>PWM1 Module 2 = 75</li><li>PWM1 Module 3 = 76</li><li>PWM1 Module 4 = 77</li><li>PWM2 Module 1 = 78</li><li>PWM2 Module 2 = 79</li><li>PWM2 Module 3 = 80</li><li>PWM2 Module 4 = 81</li><li>PWM3 Module 1 = 82</li><li>PWM3 Module 2 = 83</li><li>PWM3 Module 3 = 84</li><li>PWM3 Module 4 = 85</li><li>PWM4 Module 1 = 86</li><li>PWM4 Module 2 = 87</li><li>PWM4 Module 3 = 88</li><li>PWM4 Module 4 = 89</li></ul><p>Option IMXRT_FLEXPWMx_MODx_TRIG allows the module to generate a trigger signal. The trigger is generated on timer capture of either period or duty cycle value based on the configuration.</p><h3 id="sai" tabindex="-1">SAI <a class="header-anchor" href="#sai" aria-label="Permalink to &quot;SAI&quot;">​</a></h3><p>Synchronous audio interface provided by I2C module. Supported in i.MX RT1015 and higher.</p><h3 id="spdif" tabindex="-1">SPDIF <a class="header-anchor" href="#spdif" aria-label="Permalink to &quot;SPDIF&quot;">​</a></h3><p>Sony/Philips digital interface audio block. It is a stereo transceiver that allows the processor to receive and transmit digital audio. Supported in i.MX RT1010 and higher.</p><h3 id="spi" tabindex="-1">SPI <a class="header-anchor" href="#spi" aria-label="Permalink to &quot;SPI&quot;">​</a></h3><p>Serial Peripheral interface module that supports an interface to an SPI bus as a master and/or a slave. The lower-half of this driver is initialize by calling :c<code>imxrt_lpsibus_initialize</code>{.interpreted-text role=&quot;func&quot;}.</p><h3 id="uart" tabindex="-1">UART <a class="header-anchor" href="#uart" aria-label="Permalink to &quot;UART&quot;">​</a></h3><p>Universal Asynchronous Receiver/Transmitter module. UART is initialized automatically during MCU boot.</p><h3 id="usb" tabindex="-1">USB <a class="header-anchor" href="#usb" aria-label="Permalink to &quot;USB&quot;">​</a></h3><p>Console communication over USB is supported via CDC-ACM. Only USB Device is currently supported for i.MX RT in NuttX</p><h2 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h2><blockquote><p>boards/<em>/</em></p></blockquote>',19)]))}const m=r(n,[["render",s]]);export{f as __pageData,m as default};
