import{_ as s,c as e,al as a,o as t}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"The NSH Library and NSH Initialization","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/nsh/customizing.md","filePath":"en/applications/nsh/customizing.md"}'),n={name:"en/applications/nsh/customizing.md"};function o(l,i,h,d,p,c){return t(),e("div",null,i[0]||(i[0]=[a(`<p>========================* Customizing the NuttShell ========================*</p><p><strong>Overview.</strong> The NuttShell (NSH) is a simple shell application that may be used with NuttX. It supports a variety of commands and is (very) loosely based on the Bash shell and the common utilities used with Bash shell programming. The paragraphs in this appendix will focus on customizing NSH: Adding new commands, changing the initialization sequence, etc.</p><h1 id="the-nsh-library-and-nsh-initialization" tabindex="-1">The NSH Library and NSH Initialization <a class="header-anchor" href="#the-nsh-library-and-nsh-initialization" aria-label="Permalink to &quot;The NSH Library and NSH Initialization&quot;">​</a></h1><p><strong>Overview.</strong> NSH is implemented as a library that can be found at <code>apps/nshlib</code>. As a library, it can be custom built into any application that follows the NSH initialization sequence described below. As an example, the code at <code>apps/examples/nsh/nsh_main.c</code> illustrates how to start NSH and the logic there was intended to be incorporated into your own custom code. Although code was generated simply as an example, in the end most people just use this example code as their application <code>main()</code> function. That initialization performed by that example is discussed in the following paragraphs.</p><h2 id="nsh-initialization-sequence" tabindex="-1">NSH Initialization sequence <a class="header-anchor" href="#nsh-initialization-sequence" aria-label="Permalink to &quot;NSH Initialization sequence&quot;">​</a></h2><p>The NSH start-up sequence is very simple. As an example, the code at <code>apps/system/nsh/nsh_main.c</code> illustrates how to start NSH. It simple does the following:</p><blockquote><ol><li>This function calls <code>nsh_initialize()</code> which initializes the NSH library. <code>nsh_initialize()</code> is described in more detail below.</li><li>If the Telnetconsole is enabled, it calls <code>nsh_telnetstart()</code> which resides in the NSH library. <code>nsh_telnetstart()</code> will start the Telnet daemon that will listen for Telnet connections and start remote NSH sessions.</li><li>If a local console is enabled (probably on a serial port), then <code>nsh_consolemain()</code> is called. <code>nsh_consolemain()</code> also resides in the NSH library. <code>nsh_consolemain()</code> does not return so that finished the entire NSH initialization sequence.</li></ol></blockquote><h2 id="nsh-initialize" tabindex="-1"><code>nsh_initialize()</code> <a class="header-anchor" href="#nsh-initialize" aria-label="Permalink to &quot;\`nsh_initialize()\`&quot;">​</a></h2><p>The NSH initialization function, <code>nsh_initialize()</code>, be found in <code>apps/nshlib/nsh_init.c</code>. It does only four things:</p><blockquote><ol><li><p><code>nsh_romfsetc()</code>: If so configured, it executes NSH system init and start-up script that can be found at <code>/etc/init.d/rc.sysinit</code> and <code>/etc/init.d/rcS</code> in the target file system. The <code>nsh_romfsetc()</code> function can be found in <code>apps/nshlib/nsh_romfsetc.c</code>. This function will (1) register a ROMFS file system, then (2) mount the ROMFS file system. <code>/etc</code> is the default location where a read-only, ROMFS file system is mounted by <code>nsh_romfsetc()</code>.</p><p>The ROMFS image is, itself, just built into the firmware. By default, this <code>rc.sysinit</code> system init script contains the following logic:</p><pre><code># Create a RAMDISK and mount it at XXXRDMOUNTPOINTXXX

mkrd -m XXXMKRDMINORXXX -s XXMKRDSECTORSIZEXXX XXMKRDBLOCKSXXX
mkfatfs /dev/ramXXXMKRDMINORXXX
mount -t vfat /dev/ramXXXMKRDMINORXXX XXXRDMOUNTPOINTXXX
</code></pre><p>Where the <code>XXXX*XXXX</code> strings get replaced in the template when the ROMFS image is created:</p><ul><li><code>XXXMKRDMINORXXX</code> will become the RAM device minor number. Default: 0</li><li><code>XXMKRDSECTORSIZEXXX</code> will become the RAM device sector size</li><li><code>XXMKRDBLOCKSXXX</code> will become the number of sectors in the device.</li><li><code>XXXRDMOUNTPOINTXXX</code> will become the configured mount point. Default: <code>/etc</code></li></ul><p>By default, the substituted values would yield an <code>rc.sysinit</code> file like:</p><pre><code># Create a RAMDISK and mount it at /tmp

mkrd -m 1 -s 512 1024
mkfatfs /dev/ram1
mount -t vfat /dev/ram1 /tmp
</code></pre><p>This script will, then:</p><ul><li>Create a RAMDISK of size 512*1024 bytes at <code>/dev/ram1</code>,</li><li>Format a FAT file system on the RAM disk at <code>/dev/ram1</code>, and then</li><li>Mount the FAT file system at a configured mountpoint, <code>/tmp</code>.</li></ul><p>This <code>rc.sysinit.template</code> template file can be found at <code>apps/nshlib/rc.sysinit.template</code>. The resulting ROMFS file system can be found in <code>apps/nshlib/nsh_romfsimg.h</code>.</p></li><li><p><code>board_app_initialize()</code>: Next any architecture-specific NSH initialization will be performed (if any). For the STM3240G-EVAL, this architecture specific initialization can be found at <code>boards/arm/stm32/stm3240g-eval/src/stm32_appinit.c</code>. This it does things like: (1) Initialize SPI devices, (2) Initialize SDIO, and (3) mount any SD cards that may be inserted.</p></li><li><p><code>nsh_netinit()</code>: The <code>nsh_netinit()</code> function can be found in <code>apps/nshlib/nsh_netinit.c</code>.</p></li><li><p>The start-up script <code>rcS</code> is executed after the system-init script to startup some application and other system service.</p><p>This <code>rcS</code> template file can be found at <code>apps/nshlib/rcS.template</code>. The resulting ROMFS file system can be found in <code>apps/nshlib/nsh_romfsimg.h</code>.</p></li></ol></blockquote><h1 id="nsh-commands" tabindex="-1">NSH Commands <a class="header-anchor" href="#nsh-commands" aria-label="Permalink to &quot;NSH Commands&quot;">​</a></h1><p><strong>Overview.</strong> NSH supports a variety of commands as part of the NSH program. All of the NSH commands are listed in the NSH documentation <a href="#cmdoverview">above</a>. Not all of these commands may be available at any time, however. Many commands depend upon certain NuttX configuration options. You can enter the help command at the NSH prompt to see the commands actual available:</p><p>For example, if network support is disabled, then all network-related commands will be missing from the list of commands presented by &#39;<code>nsh&gt; help</code>&#39;. You can see the specific command dependencies in the table <a href="#cmddependencies">above</a>.</p><h2 id="adding-new-nsh-commands" tabindex="-1">Adding New NSH Commands <a class="header-anchor" href="#adding-new-nsh-commands" aria-label="Permalink to &quot;Adding New NSH Commands&quot;">​</a></h2><p>New commands can be added to the NSH very easily. You simply need to add two things:</p><blockquote><ol><li>The implementation of your command, and</li><li>A new entry in the NSH command table</li></ol></blockquote><p><strong>Implementation of Your Command.</strong> For example, if you want to add a new a new command called <code>mycmd</code> to NSH, you would first implement the <code>mycmd</code> code in a function with this prototype:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cmd_mycmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(FAR </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsh_vtbl_s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vtbl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> **</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>The <code>argc</code> and <code>argv</code> are used to pass command line arguments to the NSH command. Command line parameters are passed in a very standard way: <code>argv[0]</code> will be the name of the command, and <code>argv[1]</code> through <code>argv[argc-1]</code> are the additional arguments provided on the NSH command line.</p><p>The first parameter, <code>vtbl</code>, is special. This is a pointer to session-specific state information. You don&#39;t need to know the contents of the state information, but you do need to pass this <code>vtbl</code> argument when you interact with the NSH logic. The only use you will need to make of the <code>vtbl</code> argument will be for outputting data to the console. You don&#39;t use <code>printf()</code> within NSH commands. Instead you would use:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nsh_output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(FAR </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsh_vtbl_s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vtbl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fmt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ...);</span></span></code></pre></div><p>So if you only wanted to output &quot;Hello, World!&quot; on the console, then your whole command implementation might be:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> cmd_mycmd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(FAR </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nsh_vtbl_s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vtbl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> **</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  nsh_output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vtbl, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The prototype for the new command should be placed in <code>apps/examples/nshlib/nsh.h</code>.</p><p><strong>Adding You Command to the NSH Command Table</strong>. All of the commands support by NSH appear in a single table called:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cmdmap_s g_cmdmap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span></span></code></pre></div><p>That table can be found in the file <code>apps/examples/nshlib/nsh_parse.c</code>. The structure <code>cmdmap_s</code> is also defined in <code>apps/nshlib/nsh_parse.c</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cmdmap_s</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cmd;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /* Name of the command */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  cmd_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       handler;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Function that handles the command */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     minargs;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Minimum number of arguments (including command) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     maxargs;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Maximum number of arguments (including command) */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">usage;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      /* Usage instructions for &#39;help&#39; command */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>This structure provides everything that you need to describe your command: Its name (<code>cmd</code>), the function that handles the command (<code>cmd_mycmd()</code>), the minimum and maximum number of arguments needed by the command, and a string describing the command line arguments. That last string is what is printed when enter &quot;<code>nsh&gt; help</code>&quot;.</p><p>So, for you sample command, you would add the following the to the <code>g_cmdmap[]</code> table:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mycmd&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cmd_mycmd, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span></code></pre></div><p>This entry is particularly simply because <code>mycmd</code> is so simple. Look at the other commands in <code>g_cmdmap[]</code> for more complex examples.</p>`,32)]))}const k=s(n,[["render",o]]);export{m as __pageData,k as default};
