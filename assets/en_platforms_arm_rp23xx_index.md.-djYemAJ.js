import{_ as a,c as t,al as o,o as i}from"./chunks/framework.NFAqBSgQ.js";const c=JSON.parse('{"title":"RaspberryPi rp2350","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/rp23xx/index.md","filePath":"en/platforms/arm/rp23xx/index.md"}'),r={name:"en/platforms/arm/rp23xx/index.md"};function n(s,e,l,p,h,d){return i(),t("div",null,e[0]||(e[0]=[o(`<h1 id="raspberrypi-rp2350" tabindex="-1">RaspberryPi rp2350 <a class="header-anchor" href="#raspberrypi-rp2350" aria-label="Permalink to &quot;RaspberryPi rp2350&quot;">​</a></h1><p>The rp2350 is a dual core chip produced by the RaspberryPi Foundation that is based on ARM Cortex-M33 or the Hazard3 RISC-V.</p><p>For now, only the ARM Cortex-M33 is supported.</p><p>This port is experimental and still a work in progress. Use with caution.</p><h2 id="peripheral-support" tabindex="-1">Peripheral Support <a class="header-anchor" href="#peripheral-support" aria-label="Permalink to &quot;Peripheral Support&quot;">​</a></h2><p>Most drivers were copied from the rp2040 port with some modifications.</p><p>The following list indicates peripherals currently supported in NuttX:</p><p>Peripheral Status Notes</p><hr><p>GPIO Working See Supported Boards documentation for available pins. UART I2C SPI Master SPI Slave DMAC PWM Working Working Working Untested Untested Working GPIO 0 (UART0 TX) and GPIO 1 (UART0 RX) are used for the console. USB PIO IRQs DMA Clock Output Experimental Working Working Untested Untested usbnsh configuration is somewhat working with some data corruption Flash ROM Boot Working Does not require boot2 from pico-sdk If picotool is available a nuttx.uf2 file will be created SRAM Boot Working Requires external SWD debugger PSRAM Working Three modes of heap allocation described below</p><h2 id="installation" tabindex="-1">Installation <a class="header-anchor" href="#installation" aria-label="Permalink to &quot;Installation&quot;">​</a></h2><ol><li><p>Download and build picotool, make it available in the PATH:</p><pre><code>git clone https://github.com/raspberrypi/picotool.git picotool
cd picotool
mkdir build
cd build
cmake ..
make
cp picotool ~/local/bin # somewhere in your PATH
</code></pre></li><li><p>Download NuttX and the companion applications. These must both be contained in the same directory:</p><pre><code>git clone https://github.com/apache/nuttx.git nuttx
git clone https://github.com/apache/nuttx-apps.git apps
</code></pre></li></ol><h2 id="building-nuttx" tabindex="-1">Building NuttX <a class="header-anchor" href="#building-nuttx" aria-label="Permalink to &quot;Building NuttX&quot;">​</a></h2><ol><li><p>Change to NuttX directory:</p><pre><code>cd nuttx
</code></pre></li><li><p>Select a configuration. The available configurations can be listed with the command:</p><pre><code>./tools/configure.sh -L
</code></pre></li><li><p>Load the selected configuration.:</p><pre><code>make distclean
./tools/configure.sh raspberrypi-pico-2:usbnsh
</code></pre></li><li><p>Modify the configuration as needed (optional):</p><pre><code>make menuconfig
</code></pre></li><li><p>Build NuttX:</p><pre><code>make
</code></pre></li></ol><h2 id="flash-boot" tabindex="-1">Flash boot <a class="header-anchor" href="#flash-boot" aria-label="Permalink to &quot;Flash boot&quot;">​</a></h2><p>By default, the system is built to build and run from the flash using XIP. By using the default [BOOT_RUNFROMFLASH]{.title-ref} configuration, the full image is run from the flash making most of the internal SRAM available for the OS and applications, however the execution is slower. The cache can speed up, but you might want set your time critical functions to be placed in the SRAM (copied from the flash on startup).</p><p>It is also possible to execute from SRAM, which reduces the available SRAM to the OS and applications, however it is very useful when debugging as erasing and rewriting the flash on every build is tedious and slow. This option is enabled with [BOOT_RUNFROMISRAM]{.title-ref} and requires [openocd]{.title-ref}[ and/or \`gdb]{.title-ref}.</p><p>There is a third option which is to write the firmware on the flash and it gets copied to the SRAM. This is enabled with [CONFIG_BOOT_COPYTORAM]{.title-ref} and might be useful for time critical applications, on the expense of reduced usable internal SRAM memory.</p><h2 id="psram" tabindex="-1">PSRAM <a class="header-anchor" href="#psram" aria-label="Permalink to &quot;PSRAM&quot;">​</a></h2><p>Some boards like the [pimoroni-pico-2-plus]{.title-ref} have a PSRAM which greatly increases the available memory for applications. The PSRAM is very slow compared to the internal SRAM, so depending on the application, different configuration might be necessary.</p><p>To use the PSRAM, enable the [RP23XX_PSRAM]{.title-ref} and select the GPIO pin used as CS1n with [RP23XX_PSRAM_CS1_GPIO]{.title-ref}. See the RP2350 datasheet for more information.</p><p>The port offers three options for configuring the heaps to use the external PSRAM, described below. More custom configurations can be used with custom board initialization functions.</p><h3 id="use-psram-and-sram-as-a-single-main-heap" tabindex="-1">Use PSRAM and SRAM as a single main heap <a class="header-anchor" href="#use-psram-and-sram-as-a-single-main-heap" aria-label="Permalink to &quot;Use PSRAM and SRAM as a single main heap&quot;">​</a></h3><p>This option is selected with [RP23XX_PSRAM_HEAP_SINGLE]{.title-ref} and requires [MM_REGIONS &gt; 1]{.title-ref}, as the PSRAM memory region will be added to the heap. It is also necessary to disable [MM_KERNEL_HEAP]{.title-ref}, as there will only be a single heap.</p><p>This is the simplest configuration because it will unify the memories into a single main heap. This way you can see the [free]{.title-ref} command output the total amount of usable RAM in the heap.</p><p>However, there are some unpredictable performance issues because there is no control of where the memory is allocated when issuing [malloc(3)]{.title-ref} and [free(3)]{.title-ref}. For this reason, you might want to consider the other options.</p><h3 id="use-psram-as-user-heap-sram-as-kernel-heap" tabindex="-1">Use PSRAM as user heap, SRAM as kernel heap <a class="header-anchor" href="#use-psram-as-user-heap-sram-as-kernel-heap" aria-label="Permalink to &quot;Use PSRAM as user heap, SRAM as kernel heap&quot;">​</a></h3><p>This option is selected with [RP23XX_PSRAM_HEAP_USER]{.title-ref} and requires [MM_KERNEL_HEAP]{.title-ref} to be set.</p><p>The external PSRAM is allocated to the default heap, while the internal SRAM will be used for the kernel heap. This configuration is useful because it allows drivers to use the SRAM and behave much faster than if they used memory on the PSRAM. While user applications can take the bull benefit of the larger slower heap on the PSRAM.</p><h3 id="use-psram-as-a-separate-heap" tabindex="-1">Use PSRAM as a separate heap <a class="header-anchor" href="#use-psram-as-a-separate-heap" aria-label="Permalink to &quot;Use PSRAM as a separate heap&quot;">​</a></h3><p>This option is selected with [RP23XX_PSRAM_HEAP_SEPARATE]{.title-ref} and requires [ARCH_HAVE_EXTRA_HEAPS]{.title-ref} to be set.</p><p class="title-ref">The internal SRAM is used as the main heap for kernel and applications, as if there was no PSRAM configured. The external PSRAM is configured as a separate user heap called [psram]{.title-ref} and can be used through the global variable [g_psramheap]{.title-ref} after including [rp23xx_heaps.h]</p><h2 id="programming" tabindex="-1">Programming <a class="header-anchor" href="#programming" aria-label="Permalink to &quot;Programming&quot;">​</a></h2><h3 id="programming-using-bootsel" tabindex="-1">Programming using BOOTSEL <a class="header-anchor" href="#programming-using-bootsel" aria-label="Permalink to &quot;Programming using BOOTSEL&quot;">​</a></h3><p>Connect board to USB port while holding BOOTSEL. The board will be detected as USB Mass Storage Device. Then copy &quot;nuttx.uf2&quot; into the device. (Same manner as the standard Pico SDK applications installation.)</p><h3 id="programming-with-picotool" tabindex="-1">Programming with picotool <a class="header-anchor" href="#programming-with-picotool" aria-label="Permalink to &quot;Programming with picotool&quot;">​</a></h3><p>You can use picotool to load the elf (or the uf2):</p><pre><code>picotool load nuttx -t elf
</code></pre><h3 id="programming-using-swd-debugger" tabindex="-1">Programming using SWD debugger <a class="header-anchor" href="#programming-using-swd-debugger" aria-label="Permalink to &quot;Programming using SWD debugger&quot;">​</a></h3><p>Most boards provide a serial (SWD) debug port. The &quot;nuttx&quot; ELF file can be uploaded with an appropriate SDB programmer module and companion software (openocd and gdb)</p><h2 id="running-nuttx" tabindex="-1">Running NuttX <a class="header-anchor" href="#running-nuttx" aria-label="Permalink to &quot;Running NuttX&quot;">​</a></h2><p>Most builds provide access to the console via UART0. To access this GPIO 0 and 1 pins must be connected to the device such as USB-serial converter.</p><p>The [usbnsh]{.title-ref} configuration provides the console access by USB CDC/ACM serial device. The console is available by using a terminal software on the USB host.</p><h2 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h2><blockquote><p>boards/<em>/</em></p></blockquote>`,45)]))}const m=a(r,[["render",n]]);export{c as __pageData,m as default};
