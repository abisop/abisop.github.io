import{_ as e,c as a,al as i,o as s}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"Rust in NuttX","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/rust.md","filePath":"en/guides/rust.md"}'),n={name:"en/guides/rust.md"};function o(l,t,r,p,u,c){return s(),a("div",null,t[0]||(t[0]=[i(`<h1 id="rust-in-nuttx" tabindex="-1">Rust in NuttX <a class="header-anchor" href="#rust-in-nuttx" aria-label="Permalink to &quot;Rust in NuttX&quot;">​</a></h1><p>Warning</p><p>This guide is under development. Rust support in NuttX is experimental.</p><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h2><p>NuttX is exploring Rust integration to provide memory safety guarantees and modern language features while maintaining its small footprint and real-time capabilities.</p><p>This guide covers:</p><ul><li>Setting up Rust toolchain for NuttX development</li><li>Building Rust components with NuttX</li><li>Interoperability between Rust and C</li><li>Testing Rust components</li></ul><h2 id="prerequisites" tabindex="-1">Prerequisites <a class="header-anchor" href="#prerequisites" aria-label="Permalink to &quot;Prerequisites&quot;">​</a></h2><ul><li>Rust toolchain installed (rustup recommended)</li><li>NuttX build environment configured</li><li>Basic knowledge of Rust and NuttX development</li></ul><h2 id="supported-platforms" tabindex="-1">Supported Platforms <a class="header-anchor" href="#supported-platforms" aria-label="Permalink to &quot;Supported Platforms&quot;">​</a></h2><ul><li>AArch64</li><li>ARMv7-A</li><li>ARMv6-M</li><li>ARMv7-M</li><li>ARMv8-M</li><li>RISCV32</li><li>RISCV64</li><li>X86</li><li>X86_64</li></ul><h2 id="getting-started" tabindex="-1">Getting Started <a class="header-anchor" href="#getting-started" aria-label="Permalink to &quot;Getting Started&quot;">​</a></h2><ol><li>Install Rust toolchain and switch to nightly</li></ol><p>Please refer to the official Rust installation guide for more details: <a href="https://www.rust-lang.org/tools/install" target="_blank" rel="noreferrer">https://www.rust-lang.org/tools/install</a></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>rustup toolchain install nightly</span></span>
<span class="line"><span>rustup default nightly</span></span></code></pre></div><ol start="2"><li>Prepare NuttX build environment</li></ol><p>Please ensure that you have a working NuttX build environment, and with the following PR merged or cherry-picked:</p><ul><li><a href="https://github.com/apache/nuttx-apps/pull/2487" target="_blank" rel="noreferrer">https://github.com/apache/nuttx-apps/pull/2487</a></li><li><a href="https://github.com/apache/nuttx/pull/15469" target="_blank" rel="noreferrer">https://github.com/apache/nuttx/pull/15469</a></li></ul><ol start="3"><li>Enable essential kernel configurations</li></ol><p>Please enable the following configurations in your NuttX configuration:</p><ul><li>CONFIG_SYSTEM_TIME64</li><li>CONFIG_FS_LARGEFILE</li><li>CONFIG_TLS_NELEM = 16</li><li>CONFIG_DEV_URANDOM</li></ul><p>The [rv-virt:nsh]{.title-ref} board using make as the build system is recommended for testing Rust applications as it has been verified to work with this configuration.</p><p>For [rv-virt:nsh]{.title-ref} board, you should disable [CONFIG_ARCH_FPU]{.title-ref} configuration since RISCV32 with FPU is not supported yet.</p><ol start="4"><li>Enable sample application</li></ol><p>Please enable the sample application in your NuttX configuration: - CONFIG_EXAMPLES_HELLO_RUST_CARGO</p><ol start="5"><li>Build and run the sample application</li></ol><p>Build the NuttX image and run it on your target platform:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>qemu-system-riscv32 -semihosting -M virt,aclint=on -cpu rv32 -smp 8 -bios nuttx/nuttx -nographic</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NuttShell (NSH) NuttX-12.8.0</span></span>
<span class="line"><span>nsh&gt; hello_rust_cargo</span></span>
<span class="line"><span>{&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30}</span></span>
<span class="line"><span>{&quot;name&quot;:&quot;Jane&quot;,&quot;age&quot;:25}</span></span>
<span class="line"><span>Deserialized: Alice is 28 years old</span></span>
<span class="line"><span>Pretty JSON:</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>&quot;name&quot;: &quot;Alice&quot;,</span></span>
<span class="line"><span>&quot;age&quot;: 28</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>Hello world from tokio!</span></span></code></pre></div><p>Congratulations! You have successfully built and run a Rust application on NuttX.</p><h2 id="specifying-target-cpu-for-optimization" tabindex="-1">Specifying Target CPU for Optimization <a class="header-anchor" href="#specifying-target-cpu-for-optimization" aria-label="Permalink to &quot;Specifying Target CPU for Optimization&quot;">​</a></h2><p>To optimize your Rust application for a specific CPU, you can use the [RUSTFLAGS]{.title-ref} environment variable to specify the target CPU. This can significantly improve performance by enabling CPU-specific optimizations.</p><p>The [RUSTFLAGS]{.title-ref} environment variable is particularly useful when you are working with CPUs that share the same Instruction Set Architecture (ISA) but have different microarchitectures. For example, both the Cortex-M33 and Cortex-M55 share the [thumbv8m.main]{.title-ref} target name, but they have different performance characteristics and features. By specifying the actual CPU core, you can take advantage of the specific optimizations and features of the target CPU, leading to better performance and efficiency.</p><p>For instance, if you are targeting a Cortex-M33, you would set the [RUSTFLAGS]{.title-ref} environment variable as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export RUSTFLAGS=&quot;-C target-cpu=cortex-m33&quot;</span></span></code></pre></div><p>And for a Cortex-M55, you would use:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export RUSTFLAGS=&quot;-C target-cpu=cortex-m55&quot;</span></span></code></pre></div><p>This ensures that the Rust compiler generates optimized code tailored to the specific CPU core, rather than a generic ISA.</p><ol><li>Set the [RUSTFLAGS]{.title-ref} environment variable to include the [--target-cpu]{.title-ref} flag:</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export RUSTFLAGS=&quot;-C target-cpu=your_cpu_model&quot;</span></span></code></pre></div><p>Replace [your_cpu_model]{.title-ref} with the specific CPU model you are targeting. For example, for an ARM Cortex-M4, you would use:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export RUSTFLAGS=&quot;-C target-cpu=cortex-m4&quot;</span></span></code></pre></div><ol start="2"><li>Build your NuttX image with the specified target CPU:</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>make</span></span></code></pre></div><p>This will ensure that the Rust compiler generates optimized code for the specified CPU.</p><h2 id="editor-integration" tabindex="-1">Editor Integration <a class="header-anchor" href="#editor-integration" aria-label="Permalink to &quot;Editor Integration&quot;">​</a></h2><p>To enable proper IDE support for Rust development in NuttX, you&#39;ll need to configure your editor to recognize the Rust project structure correctly. This section focuses on VS Code with rust-analyzer, which is the most popular setup.</p><ol><li>Create or update [.vscode/settings.json]{.title-ref} in your NuttX workspace:</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>    &quot;rust-analyzer.linkedProjects&quot;: [</span></span>
<span class="line"><span>        &quot;nuttx-apps/examples/rust/slint/Cargo.toml&quot;</span></span>
<span class="line"><span>    ]</span></span>
<span class="line"><span>}</span></span></code></pre></div><ol start="2"><li>(Optional) If you&#39;re using a custom target specification, you can set the [rust-analyzer.cargo.target]{.title-ref} setting:</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>    &quot;rust-analyzer.cargo.target&quot;: &quot;thumbv8m.main-nuttx-eabihf&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Note</p><p>Since NuttX now supports the Rust standard library (std), specifying an exact target triple is usually not necessary. The default host target should work fine for most cases.</p><p>If you&#39;re working with a crate that tightly depends on the NuttX target, you can specify the target triple as shown above to get more accurate code analysis.</p><p>This configuration helps rust-analyzer understand your project structure and provide accurate code analysis, auto-completion, and other IDE features while working with Rust code in NuttX.</p>`,54)]))}const g=e(n,[["render",o]]);export{h as __pageData,g as default};
