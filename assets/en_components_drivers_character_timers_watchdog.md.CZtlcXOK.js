import{_ as a,c as o,al as n,j as e,a as t,o as l}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"Watchdog Timer Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/character/timers/watchdog.md","filePath":"en/components/drivers/character/timers/watchdog.md"}'),r={name:"en/components/drivers/character/timers/watchdog.md"};function s(c,i,d,h,p,u){return l(),o("div",null,i[0]||(i[0]=[n(`<h1 id="watchdog-timer-drivers" tabindex="-1">Watchdog Timer Drivers <a class="header-anchor" href="#watchdog-timer-drivers" aria-label="Permalink to &quot;Watchdog Timer Drivers&quot;">​</a></h1><p>NuttX supports a low-level, two-part watchdog timer driver.</p><ol><li>An &quot;upper half&quot;, generic driver that provides the common watchdog timer interface to application level code, and</li><li>A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the watchdog timer functionality.</li></ol><p>Files supporting the watchdog timer driver can be found in the following locations:</p><ul><li><strong>Interface Definition</strong>. The header file for the NuttX watchdog timer driver reside at <code>include/nuttx/timers/watchdog.h</code>. This header file includes both the application level interface to the watchdog timer driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers. The watchdog timer driver uses a standard character driver framework.</li><li><strong>&quot;Upper Half&quot; Driver</strong>. The generic, &quot;upper half&quot; watchdog timer driver resides at <code>drivers/timers/watchdog.c</code>.</li><li><strong>&quot;Lower Half&quot; Drivers</strong>. Platform-specific watchdog timer drivers reside in <code>arch/&lt;architecture&gt;//src/&lt;hardware&gt;</code> directory for the specific processor <code>&lt;architecture&gt;</code> and for the specific <code>&lt;chip&gt;</code> watchdog timer peripheral devices.</li></ul><p>There are two ways to enable Watchdog Timer Support along with the Watchdog Example. The first is faster and simpler. Just run the following command to use a ready config file with watchdog timer support and example included. You need to check if there&#39;s a watchdog config file for your specific chip. You may check it at the specific board&#39;s path: <code>/boards/&lt;arch&gt;/&lt;chip&gt;/&lt;board&gt;/config</code>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> ./tools/configure.sh &lt;board&gt;:watchdog</span></span></code></pre></div><p>And the second way is creating your own config file. To do so, follow the next instructions.</p><h2 id="enabling-the-watchdog-support-and-example-in-menuconfing" tabindex="-1">Enabling the Watchdog Support and Example in <code>menuconfing</code> <a class="header-anchor" href="#enabling-the-watchdog-support-and-example-in-menuconfing" aria-label="Permalink to &quot;Enabling the Watchdog Support and Example in \`menuconfing\`&quot;">​</a></h2><ol><li><p>Select Watchdog Timer Instances</p><p>To select these wdts browse in the <code>menuconfig</code> using the following path:</p><p>Go into menu <code>System Type --&gt; &lt;Chip&gt; Peripheral Selection</code>{.interpreted-text role=&quot;menuselection&quot;} and press <code>Enter</code>{.interpreted-text role=&quot;kbd&quot;}. Then select one or more watchdog timers according to availability of your chip.</p></li><li><p>Enable the Watchdog Timer Support</p><p>Go into menu <code>Device Drivers --&gt; Timer Driver Support</code>{.interpreted-text role=&quot;menuselection&quot;} and press</p><ul><li>[x] Watchdog Timer Support</li></ul></li><li><p>Include the Watchdog Timer Example</p><p>Go into menu <code>Application Configuration --&gt; Examples</code>{.interpreted-text role=&quot;menuselection&quot;} and press <code>Enter</code>{.interpreted-text role=&quot;kbd&quot;}. Then select the Watchdog Timer example.</p></li></ol><blockquote><ul><li>[x] Watchdog Timer example</li></ul></blockquote><p>Below the option, it is possible to manually configure some standard parameters that will be used by the example, but they also can be passed as command line arguments later. The parameters are the following: the standard timer device path (which defines the WDT instance), the timeout period (which is the period on which the watchdog will expire), the ping delay (which is the interval period between feeding the dog) and the ping time (which is the total interval that the example will feed the dog, after this interval, the dog will starve and the chip will trigger an interrupt or reset.</p><ol start="4"><li><p>Include the Debug Watchdog Feature</p><p>In order to get the watchdog timer status, you need to enable it. For production code and for your application you may disable it.</p><p>Go into menu <code>Build Setup --&gt; Debug Options</code>{.interpreted-text role=&quot;menuselection&quot;} and press <code>Enter</code>{.interpreted-text role=&quot;kbd&quot;}. Then enable:</p><ul><li>[x] Enable Debug Features</li><li>[x] Watchdog Timer Debug Features</li></ul></li></ol><h2 id="watchdog-timer-example" tabindex="-1">Watchdog Timer Example <a class="header-anchor" href="#watchdog-timer-example" aria-label="Permalink to &quot;Watchdog Timer Example&quot;">​</a></h2><p>The previously selected example will basically do the following:</p><ul><li>Open the watchdog device</li><li>Set the watchdog timeout</li><li>Start the watchdog timer</li><li>Ping (feed the dog) during the <code>pingtime</code> with a delay of <code>pingdelay</code> and print out the wdt status in case debug was enabled.</li><li>Enter into an endless loop without pinging. It will cause the watchdog timer to reset the chip on timeout, i.e., after timer expiration.</li></ul><p>The <a href="https://github.com/apache/nuttx-apps/blob/master/examples/watchdog/watchdog_main.c" target="_blank" rel="noreferrer">example code</a> may be explored, its path is at <code>/examples/watchdog/watchdog_main.c</code> in the apps&#39; repository.</p><p>In NuttX, the watchdog timer driver is a character driver and when a chip supports multiple watchdog timers, each one is accessible through its respective special file in <code>/dev</code> directory. Each watchdog timer is registered using a unique numeric identifier (i.e. <code>/dev/watchdog0</code>, <code>/dev/watchdog1</code>, ...).</p><p>Use the following command to run the example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nsh&gt; wdog</span></span></code></pre></div><p>This command will use the watchdog timer 0. To use the others, specify it through a parameter (where x is the timer number):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nsh&gt; wdog -i /dev/watchdogx</span></span></code></pre></div><h2 id="application-level-interface" tabindex="-1">Application Level Interface <a class="header-anchor" href="#application-level-interface" aria-label="Permalink to &quot;Application Level Interface&quot;">​</a></h2><p>The first necessary thing to be done in order to use the watchdog timer driver in an application is to include the header file for the NuttX Watchdog timer driver. It contains the Application Level Interface to the timer driver. To do so, include:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;nuttx/timers/watchdog.h&gt;</span></span></code></pre></div><p>At an application level, the watchdog timer functionalities may be accessed through <code>ioctl</code> systems calls. These <code>ioctl</code> commands internally call lower-half layer operations and the parameters are forwarded to these operations through the <code>ioctl</code> system call. The example provides a great resource to demonstrate how to use those <code>ioctl</code> commands. The available <code>ioctl</code> commands are:</p><p>This command starts the watchdog timer.</p><p>This command stops the watchdog timer.</p><p>This command gets the status of the watchdog timer. It receives a writeable pointer to struct <code>watchdog_status_s</code> as parameter. The lower-half driver writes the current status in this struct.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct watchdog_status_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  uint32_t  flags;          /* See WDFLAGS_* definitions above */</span></span>
<span class="line"><span>  uint32_t  timeout;        /* The current timeout setting (in milliseconds) */</span></span>
<span class="line"><span>  uint32_t  timeleft;       /* Time left until the watchdog expiration</span></span>
<span class="line"><span>                         * (in milliseconds) */</span></span>
<span class="line"><span>};</span></span></code></pre></div><p>This command sets the timeout value, i.e., the value that will trigger the reset or interrupt. The argument is a <code>uint32_t</code> value in milliseconds.</p><p>This command registers an user callback that will be triggered on timeout. It receives as argument a pointer to struct <code>watchdog_capture_s</code>. If the user callback is NULL, then it configures only to reset. Not all chips support interrupt on timeout. This command is optional, i.e., if it&#39;s not used, the standard behaviour is to reset on timeout.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct watchdog_capture_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  CODE xcpt_t newhandler;   /* The new watchdog capture handler */</span></span>
<span class="line"><span>  CODE xcpt_t oldhandler;   /* The previous watchdog capture handler (if any) */</span></span>
<span class="line"><span>};</span></span></code></pre></div><h2 id="enable-built-in-system-monitoring-to-reset-the-watchdog" tabindex="-1">Enable Built in System Monitoring to reset the watchdog <a class="header-anchor" href="#enable-built-in-system-monitoring-to-reset-the-watchdog" aria-label="Permalink to &quot;Enable Built in System Monitoring to reset the watchdog&quot;">​</a></h2><p>The auto-monitor provides an OS-internal mechanism to automatically start and repeatedly reset the watchdog.</p><p>To enable it, follow the next instructions:</p><ol><li>Select a Watchdog Timer Instance</li></ol>`,37),e("blockquote",null,[e("p",null,[t("To select the wdt browse in the "),e("code",null,"menuconfig"),t(" using the following path:")]),e("p",null,[t("Go into menu "),e("code",null,"System Type --> <Chip> Peripheral Selection"),t('{.interpreted-text role="menuselection"} and press '),e("code",{class:"interpreted-text",role:"kbd"},"Enter"),t(". Then select one watchdog timer.")])],-1),e("ol",{start:"2"},[e("li",null,[e("p",null,"Enable the Auto-monitor option"),e("p",null,[t("Go into menu "),e("code",null,"Device Drivers --> Timer Driver Support"),t('{.interpreted-text role="menuselection"} and press')]),e("ul",null,[e("li",null,"[x] Watchdog Timer Support")]),e("p",null,[t("Then press "),e("code",{class:"interpreted-text",role:"kbd"},"Enter"),t(" again to enter into the Watchdog Timer Support menu. And finally enable the Auto-monitor option:")]),e("ul",null,[e("li",null,"[x] Auto-monitor")]),e("p",null,"After selecting the option you may want to configure some parameters:"),e("ul",null,[e("li",null,[e("p",null,[e("strong",null,"Timeout"),t(": It is the watchdog timer expiration time in seconds.")])]),e("li",null,[e("p",null,[e("strong",null,"Keep a live interval"),t(": This is the interval in which the watchdog will be fed. It is in seconds. It can't be bigger than the timeout. If this interval is equal to timeout interval, than this interval will automatically change to half timeout.")])]),e("li",null,[e("p",null,[e("strong",null,"Keep alive by"),t(": This is a choice to determine who is going to feed the dog. There are 4 possible choices that are described as follows.")]),e("p",null,[e("code",null,"Capture callback"),t(": This choice registers a watchdog timer callback to reset the watchdog every time it expires, i.e., on timeout.")]),e("p",null,[e("code",null,"Timer callback"),t(': This choice also uses a timer callback to reset the watchdog, but it will reset the watchdog every "keep a live interval".')]),e("p",null,[e("code",null,"Worker callback"),t(': This choice uses a Work Queue to reset the watchdog every "keep a live interval". This choice depends on having the Low or High Priority Work Queue enabled. If only the High Priority Work Queue is enabled, this one will be used, otherwise Low Priority Work Queue is used.')]),e("p",null,[t("So, before enabling it, go into menu "),e("code",null,"RTOS Features --> Work queue support"),t('{.interpreted-text role="menuselection"} and press '),e("code",null,"Enter"),t('{.interpreted-text role="kbd"}.')]),e("ul",null,[e("li",null,"[x] Low priority (kernel) worker thread")]),e("p",null,[e("code",null,"Idle callback"),t(": This choice sets an Idle callback to feed the dog. It depends on the PM module, because this callback is triggered by the PM state change. To enable it do the following:")]),e("p",null,[t("Go into menu "),e("code",null,"Device Drivers"),t('{.interpreted-text role="menuselection"} and enable:')]),e("ul",null,[e("li",null,"[x] Power Management Support")]),e("p",null,"After selecting one of these choices, the chip will keep itself alive by one of these options.")])])])],-1)]))}const w=a(r,[["render",s]]);export{m as __pageData,w as default};
