import{_ as t,c as i,al as o,o as n}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"NSH Network Link Management","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/nsh_network_link_management.md","filePath":"en/guides/nsh_network_link_management.md"}'),a={name:"en/guides/nsh_network_link_management.md"};function r(s,e,l,h,d,c){return n(),i("div",null,e[0]||(e[0]=[o('<h1 id="nsh-network-link-management" tabindex="-1">NSH Network Link Management <a class="header-anchor" href="#nsh-network-link-management" aria-label="Permalink to &quot;NSH Network Link Management&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/NSH+Network+Link+Management" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/NSH+Network+Link+Management</a></p><p>In the past, if the network was not connected when NuttX started, two problems could arise:</p><ol><li>It could take a very long time for the NSH prompt to appear because of the sequential initialization (for example, when the network cable is not connected).</li><li>After NuttX came up, installing the network cable would not enable the network; the only way to recover networking was to connect the cable and reset the board.</li></ol><p>Network link management capability has now been added to NSH to address these problems.</p><h2 id="configuration-options" tabindex="-1">Configuration Options <a class="header-anchor" href="#configuration-options" aria-label="Permalink to &quot;Configuration Options&quot;">​</a></h2><p>A simple feature can be enabled to move network initialization to a separate thread so that it is no longer performed sequentially. With this feature, the network bringup occurs asynchronously, and the NSH prompt appears immediately (although the network may not be available until some time later). That feature is enabled with the following setting and is the first prerequisite for the full NSH link management feature:</p><ul><li><code>CONFIG_NSH_NETINIT_THREAD</code>. Refer to the help text in the Kconfig file for this option (<code>apps/nshlib/Kconfig</code>). Additional information about this setting is included there.</li></ul><p>The logic that implements NSH network management is provided in <code>apps/nshlib/nsh_netinit.c</code>. The behavior of that logic depends on multiple configuration settings. First, there are some additional prerequisites that must be satisfied:</p><ul><li><p><code>CONFIG_NETDEV_PHY_IOCTL</code> Enable PHY IOCTL commands in the Ethernet device driver. Special IOCTL commands must be provided by the Ethernet driver to support certain PHY operations needed for link management. These operations are not complex and are implemented for Atmel SAM4/4, SAMA5 families, and for the STMicro STM32. See <code>nuttx/arch/arm/src/sam34/sam_emac.c</code>, <code>nuttx/arch/arm/src/sam34/sam_emaca.c</code>, <code>sam_emacb.c</code>, and <code>sam_gmac.c</code>, and <code>nuttx/arch/arm/src/stm32/stm32_eth.c</code>.</p></li><li><p><code>CONFIG_ARCH_PHY_INTERRUPT</code> This is not a user-selectable option. Rather, it is set when selecting a board that supports PHY interrupts. In most architectures, the PHY interrupt is not directly associated with the Ethernet driver. Instead, the PHY interrupt is provided through some board-specific GPIO, and the board-specific logic must provide support for that GPIO interrupt. Specifically, the board logic must:</p><ol><li>Provide the function <code>arch_phy_irq()</code> as described and prototyped in <code>nuttx/include/nuttx/arch.h</code>.</li><li>Select <code>CONFIG_ARCH_PHY_INTERRUPT</code> in the board configuration file to advertise that <code>arch_phy_irq()</code> is supported.</li></ol><p>Examples can be found at:</p><ul><li><code>nuttx/boards/arm/sama5/sama5d3x-ek/src/sam_ethernet.c</code></li><li><code>nuttx/boards/arm/sama5/sama5d3-xplained/src/sam_ethernet.c</code></li><li><code>nuttx/boards/arm/sama5/sama5d4-ek/src/sam_ethernet.c</code></li></ul></li><li><p>Other requirements: UDP support must be enabled (<code>CONFIG_NET_UDP</code>), and signals must not be disabled (<code>CONFIG_DISABLE_SIGNALS</code>).</p></li></ul><p>With all these prerequisites in place, NSH network management can be enabled on the NSH network initialization thread by selecting these additional options:</p><ul><li><code>CONFIG_NSH_NETINIT_MONITOR</code> By default, the network initialization thread brings up the network (or fails while trying) then exits, freeing all resources it used. If this option is selected, however, the network initialization thread will persist indefinitely to monitor the network status. Should the network go down (for example, if the cable is removed), the thread will monitor the link status and attempt to bring the network back up. In this scenario, the resources required for network initialization are never released.</li></ul><p>If the network monitor is selected, additional options control its behavior:</p><ul><li><code>CONFIG_NSH_NETINIT_SIGNO</code> The network monitor logic receives signals when there is a change in link status. This setting can be used to customize the signal number to avoid conflicts.</li><li><code>CONFIG_NSH_NETINIT_RETRYMSEC</code> When the network is down, the initialization thread will periodically attempt to bring the network back up. Because this can be time-consuming, the retry operation is performed only at the interval specified by this value, in milliseconds.</li><li><code>CONFIG_NSH_NETINIT_THREAD_STACKSIZE</code> The stack size for the network initialization thread.</li><li><code>CONFIG_NSH_NETINIT_THREAD_PRIORITY</code> The network initialization thread priority.</li></ul><h2 id="overview-of-the-operation" tabindex="-1">Overview of the Operation <a class="header-anchor" href="#overview-of-the-operation" aria-label="Permalink to &quot;Overview of the Operation&quot;">​</a></h2><p>Below is a summary of how the NSH management thread operates:</p><ol><li>During initialization, the thread opens a UDP socket for IOCTL operations and connects a signal handler.</li><li>It enters a loop. At the beginning of each loop iteration, the thread uses an IOCTL command to register (or re-register) with the Ethernet device to receive a signal whenever the PHY reports a link up or link down interrupt. Re-registration is necessary because the notification disarms after each PHY interrupt.</li><li>The thread reads the link status from both the PHY and the Ethernet device. If they disagree, the network monitor uses an IOCTL command to bring the Ethernet driver up or down to match the current state of the network. If the network is lost, the monitor brings the Ethernet driver down; if the network is regained, the monitor brings the Ethernet driver back up and re-establishes the connection.</li><li>If the PHY and the Ethernet driver agree on the link state, no action is performed.</li><li>At the end of the loop, the network monitor waits for a PHY interrupt or a timeout. When either occurs, control returns to the top of the loop, and the process repeats.</li><li>If a PHY interrupt happens, a signal is delivered to the task and handled by the network monitor&#39;s signal handler, which posts a semaphore to immediately re-awaken the network monitor from its wait.</li></ol>',18)]))}const u=t(a,[["render",r]]);export{m as __pageData,u as default};
