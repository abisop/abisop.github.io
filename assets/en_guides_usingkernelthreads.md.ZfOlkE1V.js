import{_ as a,c as t,al as r,o as s}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Using Kernel Threads","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/usingkernelthreads.md","filePath":"en/guides/usingkernelthreads.md"}'),i={name:"en/guides/usingkernelthreads.md"};function o(n,e,d,h,c,l){return s(),t("div",null,e[0]||(e[0]=[r('<h1 id="using-kernel-threads" tabindex="-1">Using Kernel Threads <a class="header-anchor" href="#using-kernel-threads" aria-label="Permalink to &quot;Using Kernel Threads&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Using+Kernel+Threads" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Using+Kernel+Threads</a></p><h2 id="build-configurations" tabindex="-1">Build Configurations <a class="header-anchor" href="#build-configurations" aria-label="Permalink to &quot;Build Configurations&quot;">​</a></h2><p>NuttX can be built in three different configurations: (1) as a FLAT build where all of the code resides in a common address space, (2) as a PROTECTED build where a memory protection unit (MPU) is used to separate the memory into privileged memory for the OS and unprivileged memory for all applications, or (3) as a KERNEL build where a memory management unit (MMU) is used place the OS in a privileged address space and to place to task (or process) in its own virtual address space.</p><p>In the last two configurations, applications reside outside of the OS address space and in all configurations applications do not have have access to any internal resources of the OS.</p><p>More information about these build configurations can be found on <a href="https://cwiki.apache.org/confluence/display/NUTTX/Memory+Configurations" target="_blank" rel="noreferrer">the Memory Configuration Wiki page</a>.</p><h2 id="thread-types" tabindex="-1">Thread Types <a class="header-anchor" href="#thread-types" aria-label="Permalink to &quot;Thread Types&quot;">​</a></h2><p>NuttX supports three classes of threads: tasks, pthreads, and kernel threads. tasks and pthreads are both application threads and are distinguished by some usage semantics and by their hierarchical relationship. tasks are created via several different mechanisms: <code>task_create()</code>, <code>task_spawn()</code>, <code>execv()</code>, <code>posix_spawn()</code>, and others. Tasks may then create pthreads using <code>pthread_create()</code>.</p><p>More information about tasks and pthreads can be found on the <a href="https://cwiki.apache.org/confluence/display/NUTTX/NuttX+Tasking" target="_blank" rel="noreferrer">NuttX Tasking</a> Wiki page.</p><h2 id="kernel-threads" tabindex="-1">Kernel Threads <a class="header-anchor" href="#kernel-threads" aria-label="Permalink to &quot;Kernel Threads&quot;">​</a></h2><p>Kernel threads are really like tasks except that they run inside the operating system and are started with <code>kthread_create()</code> which is prototyped in <code>include/nuttx/kthread.h</code>. The differ from tasks in that (1) in PROTECTED and KERNEL builds, they have full supervisor privileges, and (2) they have full access to all internal OS resources.</p><p>In order to build the task into the OS as a kernel thread, you simply have to: (1) place the kernel thread code in your board source code directory, and (2) start it with <code>kthread_create()</code> in your board bring-up logic. There a few examples of this in the NuttX source tree. Here is one: <a href="https://github.com/apache/nuttx/blob/master/boards/arm/stm32/viewtool-stm32f107/src/stm32_highpri.c" target="_blank" rel="noreferrer">https://github.com/apache/nuttx/blob/master/boards/arm/stm32/viewtool-stm32f107/src/stm32_highpri.c</a></p><p>So that is another trick that you can use to architecture optimal solutions: Create parts of your applications as kernel threads: They need to reside in your board/src directory and the need to be started with <code>kthread_create()</code> in your board bring-up logic. And that is it.</p>',14)]))}const f=a(i,[["render",o]]);export{u as __pageData,f as default};
