import{_ as l,c as i,al as s,j as e,a,o as n}from"./chunks/framework.NFAqBSgQ.js";const v=JSON.parse('{"title":"LCD Character Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/special/lcd.md","filePath":"en/components/drivers/special/lcd.md"}'),o={name:"en/components/drivers/special/lcd.md"};function d(c,t,r,p,h,u){return n(),i("div",null,t[0]||(t[0]=[s(`<p>Note</p><p>See also the usage of the LCD driver in the graphics/ directory.</p><h1 id="lcd-character-drivers" tabindex="-1">LCD Character Drivers <a class="header-anchor" href="#lcd-character-drivers" aria-label="Permalink to &quot;LCD Character Drivers&quot;">​</a></h1><p>The LCD driver exposes the LCD interface to userspace via <code>ioctl()</code> commands.</p><p>The LCD driver is intended to be used in the following scenarios:</p><ul><li></li></ul><pre><code>On memory-constrained devices, as it doesn\\&#39;t require a buffer to represent

:   the whole display:

    -   Hence, it\\&#39;s an alternative to the
        \\[[framebuffer]{.title-ref}\\]([framebuffer]{.title-ref}.md)
</code></pre><ul><li>For graphics libraries that draw specific areas of the displays, like <code>LVGL</code></li></ul><h2 id="binding" tabindex="-1">Binding <a class="header-anchor" href="#binding" aria-label="Permalink to &quot;Binding&quot;">​</a></h2><p>LCD drivers usually are not directly accessed by user code, but are usually bound to another, higher-level device driver. In general, the binding sequence is:</p><ol><li>Get an instance of <code>struct lcd_dev_s</code> from the hardware-specific LCD screen driver, and</li><li>Provide that instance to the initialization method of the higher-level character driver.</li></ol><h3 id="generic-lcd-character-driver" tabindex="-1">Generic LCD Character Driver <a class="header-anchor" href="#generic-lcd-character-driver" aria-label="Permalink to &quot;Generic LCD Character Driver&quot;">​</a></h3><p>This example will walk through the path from userspace to hardware-specific details on how an LCD screen is bound to an LCD character driver.</p><ul><li></li></ul><pre><code>\`include/nuttx/lcd/lcd.h\` provides all structures and APIs needed to work

:   with LCD screens drivers:

    -   This header file also depends on some of the same
        definitions used for the frame buffer driver as provided in
        \`include/nuttx/video/fb.h\`
</code></pre><ul><li></li></ul><pre><code>\`drivers/lcd/lcd_dev.c\` is the higher-level device driver. An instance of

:   \`struct lcd_dev_s\` will be provided to it:

    -   \`include/nuttx/lcd/lcd_dev.h\` prototypes public structures
        and functions;
    -   \`lcddev_register\` registers the LCD character driver as
        \`/dev/lcdN\` where N is the display number and,
    -   calls the \`board_lcd_getdev\`, an LCD-specific function
        usually defined in \`boards/&lt;arch&gt;/&lt;chip&gt;/&lt;board&gt;/src\` and
        prototyped in \`include/nuttx/board.h\`
</code></pre><ul><li><p>Finally, the LCD screen drivers are usually available at <code>drivers/lcd/</code> and implement the callbacks defined at <code>include/nuttx/lcd/lcd.h</code>:</p><blockquote><ul><li><code>include/nuttx/lcd/lcd.h</code> provides structures and APIs needed to work with LCD screens, whether using the framebuffer adapter or the [[lcd]{.title-ref};]([lcd]{.title-ref};.md)</li></ul></blockquote></li></ul><h2 id="supported-devices" tabindex="-1">Supported devices <a class="header-anchor" href="#supported-devices" aria-label="Permalink to &quot;Supported devices&quot;">​</a></h2><p>Reusable LCD drivers reside in the drivers/lcd directory:</p><h3 id="lcds" tabindex="-1">LCDs <a class="header-anchor" href="#lcds" aria-label="Permalink to &quot;LCDs&quot;">​</a></h3><ul><li><p><code>mio283qt2.c</code></p><p>This is a driver for the MI0283QT-2 LCD from Multi-Inno Technology Co., Ltd. This LCD is based on the Himax HX8347-D LCD controller.</p></li><li><p><code>mio283qt9a.c</code></p><p>This is a driver for the MI0283QT-9A LCD from Multi-Inno Technology Co., Ltd. This LCD is based on the Ilitek ILI9341 LCD controller.</p></li><li><p><code>ssd12989.c</code></p><p>Generic LCD driver for LCDs based on the Solomon Systech SSD1289 LCD controller. Think of this as a template for an LCD driver that you will probably have to customize for any particular LCD hardware. (See also boards/arm/stm32/hymini-stm32v/src/ssd1289.c below).</p></li><li><p><code>st7567.c</code></p><p>LCD Display Module, ST7567, Univision Technology Inc. Used with the LPCXpresso and Embedded Artists base board.</p></li><li><p><code>memlcd.c</code></p><p>Sharp Memory LCD Suite, LS013B7DH01, LS013B7DH03, etc. There are some more different models, they are basically controlled by similar logics, thus this driver can be extended.</p></li><li><p><code>ra8875.c</code></p><p>RAiO Technologies RA8875 LCD controller. Contributed by Marten Svanfeldt.</p></li></ul><h3 id="oleds" tabindex="-1">OLEDs <a class="header-anchor" href="#oleds" aria-label="Permalink to &quot;OLEDs&quot;">​</a></h3><ul><li><p><code>p14201.c</code></p><p>Driver for RiT P14201 series display with SD1329 IC controller. Based on the SD1329 controller. This OLED is used with older versions of the TI/Luminary LM3S8962 Evaluation Kit. Example usage:</p><pre><code>boards/arm/tiva/lm3s6965-ek/src
boards/arm/tiva/lm3s8962-ek/src
</code></pre></li><li><p><code>ug-2864ambag01.c</code></p><p>OLED Display Module, UUG-2864AMBAG01, Univision Technology Inc. Based on the SH1101A controller. Example usage:</p><pre><code>boards/arm/stm32/stm32f4discovery
boards/arm/lpc214x/zp214xpa
</code></pre></li><li><p><code>ug-9664hswag01.c</code></p><p>OLED Display Module, UG-9664HSWAG01, Univision Technology Inc. Based on the SSD1305 controller. Used with the LPC Xpresso and Embedded Artists base board. Example usage:</p><pre><code>boards/arm/lpc71xx_40xx/lpcxpresso-lpc1768
</code></pre></li><li><p><code>ssd1306.c</code></p><p>OLED Display Modules based on the SSD1306 controllers. This includes the UG-2864HSWEG01 and UG2832HSWEG04, both from Univision Technology Inc. The latter is used with the OLED1 module that comes with the Atmel SAM4l Xplained Pro board. This driver also supports Densitron Technologies DD-12864WO-4A which is based on SSD1309 LCD controller. Example usage:</p><pre><code>boards/arm/stm32/stm32f4discovery
boards/arm/sam34/sam4l-xplained
</code></pre></li></ul><h3 id="segment-lcds-slcds" tabindex="-1">Segment LCDS (SLCDs) <a class="header-anchor" href="#segment-lcds-slcds" aria-label="Permalink to &quot;Segment LCDS (SLCDs)&quot;">​</a></h3><ul><li><p><code>pcf8574_lcd_backpack.c</code></p><p>See pcf8574_lcd_backpack_readme.txt.</p></li></ul><h2 id="examples" tabindex="-1">Examples <a class="header-anchor" href="#examples" aria-label="Permalink to &quot;Examples&quot;">​</a></h2>`,27),e("p",null,[a("Examples apply to specific cases of the "),e("code",{class:"interpreted-text",role:"ref"},"genericlcdlcd"),a(":")],-1),s(`<h3 id="ttgo-t-display-esp32-board" tabindex="-1">TTGO T-Display ESP32 board <a class="header-anchor" href="#ttgo-t-display-esp32-board" aria-label="Permalink to &quot;TTGO T-Display ESP32 board&quot;">​</a></h3><p>This board contains an ST7789 TFT Display (135x240). By selecting the <code>ttgo_t_display_esp32:lvgl_lcd</code> config, the <code>lvgldemo</code> example will be built with the LCD character interface.</p><ul><li><code>boards/xtensa/esp32/ttgo_t_display_esp32/src/esp32_bringup.c</code> registers the LCD character driver:</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_LCD_DEV</span></span>
<span class="line"><span> ret = board_lcd_initialize();</span></span>
<span class="line"><span> if (ret &lt; 0)</span></span>
<span class="line"><span>   {</span></span>
<span class="line"><span>     syslog(LOG_ERR, &quot;ERROR: board_lcd_initialize() failed: %d\\n&quot;, ret);</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span></span></span>
<span class="line"><span> ret = lcddev_register(0);</span></span>
<span class="line"><span> if (ret &lt; 0)</span></span>
<span class="line"><span>   {</span></span>
<span class="line"><span>     syslog(LOG_ERR, &quot;ERROR: lcddev_register() failed: %d\\n&quot;, ret);</span></span>
<span class="line"><span>   }</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><ul><li><p><code>board_lcd_initialize</code> and <code>board_lcd_getdev</code> are defined at <code>boards/xtensa/esp32/common/src/esp32_st7789.c</code>;</p><blockquote><ul><li><code>board_lcd_initialize</code> initializes the LCD hardware on the board by defining the SPI interface which is connected to the display controller;</li></ul></blockquote></li><li><p><code>lcddev_register</code> then calls <code>board_lcd_getdev</code>:</p><blockquote><ul><li><code>board_lcd_getdev</code> calls the <code>st7789_lcdinitialize</code> and returns a reference to the LCD object for the specified LCD;</li><li><code>st7789_lcdinitialize</code> is part of the LCD screen driver at <code>drivers/lcd/st7789.c</code>;</li></ul></blockquote></li><li><p>The LVGL demo application (<code>lvgldemo</code>) makes use of the <code>ioctl</code> system call to trigger an <code>LCDDEVIO_PUTAREA</code> request to the higher-level device driver to refresh the LCD screen with data:</p></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ioctl(state.fd, LCDDEVIO_PUTAREA, (unsigned long)((uintptr_t)&amp;lcd_area));;</span></span></code></pre></div><h3 id="nuttx-simulator" tabindex="-1">NuttX Simulator <a class="header-anchor" href="#nuttx-simulator" aria-label="Permalink to &quot;NuttX Simulator&quot;">​</a></h3><p>[[NuttX Simulator &lt;/platform](\`NuttX Simulator &lt;/platform.md)s/sim/sim/index&gt;]{.title-ref} provides a X11-based LCD</p><p>: character driver to simulate the LCD character displat usage into a X11-compatible host.</p><p>By selecting the <code>sim:lvgl_lcd</code> config, the <code>lvgldemo</code> example will be built with the LCD character interface.</p>`,10),e("ul",null,[e("li",null,[e("p",null,[e("code",null,"boards/sim/sim/sim/src/sim_bringup.c"),a(" registers the lcd driver the same way "),e("code",{class:"interpreted-text",role:"ref"},"ttgotdisplayesp32_lcd"),a(";")])]),e("li",null,[e("p",null,[e("code",null,"arch/sim/src/sim/up_lcd.c"),a(" and "),e("code",null,"arch/sim/src/sim/up_x11framebuffer.c"),a(" will be built as "),e("code",null,"CONFIG_SIM_LCDDRIVER = y"),a(" and "),e("code",null,"CONFIG_SIM_X11FB = y"),a(" are set, respectively;")]),e("blockquote",null,[e("ul",null,[e("li",null,[e("p",null,[e("code",null,"up_lcd.c"),a(" provides "),e("code",null,"board_lcd_initialize"),a(" and "),e("code",null,"board_lcd_getdev"),a(":")]),e("blockquote",null,[e("ul",null,[e("li",null,[e("code",null,"board_lcd_initialize"),a(" calls "),e("code",null,"up_x11initialize"),a(" from "),e("code",null,"up_x11framebuffer.c"),a(' that initializes a X11-based window as an LCD character device. This is the underlying "driver".')])])])])])])]),e("li",null,[e("p",null,[a("The LVGL demo application ("),e("code",null,"lvgldemo"),a(") makes use of the "),e("code",null,"ioctl"),a(" system call to trigger an "),e("code",null,"LCDDEVIO_PUTAREA"),a(" request to the higher-level device driver to refresh the LCD screen with data as usual;")])])],-1),s(`<h2 id="lcd-header-files" tabindex="-1">LCD Header files <a class="header-anchor" href="#lcd-header-files" aria-label="Permalink to &quot;LCD Header files&quot;">​</a></h2><p><code>include/nuttx/lcd/lcd.h</code></p><blockquote><p>Structures and APIs needed to work with LCD drivers are provided in this header file. This header file also depends on some of the same definitions used for the frame buffer driver as provided in include/nuttx/video/fb.h.</p></blockquote><p><code>struct lcd_dev_s</code></p><blockquote><p>Each LCD device driver must implement an instance of struct lcd_dev_s. That structure defines a call table with the following methods:</p><ul><li><p>Get information about the LCD video controller configuration and the configuration of each LCD color plane.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int (*getvideoinfo)(FAR struct lcd_dev_s *dev,</span></span>
<span class="line"><span>                    FAR struct fb_videoinfo_s *vinfo);</span></span>
<span class="line"><span>int (*getplaneinfo)(FAR struct lcd_dev_s *dev, unsigned int planeno,</span></span>
<span class="line"><span>                    FAR struct lcd_planeinfo_s *pinfo);</span></span></code></pre></div></li><li><p>The following are provided only if the video hardware supports RGB color mapping:</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int (*getcmap)(FAR struct lcd_dev_s *dev,</span></span>
<span class="line"><span>               FAR struct fb_cmap_s *cmap);</span></span>
<span class="line"><span>int (*putcmap)(FAR struct lcd_dev_s *dev,</span></span>
<span class="line"><span>               FAR const struct fb_cmap_s *cmap);</span></span></code></pre></div></blockquote></li><li><p>The following are provided only if the video hardware supports a hardware cursor:</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int (*getcursor)(FAR struct lcd_dev_s *dev,</span></span>
<span class="line"><span>                 FAR struct fb_cursorattrib_s *attrib);</span></span>
<span class="line"><span>int (*setcursor)(FAR struct lcd_dev_s *dev,</span></span>
<span class="line"><span>                 FAR struct fb_setcursor_s *settings);</span></span></code></pre></div></blockquote></li><li><p>Get the LCD panel power status (0: full off - CONFIG_LCD_MAXPOWER: full on). On backlit LCDs, this setting may correspond to the backlight setting:</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int (*getpower)(struct lcd_dev_s *dev);</span></span></code></pre></div></blockquote></li><li><p>Enable/disable LCD panel power (0: full off - CONFIG_LCD_MAXPOWER: full on). On backlit LCDs, this setting may correspond to the backlight setting:</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int (*setpower)(struct lcd_dev_s *dev, int power);</span></span></code></pre></div></blockquote></li><li><p>Get the current contrast setting (0-CONFIG_LCD_MAXCONTRAST):</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int (*getcontrast)(struct lcd_dev_s *dev);</span></span></code></pre></div></blockquote></li><li><p>Set LCD panel contrast (0-CONFIG_LCD_MAXCONTRAST):</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int (*setcontrast)(struct lcd_dev_s *dev, unsigned int contrast);</span></span></code></pre></div></blockquote></li></ul></blockquote>`,5)]))}const m=l(o,[["render",d]]);export{v as __pageData,m as default};
