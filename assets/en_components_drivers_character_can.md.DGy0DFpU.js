import{_ as t,c as r,al as o,o as a}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"CAN Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/character/can.md","filePath":"en/components/drivers/character/can.md"}'),i={name:"en/components/drivers/character/can.md"};function s(n,e,c,d,l,h){return a(),r("div",null,e[0]||(e[0]=[o('<h1 id="can-drivers" tabindex="-1">CAN Drivers <a class="header-anchor" href="#can-drivers" aria-label="Permalink to &quot;CAN Drivers&quot;">â€‹</a></h1><p>NuttX supports only a very low-level CAN driver. This driver supports only the data exchange and does not include any high-level CAN protocol. The NuttX CAN driver is split into two parts:</p><ol><li>An &quot;upper half&quot;, generic driver that provides the common CAN interface to application level code, and</li><li>A &quot;lower half&quot;, platform-specific driver that implements the low-level timer controls to implement the CAN functionality.</li></ol><p>Files supporting CAN can be found in the following locations:</p><ul><li><strong>Interface Definition</strong>. The header file for the NuttX CAN driver resides at <code>include/nuttx/can/can.h</code>. This header file includes both the application level interface to the CAN driver as well as the interface between the &quot;upper half&quot; and &quot;lower half&quot; drivers. The CAN module uses a standard character driver framework.</li><li><strong>&quot;Upper Half&quot; Driver</strong>. The generic, &quot;upper half&quot; CAN driver resides at <code>drivers/can.c</code>.</li><li><strong>&quot;Lower Half&quot; Drivers</strong>. Platform-specific CAN drivers reside in <code>arch/&lt;architecture&gt;/src/&lt;hardware&gt;</code> directory for the specific processor <code>&lt;architecture&gt;</code> and for the specific <code>&lt;chip&gt;</code> CAN peripheral devices.</li></ul><p><code>struct timeval ch_ts</code>: This member variable that store in the <code>can_hdr_s</code> structure depends on <code>CONFIG_CAN_TIMESTAMP</code> and is used to store the timestamp of the CAN message.</p><p><strong>Usage Note</strong>: When reading from the CAN driver multiple messages may be returned, depending on (1) the size the returned can messages, and (2) the size of the buffer provided to receive CAN messages. <em>Never assume that a single message will be returned</em>... if you do this, <em>you will lose CAN data</em> under conditions where your read buffer can hold more than one small message. Below is an example about how you should think of the CAN read operation: <strong>Examples</strong>: <code>drivers/can/mcp2515.c</code>.</p>',7)]))}const m=t(i,[["render",s]]);export{u as __pageData,m as default};
