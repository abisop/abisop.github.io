import{_ as t,c as r,al as a,o as i}from"./chunks/framework.NFAqBSgQ.js";const o="/assets/wireless_ioctl_white.drawio.CAXlGgDB.png",f=JSON.parse('{"title":"Wireless character drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/character/wireless/index.md","filePath":"en/components/drivers/character/wireless/index.md"}'),s={name:"en/components/drivers/character/wireless/index.md"};function n(d,e,l,c,h,p){return i(),r("div",null,e[0]||(e[0]=[a('<h1 id="wireless-character-drivers" tabindex="-1">Wireless character drivers <a class="header-anchor" href="#wireless-character-drivers" aria-label="Permalink to &quot;Wireless character drivers&quot;">​</a></h1><blockquote><p>lpwan/index.rst</p></blockquote><h2 id="ioctl-interface" tabindex="-1">IOCTL Interface <a class="header-anchor" href="#ioctl-interface" aria-label="Permalink to &quot;IOCTL Interface&quot;">​</a></h2><p>Before this interface, the IOCTL API for character-driven RF devices lacked a common interface across different modulation technologies, such as LoRa, FSK, and OOK. The result was, driver-specific IOCTL commands were created even when they could be shared across multiple radios. This fragmentation made application portability more difficult to maintain.</p><p>To solve this issue, groups of commands have been created that are &quot;selected&quot; by using <code>WLIOC_SETMODU</code>. See image below for a representation.</p><p><img src="'+o+'" alt=""></p><p>Note</p><p>This image does not show all features. This is purely a representation of command relations under WLIOC_SETMODU.</p><h3 id="read" tabindex="-1">read() <a class="header-anchor" href="#read" aria-label="Permalink to &quot;read()&quot;">​</a></h3><p>Reading a radio will take a <code>wlioc_rx_hdr_s</code>, where information about the payload will be read and written to.</p><ul><li><code>FAR uint8_t *payload_buffer</code> Pointer to <strong>user buffer</strong>. This is where the payload will be written to.</li><li><code>size_t payload_length</code> <strong>Initially</strong>: User must set this to the size of <code>payload_buffer</code>. <strong>After reading</strong>: This will become the amount of bytes written to the <code>payload_buffer</code>.</li><li><code>uint8_t error</code> When greater than 0, there are errors detected in the payload. The payload can still be returned, which allows the user to repair it if desired.</li><li><code>int32_t rssi_dbm</code> The Received Signal Strength Indicator in 1/100 decibel-milliwatts of the received signal. When unsupported, this returns <code>INT32_MIN</code>.</li><li><code>int32_t snr_db</code> The signal to noise ratio in 1/100 decibels of the received signal. When unsupported, this returns <code>INT32_MIN</code>.</li></ul><h3 id="write" tabindex="-1">write() <a class="header-anchor" href="#write" aria-label="Permalink to &quot;write()&quot;">​</a></h3><p>Writing to a radio will attempt to send the given bytes. The radio must be configured before doing so. Unlike <code>read()</code>, this will simply take uint8_t bytes as payload.</p>',13)]))}const _=t(s,[["render",n]]);export{f as __pageData,_ as default};
