import{_ as t,c as i,al as o,j as e,a,o as n}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"Nordic nRF53","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/nrf53/index.md","filePath":"en/platforms/arm/nrf53/index.md"}'),s={name:"en/platforms/arm/nrf53/index.md"};function p(l,r,d,c,h,u){return n(),i("div",null,r[0]||(r[0]=[o('<h1 id="nordic-nrf53" tabindex="-1">Nordic nRF53 <a class="header-anchor" href="#nordic-nrf53" aria-label="Permalink to &quot;Nordic nRF53&quot;">​</a></h1><p>The nRF53 series of chips from Nordic Semiconductor are based around an two ARM Cortex-M33 cores and a multiprotocol 2.4 GHz transceiver.</p><h2 id="peripheral-support" tabindex="-1">Peripheral Support <a class="header-anchor" href="#peripheral-support" aria-label="Permalink to &quot;Peripheral Support&quot;">​</a></h2><p>The following list indicates peripherals supported in NuttX:</p><p>Peripheral Support Notes</p><hr><p>GPIO GPIOTE I2S MWU NFCT PDM DPPI PWM QDEC QSPI RADIO RNG RTC SAADC SPIM SPIS TEMP TIMER TWIM TWIS UART UARTE USBD WDT Yes Yes No No No No No Yes No Yes No No Yes Yes Yes No No Yes Yes No Yes No Yes No<br> IPC Yes RPTUN supported</p><h3 id="gpio-gpiote" tabindex="-1">GPIO/GPIOTE <a class="header-anchor" href="#gpio-gpiote" aria-label="Permalink to &quot;GPIO/GPIOTE&quot;">​</a></h3><p>Pins can be configured/operated using <code>nrf53_gpio_*</code> functions. Interrupts are handled via the GPIOTE peripheral in one of two ways: via a GPIOTE channel or via PORT events. The former allows for simultaneous rising/falling edge-sensitive interrupts per-pin. However, as there are a limited number of channels (and sometimes these are used by some drivers for specific tasks), it may not always be possible to use this mechanism. The latter approach for pin interrupts is via the PORT event, determined by pin state on a their corresponding GPIO port. This is related to the SENSE capability of pins, which can only be set to either rising or falling edge sensing.</p><p>Depending on <code>CONFIG_NRF53_PER_PIN_INTERRUPTS</code> option, you can set a callback for the PORT event itself or you can set a callback for a given pin. In the latter case the driver scans for pins with DETECT bit high and calls the configured callback automatically.</p><p>Finally, GPIOTE can also be used to configure a channel in <em>task mode</em>, which allows to control pin state via tasks/events.</p><h3 id="adc" tabindex="-1">ADC <a class="header-anchor" href="#adc" aria-label="Permalink to &quot;ADC&quot;">​</a></h3>',12),e("p",null,[a("The SAADC peripheral is exposed via standard ADC driver. The lower-half of this driver is initialized by calling :c"),e("code",{class:"interpreted-text",role:"func"},"nrf53_adcinitialize"),a(".")],-1),e("h3",{id:"i2c",tabindex:"-1"},[a("I2C "),e("a",{class:"header-anchor",href:"#i2c","aria-label":'Permalink to "I2C"'},"​")],-1),e("p",null,"I2C is supported both in polling and interrupt mode (via EasyDMA).",-1),e("p",null,"Note",-1),e("p",null,"The I2C peripheral does not support sending two transfers without sending a START nor RSTART. For this reason, this is supported via an internal buffer where messages will be first copied to and sent together.",-1),e("p",null,[a("The lower-half of I2C bus is initialized by :c"),e("code",{class:"interpreted-text",role:"func"},"nrf53_i2cbus_initialize"),a(".")],-1),o(`<h3 id="spi" tabindex="-1">SPI <a class="header-anchor" href="#spi" aria-label="Permalink to &quot;SPI&quot;">​</a></h3><p>SPI is supported both in polling and interrupt-based (via EasyDMA) mode. The latter supports arbitrarily long transfers using Nordic&#39;s list-mode EasyDMA (intermediate transfers are currently still manually started).</p><p>It is possible to use SPI without either MOSI/MISO pin defined by simply not providing the relevant <code>BOARD_SPI*_MISO/MOSI_PIN</code> definition.</p><p>This implementation support power management hooks, which will disable SPI peripheral when entering either SLEEP or STANDBY modes and reconfigure it when going back to NORMAL mode.</p><h3 id="uart" tabindex="-1">UART <a class="header-anchor" href="#uart" aria-label="Permalink to &quot;UART&quot;">​</a></h3><p>UART is implemented using polling. UARTE EasyDMA feature is not yet supported. This may introduce a large number of interrupts which may be undesirable.</p><h3 id="pwm" tabindex="-1">PWM <a class="header-anchor" href="#pwm" aria-label="Permalink to &quot;PWM&quot;">​</a></h3><p>PWM is supported via standard driver. This means that more advanced features such as complex sequences or waveform modes are not yet supported.</p><h3 id="qspi" tabindex="-1">QSPI <a class="header-anchor" href="#qspi" aria-label="Permalink to &quot;QSPI&quot;">​</a></h3><p>QSPI is supported both in interrupt-based (via EasyDMA) mode and is exposed via standard QSPI interface.</p><h3 id="timer" tabindex="-1">TIMER <a class="header-anchor" href="#timer" aria-label="Permalink to &quot;TIMER&quot;">​</a></h3><p>The TIMER peripheral is exposed as standard timer.</p><h3 id="rtc" tabindex="-1">RTC <a class="header-anchor" href="#rtc" aria-label="Permalink to &quot;RTC&quot;">​</a></h3><p>The RTC peripheral is exposed as a standard timer, since it is really a low-power timer, without any date handling capabilities.</p><h3 id="usbd" tabindex="-1">USBD <a class="header-anchor" href="#usbd" aria-label="Permalink to &quot;USBD&quot;">​</a></h3><p>The USBD peripheral is exposed via standard USBDEV interface.</p><h2 id="interprocessor-communication" tabindex="-1">Interprocessor Communication <a class="header-anchor" href="#interprocessor-communication" aria-label="Permalink to &quot;Interprocessor Communication&quot;">​</a></h2><p>Interprocessor communication between the application core and the network core is realized with the NuttX RPTUN device based on the OpenAMP framework.</p><p>The last 32kB of the application core RAM is used for a shared memory (address = 0x20078000).</p><h2 id="ble-support" tabindex="-1">BLE Support <a class="header-anchor" href="#ble-support" aria-label="Permalink to &quot;BLE Support&quot;">​</a></h2><p>BLE is supported in the nRF53 using Nordic&#39;s <a href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrfxlib/softdevice_controller/README.html" target="_blank" rel="noreferrer">SoftDevice Controller</a>.</p><h2 id="tool-issues" tabindex="-1">Tool Issues <a class="header-anchor" href="#tool-issues" aria-label="Permalink to &quot;Tool Issues&quot;">​</a></h2><h3 id="openocd" tabindex="-1">OpenOCD <a class="header-anchor" href="#openocd" aria-label="Permalink to &quot;OpenOCD&quot;">​</a></h3><p>There is no official support for Nordic Cortex M33 chips (nRF9160 or nRF5340).</p><h3 id="segger-j-link" tabindex="-1">Segger J-Link <a class="header-anchor" href="#segger-j-link" aria-label="Permalink to &quot;Segger J-Link&quot;">​</a></h3><p>To start the GDB servers for the application core and the network core, use these commands:</p><pre><code>JLinkGDBServer -device nRF5340_xxAA_APP -autoconnect 1 -if SWD -speed 4000 -port 2331 -swoport 2332 -telnetport 2333
JLinkGDBServer -device nRF5340_xxAA_NET -autoconnect 1 -if SWD -speed 4000 -port 2334 -swoport 2335 -telnetport 2336
</code></pre><p>Then you can connect GDB to targets:</p><pre><code>(gdb_app) target remote localhost:2331
(gdb_net) target remote localhost:2334
</code></pre><h3 id="flashing-locked-device" tabindex="-1">Flashing locked device <a class="header-anchor" href="#flashing-locked-device" aria-label="Permalink to &quot;Flashing locked device&quot;">​</a></h3><ol><li><p>Unlock the network core:</p><pre><code>nrfjprog --recover --coprocessor CP_NETWORK
</code></pre></li><li><p>Unlock the application core:</p><pre><code>nrfjprog --recover
</code></pre></li><li><p>Flash the network core:</p><pre><code>nrfjprog --coprocessor CP_NETWORK --program nuttx_net.hex --verify --chiperase
</code></pre></li><li><p>Flash the application core:</p><pre><code>nrfjprog --program nuttx_app.hex --verify --chiperase
</code></pre></li></ol><h2 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h2><blockquote><p>boards/<em>/</em></p></blockquote>`,33)]))}const b=t(s,[["render",p]]);export{f as __pageData,b as default};
