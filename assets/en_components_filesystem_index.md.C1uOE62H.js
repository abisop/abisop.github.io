import{_ as o,c as a,al as i,j as e,a as t,o as n}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"NuttX File System","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/filesystem/index.md","filePath":"en/components/filesystem/index.md"}'),r={name:"en/components/filesystem/index.md"};function l(d,s,c,p,m,h){return n(),a("div",null,s[0]||(s[0]=[i('<h1 id="nuttx-file-system" tabindex="-1">NuttX File System <a class="header-anchor" href="#nuttx-file-system" aria-label="Permalink to &quot;NuttX File System&quot;">​</a></h1><p>NuttX includes an optional, scalable file system. This file-system may be omitted altogether; NuttX does not depend on the presence of any file system.</p><p><strong>Pseudo Root File System</strong>. A simple <em>in-memory</em>, <em>pseudo</em> file system can be enabled by default. This is an <em>in-memory</em> file system because it does not require any storage medium or block driver support. Rather, file system contents are generated on-the-fly as referenced via standard file system operations (open, close, read, write, etc.). In this sense, the file system is <em>pseudo</em> file system (in the same sense that the Linux <code>/proc</code> file system is also referred to as a pseudo file system).</p><p>Any user supplied data or logic can be accessed via the pseudo-file system. Built in support is provided for character and block drivers in the <code>/dev</code> pseudo file system directory.</p><p><strong>Mounted File Systems</strong> The simple in-memory file system can be extended my mounting block devices that provide access to true file systems backed up via some mass storage device. NuttX supports the standard <code>mount()</code> command that allows a block driver to be bound to a mountpoint within the pseudo file system and to a file system. At present, NuttX supports the standard VFAT and ROMFS file systems, a special, wear-leveling NuttX FLASH File System (NXFFS), as well as a Network File System client (NFS version 3, UDP).</p><p><strong>Comparison to Linux</strong> From a programming perspective, the NuttX file system appears very similar to a Linux file system. However, there is a fundamental difference: The NuttX root file system is a pseudo file system and true file systems may be mounted in the pseudo file system. In the typical Linux installation by comparison, the Linux root file system is a true file system and pseudo file systems may be mounted in the true, root file system. The approach selected by NuttX is intended to support greater scalability from the very tiny platform to the moderate platform.</p><h2 id="virtual-file-system-vfs" tabindex="-1">Virtual File System (VFS) <a class="header-anchor" href="#virtual-file-system-vfs" aria-label="Permalink to &quot;Virtual File System (VFS)&quot;">​</a></h2><p>Virtual File System provides a unified interface for various file systems to be able to co-exist together by exposing a blueprint that each file system needs to implement. This also allows the file system to be free from worry about the device driver implementations for storage devices, as they also expose a unified way of accessing the underlying devices.</p><h3 id="how-vfs-works" tabindex="-1">How VFS works <a class="header-anchor" href="#how-vfs-works" aria-label="Permalink to &quot;How VFS works&quot;">​</a></h3><p>Threads are controllable sequences of instruction execution with their own stacks. Each task in NuttX is represented by a Task Control Block (TCB) (TCB is defined in <code>include/nuttx/sched.h</code>) and tasks are organized in task lists.</p><p>All threads that are created by <code>pthread_create()</code> are part of the same task group. A task group (defined in <code>include/nuttx/sched.h</code>) is a shared structure pointed to by the TCBs of all the threads that belong to the same task group, and this task group contains all the resources shared across the task group which includes <em>file descriptors</em> in the form of a <strong>file list</strong>.</p>',11),e("p",null,[t("A file list (defined in "),e("code",null,"include/nuttx/fs/fs.h"),t(") contains file structures that denote open files (along with a spinlock to manage access to the file list). With the devices listed in the "),e("code",{class:"interpreted-text",role:"ref"},"root file system <root_fs>"),t(" (on points like "),e("code",null,"/dev/led"),t(", "),e("code",null,"/dev/mmcsd0"),t(", etc. which are henceforth called blockdriver mount points) in an unmounted state, storage devices can be mounted using the "),e("code",null,"mount()"),t(" command (to any point like "),e("code",null,"/dir/abcd"),t(") with any specific supported file system, which internally calls its implemented "),e("code",null,"mountpt_operations->bind()"),t(" method and passes the blockdriver's mount point inode to it, thus creating a "),e("strong",null,"mount point"),t(". The blockdriver mount point inode will have a "),e("code",null,"mountpt->i_private"),t(" which contains any (file system dependent) information about the mount and is to be filled by the file system during the execution of "),e("code",null,"mountpt_operations->bind()"),t(" (and usually this data includes a pointer to the blockdriver mount point as well). After that, according to system calls, the other exposed functions of the filesystem are called as per need.")],-1),i('<h3 id="vfs-interface" tabindex="-1">VFS Interface <a class="header-anchor" href="#vfs-interface" aria-label="Permalink to &quot;VFS Interface&quot;">​</a></h3><p>VFS allows file systems to expose their own implementations of methods belonging to a unified interface:</p><ul><li><strong>File operations</strong></li></ul><p>Note</p><p>POSIX requires that a <code>read()</code> after a <code>write()</code> should get the newly written data, but not all file systems conform to POSIX, especially as POSIX requires atomic writes, which is not usually implemented as it can impact performance.</p><p>To be POSIX compliant in concurrent situations, either the writes have to be atomic, or read is blocked with a lock until an on-going write is finished, which, as stated, would impact performance.</p><p>Note</p><p>According to POSIX, <code>lseek()</code> to any point after the end of the file <em>does not</em> by itself increase the size of the file. Later writes to this part will, however, increase it to at least the end of the written data, and the &quot;gap&quot; before this written data should be filled with <code>\\0</code> in case of any reads after such a write operation.</p><p>Note</p><p>NuttX operates in a flat open address space. Therefore, it generally does not require <code>mmap()</code> functionality. There are two notable exceptions where <code>mmap()</code> functionality is required:</p><ol><li><code>mmap()</code> is the API that is used to support direct access to random access media under the following very restrictive conditions:</li></ol><blockquote><p>a. The filesystem implements the mmap file operation. Any file system that maps files contiguously on the media should support this ioctl. (vs. file system that scatter files over the media in non-contiguous sectors). As of this writing, ROMFS is the only file system that meets this requirement. b. The underlying block driver supports the BIOC_XIPBASE ioctl command that maps the underlying media to a randomly accessible address. At present, only the RAM/ROM disk driver does this.</p></blockquote><ol start="2"><li>If CONFIG_FS_RAMMAP is defined in the configuration, then mmap() will support simulation of memory mapped files by copying files whole into RAM.</li></ol><ul><li><strong>Additional open file specific operations</strong></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- --&gt;</span></span></code></pre></div><ul><li><strong>Directory operations</strong></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- --&gt;</span></span></code></pre></div><ul><li><strong>Volume-relations operations</strong></li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- --&gt;</span></span></code></pre></div><ul><li><strong>Path operations</strong></li></ul><p>The file systems can have their own implementations for these functions under-the-hood, but the user does not have to worry about the underlying file system during file I/O, as the file system has to expose its implementations in a unified interface.</p><p>Note</p><p>Each file system has to globally expose their implementations of the unified interface as defined by <code>struct mountpt_operations</code> (in <code>include/fs/fs.h</code>) to one of the lists defined in <code>fs/mount/fs_mount.c</code> depending on the type of the file system.</p><p>They also need their own <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)" target="_blank" rel="noreferrer">magic number</a> to be listed in <code>include/sys</code> and in <code>fs_gettype</code> function (in <code>fs/mount/fs_gettype.c</code>) for identification of the filesystem.</p><h2 id="file-systems" tabindex="-1">File systems <a class="header-anchor" href="#file-systems" aria-label="Permalink to &quot;File systems&quot;">​</a></h2><p>NuttX provides support for a variety of file systems out of the box.</p><blockquote><p>aio.rst binfs.rst cromfs.rst fat.rst hostfs.rst littlefs.rst mmap.rst mnemofs.rst nfs.rst nxffs.rst partition.rst procfs.rst romfs.rst rpmsgfs.rst smartfs.rst shmfs.rst spiffs.rst tmpfs.rst unionfs.rst userfs.rst zipfs.rst inotify.rst nuttxfs.rst nxflat.rst pseudofs.rst special_files_dev_num.rst v9fs.rst</p></blockquote><h3 id="fs-categories" tabindex="-1">FS Categories <a class="header-anchor" href="#fs-categories" aria-label="Permalink to &quot;FS Categories&quot;">​</a></h3><p>File systems can be divided into these categories on the basis of the drivers they require:</p><ol><li>They require a block device driver. They include vfat, romfs, smartfs, and littlefs.</li><li>They require MTD drivers. They include romfs, spiffs, littlefs.</li><li>They require neither block nor MTD drivers. They include nxffs, tmpfs, nfs binfs, procfs, userfs, hostfs, cromfs, unionfs, rpmsgfs, and zipfs.</li></ol><p>The requirements are specified by declaring the filesystem in the proper array in <code>fs/mount/fs_mount.c</code>.</p>',31)]))}const y=o(r,[["render",l]]);export{u as __pageData,y as default};
