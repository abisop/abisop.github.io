import{_ as o,c as t,al as a,o as i}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"qemu-intel64","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/x86_64/intel64/boards/qemu-intel64/index.md","filePath":"en/platforms/x86_64/intel64/boards/qemu-intel64/index.md"}'),n={name:"en/platforms/x86_64/intel64/boards/qemu-intel64/index.md"};function r(s,e,l,h,u,c){return i(),t("div",null,e[0]||(e[0]=[a(`<h1 id="qemu-intel64" tabindex="-1">qemu-intel64 <a class="header-anchor" href="#qemu-intel64" aria-label="Permalink to &quot;qemu-intel64&quot;">​</a></h1><p>This page file describes the contents of the build configurations available for the NuttX QEMU x86_64 port.</p><h2 id="qemu-kvm" tabindex="-1">QEMU/KVM <a class="header-anchor" href="#qemu-kvm" aria-label="Permalink to &quot;QEMU/KVM&quot;">​</a></h2><p>QEMU is a generic and open source machine emulator and virtual machine. Here are some links (which will probably be mostly outdated by the time your read this):</p><ul><li>Home Page: <a href="http://wiki.qemu.org/Main_Page" target="_blank" rel="noreferrer">http://wiki.qemu.org/Main_Page</a></li><li>Downloads: <a href="http://wiki.qemu.org/Download" target="_blank" rel="noreferrer">http://wiki.qemu.org/Download</a></li><li>Documentation: <a href="http://wiki.qemu.org/Manual" target="_blank" rel="noreferrer">http://wiki.qemu.org/Manual</a></li></ul><p>KVM is the Linux kernel hypervisor. It supports creations of virtual machines in Linux systems. It is usually coupled with Qemu as its I/O supporting layer.</p><p>The qemu can be build from source or downloaded from distro repositories. However, a modern CPU and KVM support are mandatory because the X2APIC is not available in pure emulator mode. This mean using this build with qemu in windows or old x86 machine can be frustrating. In such case, looks the next section and use bochs emulator instead.</p><h3 id="running-qemu" tabindex="-1">Running QEMU <a class="header-anchor" href="#running-qemu" aria-label="Permalink to &quot;Running QEMU&quot;">​</a></h3><p>When you created a bootable disk, use command:</p><pre><code>qemu-system-x86_64 -cpu host -enable-kvm -m 2G -cdrom boot.iso -nographic -serial mon:stdio
</code></pre><p>or, when option <code>CONFIG_ARCH_PVHBOOT</code> is set, you can use <code>-kernel</code> argument instead:</p><pre><code>qemu-system-x86_64 -cpu host -enable-kvm -m 2G -kernel nuttx.elf -nographic -serial mon:stdio
</code></pre><p>This multiplex the qemu console and COM1 to your console.</p><p>Use control-a 1 and 2 to switch between. Use control-a x to terminate the emulation.</p><p>P.S. Make sure that you CPU supports the mandatory features. Look at Real machine section for more information.</p><p>For testing the PCI bus and driver layers. This QEMU configuration can be used with the pcitest NuttX configuration:</p><pre><code>qemu-system-x86_64  -cpu host,+pcid,+x2apic,+tsc-deadline,+xsave,+rdrand --enable-kvm -smp 1 -m 2G -cdrom boot.iso --nographic -s -no-reboot -device edu -device pci-testdev
</code></pre><p>This will enable the QEMU pci-test and edu PCI test devices which test PIO, MMIO, IRQ, and DMA functions. Additionally it will show detailed information about the enumeration of the PCI bus.</p><p>If you want to boot using UEFI and TianoCore you will need to add a flag like this to point at OVMF <code>--bios /usr/share/edk2/ovmf/OVMF_CODE.fd</code></p><h2 id="bochs" tabindex="-1">Bochs <a class="header-anchor" href="#bochs" aria-label="Permalink to &quot;Bochs&quot;">​</a></h2><p>Bochs is also a generic and open source machine emulator and virtualizer. It does very comprehensive emulation of x86 platform, even the state-of-art processors. Here are some links (which will probably be mostly outdated by the time your read this):</p><ul><li>Home Page: <a href="http://bochs.sourceforge.net" target="_blank" rel="noreferrer">http://bochs.sourceforge.net</a></li></ul><p>The bochs can be build from source. Unlike qemu, it does not rely on KVM to support modern hardware features, therefore it can also be used under Windows. When building bochs, remember to enable x86-64 support with <code>--enable-x86-64</code>. If you also want support for SIMD instructions, enable them with <code>--enable-avx --enable-evex</code>.</p><h3 id="running-bochs" tabindex="-1">Running Bochs <a class="header-anchor" href="#running-bochs" aria-label="Permalink to &quot;Running Bochs&quot;">​</a></h3><p>First edit/check the <code>.bochsrc</code> You can create one in the top-level NuttX directory or bochs will use the one in your \\HOME. Remember to change the CPU model to one with mandatory features and enable the COM port.</p><ul><li><p>Find and edit (You might adjust the IPS as you machine perform):</p><pre><code>cpu: model=broadwell_ult, count=1, ips=50000000, reset_on_triple_fault=0, ignore_bad_msrs=0, msrs=&quot;msrs.def&quot;
ata0-master: type=cdrom, path=&quot;&lt;PATH TO boot.iso&gt;&quot;, status=inserted
</code></pre></li><li><p>Add:</p><pre><code>com1: enabled=1, mode=file, dev=com1.out
</code></pre></li><li><p>In the top-level NuttX directory:</p><pre><code>bochs
</code></pre></li></ul><p>The emulator will drop into debugger mode. Enter <code>c</code> to start the emulation. COM port output will be in the com1.out file.</p><h2 id="real-machine" tabindex="-1">Real machine <a class="header-anchor" href="#real-machine" aria-label="Permalink to &quot;Real machine&quot;">​</a></h2><p>This port can work on real x86-64 machine with a proper CPU. The mandatory CPU features are:</p><ul><li>TSC DEADLINE or APIC timer or HPET</li><li>PCID</li><li>X2APIC</li><li>legacy serial port support or PCI serial card (AX99100 only supported now)</li></ul><p>WARNING: IF you use TSC DEADLINE, make sure that your CPU&#39;s TSC DEADLINE timer is not buggy!</p><h2 id="toolchains" tabindex="-1">Toolchains <a class="header-anchor" href="#toolchains" aria-label="Permalink to &quot;Toolchains&quot;">​</a></h2><p>Currently, only the Linux GCC toolchain is tested. While building on a modern x86_64 PC, the default system GCC can be used.</p><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><h3 id="common-configuration-notes" tabindex="-1">Common Configuration Notes <a class="header-anchor" href="#common-configuration-notes" aria-label="Permalink to &quot;Common Configuration Notes&quot;">​</a></h3><ol><li><p>Each Qemu-intel64 configuration is maintained in a sub-directory and can be selected as follow:</p><pre><code>tools/configure.sh qemu-intel64:&lt;subdir&gt;
</code></pre><p>Where <code>&lt;subdir&gt;</code> is one of the configuration sub-directories described in the following paragraph.</p></li><li><p>These configurations use the mconf-based configuration tool. To change a configurations using that tool, you should:</p><p>a. Build and install the kconfig-mconf tool. See nuttx/README.txt see additional README.txt files in the NuttX tools repository. b. Execute <code>make menuconfig</code> in nuttx/ in order to start the reconfiguration process.</p></li><li><p>By default, all configurations assume the Linux. This is easily reconfigured:</p><pre><code>CONFIG_HOST_LINUX=y
</code></pre></li></ol><h3 id="configuration-sub-directories" tabindex="-1">Configuration Sub-Directories <a class="header-anchor" href="#configuration-sub-directories" aria-label="Permalink to &quot;Configuration Sub-Directories&quot;">​</a></h3><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>This configuration provides a basic NuttShell configuration (NSH) with the default console on legacy UART0 port (base=0x3f8)</p><h3 id="nsh-pci" tabindex="-1">nsh_pci <a class="header-anchor" href="#nsh-pci" aria-label="Permalink to &quot;nsh\\_pci&quot;">​</a></h3><p>This configuration provides a basic NuttShell configuration (NSH) with the default console on PCI serial port (AX99100 based card).</p><h3 id="nsh-pci-smp" tabindex="-1">nsh_pci_smp <a class="header-anchor" href="#nsh-pci-smp" aria-label="Permalink to &quot;nsh\\_pci\\_smp&quot;">​</a></h3><p>This is a configuration to run NuttX in SMP mode on hardware with a PCI serial port card (AX99100).</p><h3 id="ostest" tabindex="-1">ostest <a class="header-anchor" href="#ostest" aria-label="Permalink to &quot;ostest&quot;">​</a></h3><p>The &quot;standard&quot; NuttX examples/ostest configuration with the default console on legacy UART0 port (base=0x3f8)</p><h3 id="jumbo" tabindex="-1">jumbo <a class="header-anchor" href="#jumbo" aria-label="Permalink to &quot;jumbo&quot;">​</a></h3><p>This is a QEMU configuration that enables many NuttX features.</p><p>Basic command to run the image without additional PCI devices attached:</p><pre><code>qemu-system-x86_64 -m 2G -cpu host -smp 4 -enable-kvm \\
-kernel nuttx -nographic -serial mon:stdio
</code></pre><h3 id="knsh-romfs" tabindex="-1">knsh_romfs <a class="header-anchor" href="#knsh-romfs" aria-label="Permalink to &quot;knsh\\_romfs&quot;">​</a></h3><p>This is similar to the <code>nsh</code> configuration except that NuttX is built as a kernel-mode, monolithic module, and the user applications are built separately. It uses ROMFS to load the user-space applications. This is intended to run on QEMU with COM serial port support.</p><p>Steps to build kernel image with user-space apps in ROMFS:</p><pre><code>./tools/configure.sh qemu-intel64/knsh_romfs
make -j
make export -j
pushd ../apps
./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz
make import -j
./tools/mkromfsimg.sh
mv boot_romfsimg.h ../nuttx/arch/x86_64/src/board/romfs_boot.c
popd
make -j
</code></pre><h3 id="knsh-romfs-pci" tabindex="-1">knsh_romfs_pci <a class="header-anchor" href="#knsh-romfs-pci" aria-label="Permalink to &quot;knsh\\_romfs\\_pci&quot;">​</a></h3><p>This is similar to the <code>knsh_romfs</code> configuration except that it is intended to run on a bare metal Intel hardware with PCI serial port support.</p><h3 id="lvgl" tabindex="-1">lvgl <a class="header-anchor" href="#lvgl" aria-label="Permalink to &quot;lvgl&quot;">​</a></h3><p>LVGL demo example that demonstrates x86_64 framebuffer feature.</p><h3 id="fb" tabindex="-1">fb <a class="header-anchor" href="#fb" aria-label="Permalink to &quot;fb&quot;">​</a></h3><p>Configuration that enables NuttX framebuffer examples.</p>`,59)]))}const m=o(n,[["render",r]]);export{p as __pageData,m as default};
