import{_ as t,c as o,al as i,o as r}from"./chunks/framework.NFAqBSgQ.js";const c="/assets/directories.eQ_8uBZN.png",f=JSON.parse('{"title":"Platform Directories","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/platform_directories.md","filePath":"en/guides/platform_directories.md"}'),a={name:"en/guides/platform_directories.md"};function d(s,e,n,l,h,p){return r(),o("div",null,e[0]||(e[0]=[i('<h1 id="platform-directories" tabindex="-1">Platform Directories <a class="header-anchor" href="#platform-directories" aria-label="Permalink to &quot;Platform Directories&quot;">â€‹</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Platform+Directories" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Platform+Directories</a></p><p>Let&#39;s assume that you are not change the OS itself but want to implement or extend platform-specific code.In this case, there are six, maybe seven, places where you can provide the platform code.</p><p><img src="'+c+'" alt="image"></p><p>REVISIT: This is a out of date. There has been a recent reorganization of the board-related directories: The <code>configs/</code> directory has been renamed <code>boards/</code> and structure under the new <code>boards/</code> directory is significantly different. A <code>&lt;board&gt;</code> directory would now be found at <code>boards/&lt;arch&gt;/&lt;chip&gt;/&lt;board&gt;</code>. Conceptually the figure is correct, just not consistent with current naming.</p><p>Each directory has slightly different properties and are discussed in more detail below where:</p><ul><li>[&lt;arch&gt;]{.title-ref} represents the chip architecture that you are using. As examples, [&lt;arch&gt;]{.title-ref} might represent <code>arm</code> or <code>mips</code>.</li><li>[&lt;chip&gt;]{.title-ref} represents the specific chip family that you are using. As examples, [&lt;chip&gt;]{.title-ref} might mean <code>stm32</code> or <code>efm32</code></li><li>[&lt;board&gt;]{.title-ref} represents the specific board that you are using. As examples, [&lt;board&gt;]{.title-ref} might be <code>stm32f4discovery</code> or <code>dk-tm4c129x</code></li></ul><ol><li>arch/&lt;arch&gt;/src/&lt;chip&gt;</li></ol><hr><p>The <code>arch/&lt;arch&gt;/src/&lt;chip&gt;</code> directory should hold all chip related logic. Almost all chip-specific header files should reside here too. That includes device-related header files. GPIO header files, for example, go here and no where else.</p><ol start="2"><li>arch/&lt;arch&gt;/include/&lt;chip&gt;</li></ol><hr><p>The intent of the <code>arch/&lt;arch&gt;/include/&lt;chip&gt;</code> directory is to hold driver-related definitions needed by application in order to access drivers registered by the chip-specific logic in the <code>arch/&lt;arch&gt;/src/&lt;chip&gt;</code> directory. This would include things like:</p><ul><li>The IOCTL cmds that would be used with the driver <code>ioctl()</code> interfaces calls,</li><li>Structure definitions of parameters passed with IOCTL cmds, and</li><li>Structure definitions of binary data that might be transferred via the driver <code>read()</code> or <code>write()</code> methods.</li></ul><p>The <code>arch/&lt;arch&gt;/include/&lt;chip&gt;</code> directory is not currently used properly for most of the definitions you will find there. Most of the definitions in these header files really belong in the <code>arch/&lt;arch&gt;/src/&lt;chip&gt;</code> directory but are here for historical reasons only at this point.</p><p>The difference between header files in <code>arch/&lt;arch&gt;/include/&lt;chip&gt;</code> directory and the header files in <code>arch/&lt;arch&gt;/src/&lt;chip&gt;</code> directory is that the former can be included by applications using the include path:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;arch/chip/someheader.h&gt;</span></span></code></pre></div><p>The header files in <code>arch/&lt;arch&gt;/src/&lt;chip&gt;</code> cannot be used by applications. Those header flies can and only be used in the <code>arch/&lt;arch&gt;/src/&lt;chip&gt;</code> and in the <code>configs/&lt;board&gt;</code> directories.</p><p>The header files in this directory [MUST NOT]{.title-ref} introduce [ad hoc]{.title-ref} non-standard function call interfaces between the application and the OS. The OS interfaces are highly controlled and not subject to [ad hoc]{.title-ref} extension.</p><p>The NuttX build system enforces this and I do everything that I can to restrict usage of all chip specific facilities to those directories. In reality you are free, of course, to subvert that intent in any way you please for your personal project; but any subversion of that intent will not not be committed into the upstream NuttX repository.</p><ol start="3"><li>configs/&lt;board&gt;/include</li></ol><hr><p>The <code>configs/&lt;board&gt;/include</code> directory is the moral equivalent of the <code>arch/&lt;arch&gt;/include/&lt;chip&gt;</code> directory for boards: The <code>arch/&lt;arch&gt;/include/&lt;chip&gt;</code> directory holds chip-specific definitions that are accessible all logic (event even application code). Similarly the <code>configs/&lt;board&gt;/include</code> directory holds board-specific definitions that are accessible even to applications code. And the same kinds of driver interfacing data should appear in these files (see the list above).</p><p>Similarly, the intent of the <code>configs/&lt;board&gt;/include</code> directory is to hold driver-related definitions needed by application in order to access drivers registered by the board-specific logic in the <code>configs/&lt;board&gt;/src</code> directory. The header files in the <code>configs/&lt;board&gt;/include</code> directory can be included using this include path:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;arch/board/someheader.h&gt;</span></span></code></pre></div><p>The header files in this directory [MUST NOT]{.title-ref} introduce [ad hoc]{.title-ref} non-standard function call interfaces between the application and the OS. The OS interfaces are highly controlled and not subject to [ad hoc]{.title-ref} extension.</p><ol start="4"><li>configs/&lt;board&gt;/src</li></ol><hr><p>All of your board-specific initialization logic and [all]{.title-ref} of the custom board device driver logic should go either in a [built-in]{.title-ref} <code>configs/&lt;board&gt;/src</code> directory or in an external, custom board directory. These board directories are where all of your board-specific, hardware interfacing work should be done. As a minimum, a built-in board directory must contain these files/directories at a minimum:</p><ul><li><code>Kconfig</code> to include the custom board configuration options into the NuttX configuration system.</li><li><code>src/Makefile</code> contains the custom board build logic</li><li><code>include/board.h</code> provides board-specific information needed by the system</li></ul><p>Most people will eventually want to create their own custom board directory. If you do <code>make menuconfig</code> you will find under the board menu that you can enable and configure a custom board directory. One of these configuration options is the path to your custom board directory. That is where you will want to implement all of your product-specific device driver logic. As a minimum, your custom board directory must contain these files/directories at a minimum:</p><ul><li><code>src/Makefile</code> contains the custom board build logic</li><li><code>include/board.h</code> provides board-specific information needed by the system</li></ul><p>NOTE: That the configuration definition file, <code>Kconfig</code>, is not currently supported in the custom board configuration directory.</p><p>Within either type of <code>board/src</code> directory you will have free access to all of the header files in the whole system, including even those in the <code>arch/&lt;arch&gt;/src/&lt;chip&gt;</code> directory. There are no limitations whatsoever; All include paths are supported.</p><ol start="5"><li>Application Directory</li></ol><hr><p>There are many ways to implement your application build. How you do that is not really a part of NuttX and the topic is beyond the scope of this Wiki page. The NuttX apps package does provide one example of an application directory you may choose to use -- or not. That apps/ directory is intended to provide you with some guidance. But if you search the messages in the forum, you can get lots of other ideas how to structure the application build.</p><p>The application logic can include header files from <code>arch/&lt;arch&gt;/include/&lt;chip&gt;</code> directory or from the <code>configs/&lt;board&gt;/include</code> directory for sole purpose of support standard driver interfacing. The header files in this directories must not introduce uncontrolled, [ad hoc]{.title-ref} interfaces into the operating system.</p><p>In the application directory, you cannot include header files from either the <code>arch/&lt;arch&gt;/src/&lt;chip&gt;</code> directory or the <code>configs/&lt;board&gt;/src</code> directory. That is an intentional restriction that I try to enforce in order to support the NuttX model for the segregation of functionality. But again, you can always subvert that in your own repository as you like. There should be no device level code in your application. There should be no need to access GPIOs or registers or anything like that. That all should be done in the chip directory or in your board directory.</p><p>The model I advocate is to create and register standard device drivers in your <code>configs/&lt;board&gt;/src</code> or custom board directory, then you can access the device in your application directory using the standard <code>open()</code> / <code>close()</code> / <code>read()</code> / <code>write()</code> functions.</p><p>But I am all about freedom. Please do things exactly how you want to do them. Make sure the project meets all of your needs first; do things as you like. But, of course, I cannot commit anything upstream that does not conform to these architectural rules.</p><ol start="6"><li>drivers/</li></ol><hr><p>Above I said that all of the devices drivers for the board-specific resources should go in your <code>configs/&lt;board&gt;/src</code> directory. However if your board is loaded with standard external parts that require device drivers -- such as an lcd, a touchscreen, serial FLASH, accelerometers, etc. -- then you will want to reuse or implement standard drivers for these parts that can be shared by different boards. In that case the <code>drivers/</code> directory is the correct place for those implementations. Header files associated with these common drivers would go in the appropriate place under <code>include/nuttx/</code>.</p><ol start="7"><li>apps/platform/&lt;board&gt; (maybe)</li></ol><hr><p>A final place where you can put application specific data is the <code>apps/platform/&lt;board&gt;</code> directory. This is really part of [5. Application Directory]{.title-ref} if you are using the NuttX <code>apps/</code> package. But since it has a slightly different purpose, it is worth discussing separately.</p><p>The <code>apps/platform/</code> directory structure is very similar to the <code>nuttx/configs/</code> directory with one directory per board. At context create time, a symbolic link at <code>apps/platform/board</code> is set up to link to the board-specific directory in <code>apps/platform/&lt;board&gt;</code>.</p><p>The <code>apps/platform/&lt;board&gt;</code> directory is where board-specific application logic could be placed. This directory is not often used. In the normal [flat]{.title-ref} Nuttx build, there is really not much difference between the <code>nuttx/configs/&lt;board&gt;</code> board directory and the <code>apps/platform/&lt;board&gt;</code> board directory. Hence the former is normally sufficient.</p><p>The fundamental difference between the two board directories is that the <code>nuttx/configs/&lt;board&gt;</code> board directory is inside the operating system while the <code>apps/platform/&lt;board&gt;</code> directory is outside of the operating system. This distinction does not mean very much in the [flat]{.title-ref} build (<code>CONFIG_BUILD_FLAT</code>) because nothing enforces [inside]{.title-ref}-ness or [outside]{.title-ref}-ness in that case. But the distinction is very important in protected builds (<code>CONFIG_BUILD_PROTECTED</code>) and [kernel]{.title-ref} builds (<code>CONFIG_BUILD_KERNEL</code>) because the code operating [inside]{.title-ref} the OS is privileged, kernel-mode logic; the code [outside]{.title-ref} of the OS, on the other hand, is unprivileged, user-mode code. The two cannot be intermixed.</p>',51)]))}const g=t(a,[["render",d]]);export{f as __pageData,g as default};
