import{_ as o,c as t,al as n,o as a}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"CNxConsole Keyboard Input","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/graphics/nxwm/cnxconsole.md","filePath":"en/applications/graphics/nxwm/cnxconsole.md"}'),i={name:"en/applications/graphics/nxwm/cnxconsole.md"};function d(s,e,r,c,l,h){return a(),t("div",null,e[0]||(e[0]=[n('<h1 id="cnxconsole-keyboard-input" tabindex="-1">CNxConsole Keyboard Input <a class="header-anchor" href="#cnxconsole-keyboard-input" aria-label="Permalink to &quot;CNxConsole Keyboard Input&quot;">â€‹</a></h1><p><strong>Players</strong></p><p>Let&#39;s look at the major players in the keyboard data transfer. This is much more complex than you might initially think:</p><p><strong>Special Drivers</strong> NxConsole Device. The NX console input comes through a special device driver that is registered at <code>/dev/nxcon0</code> as part of early initialization.</p><p><strong>Kernel Threads</strong></p><ul><li><strong>NX Server Thread</strong> The NX Server is the graphics server command. It receives messages from various sources, performs graphics actions, and forwards graphic event messages to the correct window. Most of the time, the NX Server Thread was waiting on a message queue to receive the next graphics event.</li><li><strong>NxConsole Threads</strong> Each NxConsole has a thread that was started when each <code>NxWM::CNxConsole</code> instance was created by NxWM. Each <code>NxWM::CNxConsole</code> thread opens the NxConsole driver at <code>/dev/nxcon0</code> and redirects stdin, stdout, and stderr to/from that special device. Normally, the <code>NxWM::CNxConsole</code> thread is stopped, just waiting on read for keyboard input to complete.</li></ul><p><strong>Application Threads</strong></p><ul><li><strong>NxWidgets Window Event Handler Thread</strong> <code>CNxServer::listener()</code> is an application thread started by NxWidgets each time a new window is opened. It receives window messages from the NX server and dispatches the messages accordingly.</li><li><strong>Keyboard Listener Thread</strong> <code>CKeyboard::listener()</code> is an application thread that is started by NxWM. It just listens for keyboard input and forwards it through the graphics routing system.</li></ul><p>Now here is the sequence of events to get keyboard input from the stdin device to the correct NxConsole.</p><ol><li><p>Application Space / NxWidgets Window Event Handler Thread Let&#39;s start with the initial state of the NX Server Thread. Initially, it will just want for messages from the NX Server.</p><blockquote><ul><li><code>NxWidgets/libnxwidgets/src/cnxserver.cxx</code><code>CNxServer::listener()</code> is it window listener thread. It just calls <code>nx_eventhandler()</code> to receive and process server events. There is one such listener thread per window.</li><li><code>nuttx/libnx/nxwm/nx_eventhandler</code> <code>nx_eventhandler()</code> waits to receive a message from the NX server. Each window has its own message queue; each window instance has its own <code>nx_eventhandler()</code> waiting for messages.</li></ul></blockquote></li><li><p>Application Space / Keyboard Listener Thread</p><p>Here are the immediate events that happen when the keyboard data is entered. The Keyboard Listener Thread wakes up and forwards the Keyboard data to the the NX Server. Only the NX Server knows which window should get the keyboard input.</p><blockquote><ul><li><code>NxWidgets\\nxwm\\src\\ckeyboard.cxx</code> <code>CKeyboard::listener()</code> is a tiny thread that is started by NxWM that just listens for keyboard input. It opens the keyboard device and waits on a <code>read()</code> from the keyboard device to receive the next keyboard input. When data is returned by reading from the keyboard device, <code>CKeyboard::listener()</code> calls <code>nx_kbdin()</code></li><li><code>nuttx\\libnx\\nxmu\\nx_kbdin.c</code> This library function just hides the NX server messaging implementation. It sends the <code>NX_SVRMSG_KBDIN</code> to the NX server thread.</li></ul></blockquote></li><li><p>Kernel Space / NX Server</p><p>The NX Server wakes up, receives the keyboard message, and forwards it to the appropriate window.</p><blockquote><ul><li><code>nuttx/graphics/nxmu/nxmu/nxmu_server.c</code> The receipt of the <code>NX_SVRMSG_KBDIN</code> message wakes up the NX server thread. The NX server thread decodes the message and calls <code>nxmu_kbdin()</code>.</li><li><code>nuttx/graphics/nxconsole/nxmu_kbdin.c</code> <code>nxmu_kbdin()</code> simply sends the <code>NX_CLIMSG_KBDIN</code> to the appropriate windows client via the client message queue associated with the window.</li></ul></blockquote></li><li><p>Application Space / NxWidgets Window Event Handler Thread</p><p>The Windows client wakes up when the keyboard message is received. It forwards the keyboard data to <code>/dev/nxcon0/</code> so that is can be available to the NxConsole window.</p><blockquote><ul><li><code>nuttx/libnx/nxwm/nx_eventhandler</code> The <code>nx_eventhandler()</code> logic running in the <code>CNxServer::listener()</code> thread receives the <code>NX_CLIMSG_KBDIN</code> message and dispatches it to the kbdin callback method. In this case that callback method maps to <code>CCallback::newKeyboardEvent()</code>.</li><li><code>NxWidgets/libnxwidgets/src/ccallback.cxx</code> For normal keyboard input, <code>CCallback::newKeyboardEvent()</code> directs the Keyboard to the widget with focus via the <code>CWidgetControl::newKeyboardEvent()</code> method. But the story is different for the NxConsole window. This case, <code>CCallback::newKeyboardEvent()</code>, calls <code>nxcon_kbdin()</code>.</li><li><code>nuttx/graphics/nxconsole/nxcon_kbdin.c</code> <code>nxcon_kbdin()</code> adds the keyboard data to a circular buffer and wakes up any reads on the <code>/dev/nxcon0</code> input device.</li></ul></blockquote><p>NOTE: Here is a violation of the Application and Kernel Space boundaries. <code>nxcon_kbdin.c</code> built into Kernel Space but it is called from Application Space. The solution is to (1) move <code>nxcon_kbdin()</code> to <code>libnx/</code> and (2) it should then communicate with the <code>/dev/nxcon9</code> driver via ioctl calls. This will become a problem some day.</p></li><li><p>Kernel Space / NxConsole Thread</p><p>Finally,</p><p>: - <code>nuttx/graphics/nxconsole/nxcon_kbdin.c</code> The receipt and enqueuing of keyboard data by <code>nxcon_kbdin()</code> wakes up any threads waiting in the <code>nxcon_read()</code> method. This is how the NxConsole gets its keyboard input.</p></li></ol><p><strong>Mouse Input</strong> Almost everything said here applies to mouse/touchscreen input as well. If we were to replace the names keyboard to mouse, kbdin to mousein, etc. you have a pretty good description of how mouse/touchscreen input works.</p><p>The mouse/touchscreen input is a little simpler, however: The main simplication is that the additional complexities of the NxConsole and its special input device do not apply. Mouse/touchscreen input as always steered to widgets when the callback is received in <code>CCallback::newMouseEvent</code> by an unconditional call to <code>CWidgetControl::newMouseEvent</code>. There is a &quot;fork in the road&quot; at the corresponding point in the logic of <code>CCallback::newKeyboardEvent</code></p>',12)]))}const x=o(i,[["render",d]]);export{u as __pageData,x as default};
