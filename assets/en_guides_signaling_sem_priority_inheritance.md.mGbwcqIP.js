import{_ as a,c as t,al as s,o as i}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"Signaling Semaphores and Priority Inheritance","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/signaling_sem_priority_inheritance.md","filePath":"en/guides/signaling_sem_priority_inheritance.md"}'),o={name:"en/guides/signaling_sem_priority_inheritance.md"};function r(n,e,h,l,p,c){return i(),t("div",null,e[0]||(e[0]=[s(`<h1 id="signaling-semaphores-and-priority-inheritance" tabindex="-1">Signaling Semaphores and Priority Inheritance <a class="header-anchor" href="#signaling-semaphores-and-priority-inheritance" aria-label="Permalink to &quot;Signaling Semaphores and Priority Inheritance&quot;">​</a></h1><p>Warning</p><p>Migrated from <a href="https://cwiki.apache.org/confluence/display/NUTTX/Signaling+Semaphores+and+Priority+Inheritance" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Signaling+Semaphores+and+Priority+Inheritance</a></p><h2 id="locking-vs-signaling-semaphores" tabindex="-1">Locking vs Signaling Semaphores <a class="header-anchor" href="#locking-vs-signaling-semaphores" aria-label="Permalink to &quot;Locking vs Signaling Semaphores&quot;">​</a></h2><h3 id="locking-semaphores" tabindex="-1">Locking Semaphores <a class="header-anchor" href="#locking-semaphores" aria-label="Permalink to &quot;Locking Semaphores&quot;">​</a></h3><p>POSIX counting semaphores have multiple uses. The typical usage is where the semaphore is used as lock on one or more resources. In this typical case, priority inheritance works perfectly: The holder of a semaphore count must be remembered so that its priority can be boosted if a higher priority task requires a count from the semaphore. It remains the holder until the same task calls <code>sem_post()</code> to release the count on the semaphore.</p><h3 id="mutual-exclusion-example" tabindex="-1">Mutual Exclusion Example <a class="header-anchor" href="#mutual-exclusion-example" aria-label="Permalink to &quot;Mutual Exclusion Example&quot;">​</a></h3><p>This usage is very common for providing mutual exclusion. The semaphore is initialized to a value of one. The first task to take the semaphore has access; additional tasks that need access will then block until the first holder calls <code>sem_post()</code> to relinquish access:</p><hr><p><strong>TASK A</strong> <strong>TASK B</strong></p><hr><p class="title-ref">[have<br> access]</p><p class="title-ref">[priority <strong>sem_wait(sem);</strong> boost]</p><p class="title-ref">[priority [have restored]{.title-ref} access]</p><p><strong>sem_post(sem);</strong></p><p><strong>sem_wait(sem);</strong></p><pre><code>                      [blocked]{.title-ref}
</code></pre><hr><p>The important thing to note is that <code>sem_wait()</code> and <code>sem_post()</code> both called on the same thread, TASK A. When <code>sem_wait()</code> succeeds, TASK A becomes the holder of the semaphore and, while it is the holder of the semaphore (1) other threads, such as TASK B, cannot access the protected resource and (2) the priority of TASK A may be modified by the priority inheritance logic. TASK A remains the holder until is calls <code>sem_post()</code> on the [same thread]{.title-ref}. At that time, (1) its priority may be restored and (2) TASK B has access to the resource.</p><h3 id="signaling-semaphores" tabindex="-1">Signaling Semaphores <a class="header-anchor" href="#signaling-semaphores" aria-label="Permalink to &quot;Signaling Semaphores&quot;">​</a></h3><p>But a very different usage model for semaphores is for signaling events. In this case, the semaphore count is initialized to zero and the receiving task calls <code>sem_wait()</code> to wait for the next event of interest to occur. When an event of interest is detected by another task (or even an interrupt handler), <code>sem_post()</code> is called which increments the count to 1 and wakes up the receiving task.</p><h2 id="signaling-semaphores-and-priority-inheritance-details" tabindex="-1">Signaling Semaphores and Priority Inheritance details <a class="header-anchor" href="#signaling-semaphores-and-priority-inheritance-details" aria-label="Permalink to &quot;Signaling Semaphores and Priority Inheritance details&quot;">​</a></h2><h3 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h3><p>For example, in the following TASK A waits on a semaphore for events and TASK B (or perhaps an interrupt handler) signals task A of the occurrence of the events by posting to that semaphore:</p><hr><p><strong>TASK A</strong> <strong>TASK B</strong></p><hr><p><strong>sem_init(sem, 0, 0);</strong></p><p><strong>sem_wait(sem);</strong></p><p class="title-ref">[blocked]</p><pre><code>                         **sem\\_post(sem);**
</code></pre><h2 class="title-ref" id="awakens-asholder" tabindex="-1">[Awakens as<br> holder] <a class="header-anchor" href="#awakens-asholder" aria-label="Permalink to &quot;[Awakens as                
  holder]{.title-ref}&quot;">​</a></h2><p>Notice that unlike the mutual exclusion case above, <code>sem_wait()</code> and <code>sem_post()</code> are called on [different]{.title-ref} threads.</p><h3 id="usage-in-drivers" tabindex="-1">Usage in Drivers <a class="header-anchor" href="#usage-in-drivers" aria-label="Permalink to &quot;Usage in Drivers&quot;">​</a></h3><p>This usage case is used often within drivers, for example, when the user calls the <code>read()</code> method and there is no data available. <code>sem_wait()</code> is called to wait for new data to be received; <code>sem_post()</code> is called when the new data arrives and the user task is re-awakened.</p><h3 id="priority-inheritance-fails" tabindex="-1">Priority Inheritance Fails <a class="header-anchor" href="#priority-inheritance-fails" aria-label="Permalink to &quot;Priority Inheritance Fails&quot;">​</a></h3><p>These two usage models, the locking modeling and the signaling model, are really very different and priority inheritance simply does not apply when the semaphore is used for signalling rather than locking. In this signaling case priority inheritance can interfere with the operation of the semaphore. The problem is that when TASK A is awakened it is a holder of the semaphore. Normally, a task is removed from the holder list when it finally releases the semaphore via <code>sem_post()</code>.</p><p>In this case, TASK B calls <code>sem_post(sem)</code> but TASK B is not the holder of the semaphore. Since TASK A never calls <code>sem_post(sem)</code> it becomes a permanently a holder of the semaphore and may have its priority boosted at any time when any other task tries to acquire the semaphore.</p><h3 id="who-s-to-blame" tabindex="-1">Who&#39;s to Blame <a class="header-anchor" href="#who-s-to-blame" aria-label="Permalink to &quot;Who\\&#39;s to Blame&quot;">​</a></h3><p>In the POSIX case, priority inheritance is specified only in the pthread mutex layer. In NuttX, on the other hand, pthread mutexes are simply built on top of binary locking semaphores. Hence, in NuttX, priority inheritance is implemented in the semaphore layer.</p><p>In the case of a mutex this could be simply resolved since there is only one holder but for the case of counting semaphores, there may be many holders and if the holder is not the thread that calls <code>sem_post()</code>, then it is not possible to know which thread/holder should be released.</p><h2 id="selecting-the-semaphore-protocol" tabindex="-1">Selecting the Semaphore Protocol <a class="header-anchor" href="#selecting-the-semaphore-protocol" aria-label="Permalink to &quot;Selecting the Semaphore Protocol&quot;">​</a></h2><h3 id="sem-setprotocol" tabindex="-1"><code>sem_setprotocol()</code> <a class="header-anchor" href="#sem-setprotocol" aria-label="Permalink to &quot;\`sem_setprotocol()\`&quot;">​</a></h3><p>The fix is to call non-standard NuttX function <code>sem_setprotocol(SEM_PRIO_NONE)</code> immediately after the <code>sem_init()</code>. The effect of this function call is to disable priority inheritance for that specific semaphore. There should then be no priority inheritance operations on this semaphore that is used for signalling.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sem_t sem</span></span>
<span class="line"><span>// ...</span></span>
<span class="line"><span>sem_init(&amp;sem, 0, 0);</span></span>
<span class="line"><span>sem_setprotocol(&amp;sem, SEM_PRIO_NONE);</span></span></code></pre></div><p>Here is the rule: If you have priority inheritance enabled and you use semaphores for signaling events, then you [must]{.title-ref} call <code>sem_setprotocol(SEM_PRIO_NONE)</code> immediately after initializing the semaphore.</p><h3 id="why-another-non-standard-os-interface" tabindex="-1">Why Another Non-Standard OS Interface? <a class="header-anchor" href="#why-another-non-standard-os-interface" aria-label="Permalink to &quot;Why Another Non-Standard OS Interface?&quot;">​</a></h3><p>The non-standard <code>sem_setprotocol()</code> is the [moral]{.title-ref} [equivalent]{.title-ref} of the POSIX <code>pthread_mutexattr_setprotocol()</code> and its naming reflects that relationship. In most implementations, priority inheritance is implemented only in the pthread mutex layer. In NuttX, on the other hand, pthread mutexes are simply built on top of binary locking semaphores. Hence, in NuttX, priority inheritance is implemented in the semaphore layer. This architecture then requires an interface like <code>sem_setprotocol()</code> in order to manage the protocol of the underlying semaphore.</p><h3 id="pthread-mutexattr-setprotocol" tabindex="-1"><code>pthread_mutexattr_setprotocol()</code> <a class="header-anchor" href="#pthread-mutexattr-setprotocol" aria-label="Permalink to &quot;\`pthread_mutexattr_setprotocol()\`&quot;">​</a></h3><p>Since NuttX implements pthread mutexes on top of binary semaphores, the above recommendation also applies when pthread mutexes are used for inter-thread signaling. That is, a mutex that is used for signaling should be initialize like this (simplified, no error checking here):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pthread_mutexattr_t attr;</span></span>
<span class="line"><span>pthread_mutex_t mutex;</span></span>
<span class="line"><span>// ...</span></span>
<span class="line"><span>pthread_mutexattr_init(&amp;attr);</span></span>
<span class="line"><span>pthread_mutexattr_settype(&amp;attr, PTHREAD_PRIO_NONE);</span></span>
<span class="line"><span>pthread_mutex_init(&amp;mutex, &amp;attr);</span></span></code></pre></div><h2 id="is-this-always-a-problem" tabindex="-1">Is this Always a Problem? <a class="header-anchor" href="#is-this-always-a-problem" aria-label="Permalink to &quot;Is this Always a Problem?&quot;">​</a></h2><p>Ideally <code>sem_setprotocol(SEM_PRIO_NONE)</code> should be called for all signaling semaphores. But, no, often the use of a signaling semaphore with priority inversion is not a problem. It is not a problem if the signaling semaphore is always taken on the same thread. For example:</p><ul><li>If the driver is used by only a single task, or</li><li>If the semaphore is only taken on the worker thread.</li></ul><p>But this can be a serious problem if multiple tasks ever wait on the signaling semaphore. Drivers like the serial driver, for example, have many user threads that may call into the driver.</p>`,55)]))}const u=a(o,[["render",r]]);export{m as __pageData,u as default};
