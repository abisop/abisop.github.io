import{_ as s,c as t,al as i,j as e,a as n,o as l}from"./chunks/framework.NFAqBSgQ.js";const b=JSON.parse('{"title":"I/O Buffer Management","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/os/iob.md","filePath":"en/reference/os/iob.md"}'),o={name:"en/reference/os/iob.md"};function r(c,a,p,u,d,f){return l(),t("div",null,a[0]||(a[0]=[i(`<h1 id="i-o-buffer-management" tabindex="-1">I/O Buffer Management <a class="header-anchor" href="#i-o-buffer-management" aria-label="Permalink to &quot;I/O Buffer Management&quot;">​</a></h1><p>NuttX supports generic I/O buffer management (IOB) logic. This logic was originally added to support network I/O buffering, but has been generalized to meet buffering requirements by all device drivers. At the time of this writing, IOBs are currently used not only be networking but also by logic in <code>drivers/syslog</code> and <code>drivers/wireless</code>. NOTE that some of the wording in this section still reflects those legacy roots as a part of the networking subsystem. This objectives of this feature are:</p><blockquote><ol><li>Provide common I/O buffer management logic for all drivers,</li><li>Support I/O buffer allocation from both the tasking and interrupt level contexts.</li><li>Use a fixed amount of pre-allocated memory.</li><li>No costly, non-deterministic dynamic memory allocation.</li><li>When the fixed number of pre-allocated I/O buffers is exhausted, further attempts to allocate memory from tasking logic will cause the task to block and wait until a an I/O buffer to be freed.</li><li>Each I/O buffer should be small, but can be chained together to support buffering of larger thinks such as full size network packets.</li><li>Support <em>throttling</em> logic to prevent lower priority tasks from hogging all available I/O buffering.</li></ol></blockquote><h2 id="configuration-options" tabindex="-1">Configuration Options <a class="header-anchor" href="#configuration-options" aria-label="Permalink to &quot;Configuration Options&quot;">​</a></h2><p><code>CONFIG_MM_IOB</code></p><p>: Enables generic I/O buffer support. This setting will build the common I/O buffer (IOB) support library.</p><p><code>CONFIG_IOB_NBUFFERS</code></p><p>: Number of pre-allocated I/O buffers. Each packet is represented by a series of small I/O buffers in a chain. This setting determines the number of preallocated I/O buffers available for packet data. The default value is setup for network support. The default is 8 buffers if neither TCP/UDP or write buffering is enabled (neither <code>CONFIG_NET_TCP_WRITE_BUFFERS</code> nor <code>CONFIG_NET_TCP</code>), 24 if only TCP/UDP is enabled, and 36 if both TCP/UDP and write buffering are enabled.</p><p><code>CONFIG_IOB_BUFSIZE</code></p><p>: Payload size of one I/O buffer. Each packet is represented by a series of small I/O buffers in a chain. This setting determines the data payload each preallocated I/O buffer. The default value is 196 bytes.</p><p><code>CONFIG_IOB_NCHAINS</code></p><p>: Number of pre-allocated I/O buffer chain heads. These tiny nodes are used as <em>containers</em> to support queueing of I/O buffer chains. This will limit the number of I/O transactions that can be <em>in-flight</em> at any give time. The default value of zero disables this features. These generic I/O buffer chain containers are not currently used by any logic in NuttX. That is because their other other specialized I/O buffer chain containers that also carry a payload of usage specific information. The default value is zero if nether TCP nor UDP is enabled (i.e., neither <code>CONFIG_NET_TCP</code> &amp;&amp; !<code>CONFIG_NET_UDP</code> or eight if either is enabled.</p><p><code>CONFIG_IOB_THROTTLE</code></p><p>: I/O buffer throttle value. TCP write buffering and read-ahead buffer use the same pool of free I/O buffers. In order to prevent uncontrolled incoming TCP packets from hogging all of the available, pre-allocated I/O buffers, a throttling value is required. This throttle value assures that I/O buffers will be denied to the read-ahead logic before TCP writes are halted. The default 0 if neither TCP write buffering nor TCP read-ahead buffering is enabled. Otherwise, the default is 8.</p><p><code>CONFIG_IOB_DEBUG</code></p><p>: Force I/O buffer debug. This option will force debug output from I/O buffer logic. This is not normally something that would want to do but is convenient if you are debugging the I/O buffer logic and do not want to get overloaded with other un-related debug output. NOTE that this selection is not available if DEBUG features are not enabled (<code>CONFIG_DEBUG_FEATURES</code>) with IOBs are being used to syslog buffering logic (<code>CONFIG_SYSLOG_BUFFER</code>).</p><h2 id="throttling" tabindex="-1">Throttling <a class="header-anchor" href="#throttling" aria-label="Permalink to &quot;Throttling&quot;">​</a></h2><p>An allocation throttle was added. I/O buffer allocation logic supports a throttle value originally for read-ahead buffering to prevent the read-ahead logic from consuming all available I/O buffers and blocking the write buffering logic. This throttle logic is only needed for networking only if both write buffering and read-ahead buffering are used. Of use of I/O buffering might have other motivations for throttling.</p><h2 id="public-types" tabindex="-1">Public Types <a class="header-anchor" href="#public-types" aria-label="Permalink to &quot;Public Types&quot;">​</a></h2><p>This structure represents one I/O buffer. A packet is contained by one or more I/O buffers in a chain. The <code>io_pktlen</code> is only valid for the I/O buffer at the head of the chain.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct iob_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  /* Singly-link list support */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  FAR struct iob_s *io_flink;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Payload */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if CONFIG_IOB_BUFSIZE &lt; 256</span></span>
<span class="line"><span>  uint8_t  io_len;      /* Length of the data in the entry */</span></span>
<span class="line"><span>  uint8_t  io_offset;   /* Data begins at this offset */</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>  uint16_t io_len;      /* Length of the data in the entry */</span></span>
<span class="line"><span>  uint16_t io_offset;   /* Data begins at this offset */</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>  uint16_t io_pktlen;   /* Total length of the packet */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  uint8_t  io_data[CONFIG_IOB_BUFSIZE];</span></span>
<span class="line"><span>};</span></span></code></pre></div><p>This container structure supports queuing of I/O buffer chains. This structure is intended only for internal use by the IOB module.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#if CONFIG_IOB_NCHAINS &gt; 0</span></span>
<span class="line"><span>struct iob_qentry_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  /* Singly-link list support */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  FAR struct iob_qentry_s *qe_flink;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Payload -- Head of the I/O buffer chain */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  FAR struct iob_s *qe_head;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>#endif /* CONFIG_IOB_NCHAINS &gt; 0 */</span></span></code></pre></div><p>The I/O buffer queue head structure.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#if CONFIG_IOB_NCHAINS &gt; 0</span></span>
<span class="line"><span>struct iob_queue_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  /* Head of the I/O buffer chain list */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  FAR struct iob_qentry_s *qh_head;</span></span>
<span class="line"><span>  FAR struct iob_qentry_s *qh_tail;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>#endif /* CONFIG_IOB_NCHAINS &gt; 0 */</span></span></code></pre></div><h2 id="public-function-prototypes" tabindex="-1">Public Function Prototypes <a class="header-anchor" href="#public-function-prototypes" aria-label="Permalink to &quot;Public Function Prototypes&quot;">​</a></h2>`,26),e("blockquote",null,[e("ul",null,[e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_initialize()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_alloc()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_tryalloc()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_free()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_free_chain()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_add_queue()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_tryadd_queue()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_remove_queue()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_peek_queue()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_free_queue()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_free_queue_qentry()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_get_queue_size()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_copyin()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_trycopyin()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_copyout()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_clone()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_clone_partial()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_concat()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_trimhead()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_trimhead_queue()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_trimtail()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_pack()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_contig()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_count()")]),e("li",null,[n(":c"),e("code",{class:"interpreted-text",role:"func"},"iob_dump()")])])],-1)]))}const _=s(o,[["render",r]]);export{b as __pageData,_ as default};
