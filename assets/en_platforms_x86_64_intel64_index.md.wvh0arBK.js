import{_ as a,c as o,al as t,o as i}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"Intel64","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/x86_64/intel64/index.md","filePath":"en/platforms/x86_64/intel64/index.md"}'),r={name:"en/platforms/x86_64/intel64/index.md"};function c(n,e,s,d,l,u){return i(),o("div",null,e[0]||(e[0]=[t(`<h1 id="intel64" tabindex="-1">Intel64 <a class="header-anchor" href="#intel64" aria-label="Permalink to &quot;Intel64&quot;">​</a></h1><h2 id="architecture-specific-directories" tabindex="-1">Architecture-Specific Directories <a class="header-anchor" href="#architecture-specific-directories" aria-label="Permalink to &quot;Architecture-Specific Directories&quot;">​</a></h2><p>Architecture-specific directories hold common source files shared for by implementations of specific x86_64 architectures.</p><p><code>intel64</code></p><p>: This directory holds logic appropriate for any instantiation of the 64-bit intel64 architecture.</p><h2 id="chip-specific-directories" tabindex="-1">Chip-Specific directories <a class="header-anchor" href="#chip-specific-directories" aria-label="Permalink to &quot;Chip-Specific directories&quot;">​</a></h2><p>The same x86 architecture may be realized in different chip implementations. For SoC chips, in particular, on-chip devices and differing interrupt structures may require special, chip-specific definitions in these chip-specific directories.</p><p><code>qemu</code></p><p>: This is the implementation of NuttX on the QEMU x86_64. It&#39;s empty for now.</p><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h2><h3 id="hardware-acceleration" tabindex="-1">Hardware acceleration <a class="header-anchor" href="#hardware-acceleration" aria-label="Permalink to &quot;Hardware acceleration&quot;">​</a></h3><p>Configurable hardware acceleration: SSE, AVX2, AVX512 support.</p><p>FMA, AVX and AVX512 support requires <code>XSAVE</code> instructions support which is controlled with <code>CONFIG_ARCH_X86_64_HAVE_XSAVE</code> option.</p><h3 id="irqs" tabindex="-1">IRQs <a class="header-anchor" href="#irqs" aria-label="Permalink to &quot;IRQs&quot;">​</a></h3><p>IRQs are managed by LAPIC(X2APIC) and IOAPIC.</p><h3 id="clock-source" tabindex="-1">Clock source <a class="header-anchor" href="#clock-source" aria-label="Permalink to &quot;Clock source&quot;">​</a></h3><p>TSC DEADLINE timer, APIC timer or HPET can be used as system clock.</p><h3 id="smp" tabindex="-1">SMP <a class="header-anchor" href="#smp" aria-label="Permalink to &quot;SMP&quot;">​</a></h3><p>SMP is supported up to 4 cores now (BSP + 3 AP), but can be easily extended.</p><h3 id="hpet" tabindex="-1">HPET <a class="header-anchor" href="#hpet" aria-label="Permalink to &quot;HPET&quot;">​</a></h3><p>High Precision Event Timer (HPET) is supported as oneshot timer.</p><h3 id="rdrand" tabindex="-1">RDRAND <a class="header-anchor" href="#rdrand" aria-label="Permalink to &quot;RDRAND&quot;">​</a></h3><p>The <code>/dev/random</code> device support with <code>RDRAND</code> instruction is enabled with <code>CONFIG_ARCH_INTEL64_HAVE_RDRAND=y</code></p><h3 id="pci-bus" tabindex="-1">PCI bus <a class="header-anchor" href="#pci-bus" aria-label="Permalink to &quot;PCI bus&quot;">​</a></h3><p>PCI bus is supported with legacy interrupts, MSI and MSI-X.</p><h3 id="multiboot-framebuffer" tabindex="-1">Multiboot Framebuffer <a class="header-anchor" href="#multiboot-framebuffer" aria-label="Permalink to &quot;Multiboot Framebuffer&quot;">​</a></h3><p>Multiboot2 framebuffer is supported with <code>CONFIG_MULTBOOT2_FB_TERM=y</code>.</p><p>It is very possible that the framebuffer is mapped in a memory region above 4GB, so you may also need to set <code>CONFIG_MM_PGALLOC=y</code>.</p><p>To enable framebuffer support in QEMU, omit the <code>-nographic</code> argument and use <code>-cdrom boot.iso</code> (multiboot2 framebuffer doesn&#39;t work with <code>-kernel</code> option).</p><p>Also, your GRUB configuration (<code>grub.cfg</code>) should insert the appropriate video module, in many cases <code>insmod all_video</code> should be enough.</p><h3 id="kernel-build" tabindex="-1">Kernel build <a class="header-anchor" href="#kernel-build" aria-label="Permalink to &quot;Kernel build&quot;">​</a></h3><p>Kernel build is supported.</p><p>Warning</p><p>IMPORTANT: the current implementation doesn&#39;t include any protection against speculative execution vulnerabilities (Spectre, Meltdown and others) !</p><h2 id="creating-a-bootable-disk" tabindex="-1">Creating a bootable disk <a class="header-anchor" href="#creating-a-bootable-disk" aria-label="Permalink to &quot;Creating a bootable disk&quot;">​</a></h2><p>This build supports multiboot2, which means that usual multiboot2 bootloaders, e.g. grub can be used. To create a bootable disk with grub2, create a directory named <code>iso</code> with grub configuration file and the compiled <code>nuttx.elf</code>.</p><p>Directory and file hierarchy:</p><pre><code>- iso/
  - boot/
    - grub/
      - grub.cfg
    - nuttx.elf
</code></pre><p>The grub.cfg should contain the boot entry of NuttX:</p><pre><code>set timeout=0
set default=0
menuentry &quot;kernel&quot; {
  multiboot2 /boot/nuttx.elf
}
</code></pre><h3 id="making-the-disk" tabindex="-1">Making the disk <a class="header-anchor" href="#making-the-disk" aria-label="Permalink to &quot;Making the disk&quot;">​</a></h3><p>Use the following command to create the disk. P.S. In some distros, <code>grub-mkrescue</code> is called <code>grub2-mkrescue</code>:</p><pre><code>grub-mkrescue -o boot.iso iso
</code></pre><h3 id="grub-with-uefi" tabindex="-1">Grub with UEFI <a class="header-anchor" href="#grub-with-uefi" aria-label="Permalink to &quot;Grub with UEFI&quot;">​</a></h3><p>This flow is very similar except you need to have the BOOTX64.EFI file. You can find this in most Linux distributions:</p><pre><code>iso/
└── boot
    ├── efi
    │   └── EFI
    │       └── BOOT
    │           └── BOOTX64.EFI
    ├── grub
    │   └── grub.cfg
    └── nuttx.elf
</code></pre><h2 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h2><blockquote><p>boards/<em>/</em></p></blockquote>`,48)]))}const b=a(r,[["render",c]]);export{p as __pageData,b as default};
