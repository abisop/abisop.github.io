import{_ as t,c as o,al as n,o as s}from"./chunks/framework.NFAqBSgQ.js";const _=JSON.parse('{"title":"USB Device Trace","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/usbtrace.md","filePath":"en/guides/usbtrace.md"}'),a={name:"en/guides/usbtrace.md"};function i(c,e,r,d,l,p){return s(),o("div",null,e[0]||(e[0]=[n(`<h1 id="usb-device-trace" tabindex="-1">USB Device Trace <a class="header-anchor" href="#usb-device-trace" aria-label="Permalink to &quot;USB Device Trace&quot;">â€‹</a></h1><p><strong>USB Device Tracing Controls</strong>. The NuttX USB device subsystem supports a fairly sophisticated tracing facility. The basic trace capability is controlled by these NuttX configuration settings:</p><blockquote><ul><li><code>CONFIG_USBDEV_TRACE</code>: Enables USB tracing</li><li><code>CONFIG_USBDEV_TRACE_NRECORDS</code>: Number of trace entries to remember</li></ul></blockquote><p><strong>Trace IDs</strong>. The trace facility works like this: When enabled, USB events that occur in either the USB device driver or in the USB class driver are logged. These events are described in <code>include/nuttx/usb/usbdev_trace.h</code>. The logged events are identified by a set of event IDs:</p><p>+-------------------------+-------------------------------------+ | <code>TRACE_INIT_ID</code> | Initialization events | +-------------------------+-------------------------------------+ | <code>TRACE_EP_ID</code> | &gt; Endpoint API calls | +-------------------------+-------------------------------------+ | <code>TRACE_DEV_ID</code> | &gt; USB device API calls | +-------------------------+-------------------------------------+ | <code>TRACE_CLASS_ID</code> | USB class driver API calls | +-------------------------+-------------------------------------+ | <code>TRACE_CLASSAPI_ID</code> | Other class driver system API calls | +-------------------------+-------------------------------------+ | <code>TRACE_CLASSSTATE_ID</code> | Track class driver state changes | +-------------------------+-------------------------------------+ | <code>TRACE_INTENTRY_ID</code> | Interrupt handler entry | +-------------------------+-------------------------------------+ | <code>TRACE_INTDECODE_ID</code> | Decoded interrupt event | +-------------------------+-------------------------------------+ | <code>TRACE_INTEXIT_ID</code> | &gt; Interrupt handler exit | +-------------------------+-------------------------------------+ | <code>TRACE_OUTREQQUEUED_ID</code> | Request queued for OUT endpoint | +-------------------------+-------------------------------------+ | <code>TRACE_INREQQUEUED_ID</code> | Request queued for IN endpoint | +-------------------------+-------------------------------------+ | <code>TRACE_READ_ID</code> | Read (OUT) action | +-------------------------+-------------------------------------+ | <code>TRACE_WRITE_ID</code> | Write (IN) action | +-------------------------+-------------------------------------+ | <code>TRACE_COMPLETE_ID</code> | Request completed | +-------------------------+-------------------------------------+ | <code>TRACE_DEVERROR_ID</code> | USB controller driver error event | +-------------------------+-------------------------------------+ | <code>TRACE_CLSERROR_ID</code> | USB class driver error event | +-------------------------+-------------------------------------+</p><p><strong>Logged Events</strong>. Each logged event is 32-bits in size and includes</p><blockquote><ol><li>8-bits of the trace ID (values associated with the above)</li><li>8-bits of additional trace ID data, and</li><li>16-bits of additional data.</li></ol></blockquote><p><strong>8-bit Trace Data</strong> The 8-bit trace data depends on the specific event ID. As examples,</p><blockquote><ul><li>For the USB serial and mass storage class, the 8-bit event data is provided in <code>include/nuttx/usb/usbdev_trace.h</code>.</li><li>For the USB device driver, that 8-bit event data is provided within the USB device driver itself. So, for example, the 8-bit event data for the LPC1768 USB device driver is found in <code>arch/arm/src/lpc17xx_40xx/lpc17_40_usbdev.c</code>.</li></ul></blockquote><p><strong>16-bit Trace Data</strong>. The 16-bit trace data provided additional context data relevant to the specific logged event.</p><p><strong>Trace Control Interfaces</strong>. Logging of each of these kinds events can be enabled or disabled using the interfaces described in <code>include/nuttx/usb/usbdev_trace.h</code>.</p><p><strong>Enabling USB Device Tracing</strong>. USB device tracing will be configured if <code>CONFIG_USBDEV</code> and either of the following are set in the NuttX configuration file:</p><blockquote><ul><li><code>CONFIG_USBDEV_TRACE</code>, or</li><li><code>CONFIG_DEBUG_FEATURES and CONFIG_DEBUG_USB</code></li></ul></blockquote><p><strong>Log Data Sink</strong>. The logged data itself may go to either (1) an internal circular buffer, or (2) may be provided on the console. If <code>CONFIG_USBDEV_TRACE</code> is defined, then the trace data will go to the circular buffer. The size of the circular buffer is determined by <code>CONFIG_USBDEV_TRACE_NRECORDS</code>. Otherwise, the trace data goes to console.</p><p><strong>Example</strong>. Here is an example of USB trace output using <code>apps/examples/usbserial</code> for an LPC1768 platform with the following NuttX configuration settings:</p><blockquote><ul><li><code>CONFIG_DEBUG_FEATURES</code>, <code>CONFIG_DEBUG_INFO</code>, <code>CONFIG_USB</code></li><li><code>CONFIG_EXAMPLES_USBSERIAL_TRACEINIT</code>, <code>CONFIG_EXAMPLES_USBSERIAL_TRACECLASS</code>, <code>CONFIG_EXAMPLES_USBSERIAL_TRACETRANSFERS</code>, <code>CONFIG_EXAMPLES_USBSERIAL_TRACECONTROLLER</code>, <code>CONFIG_EXAMPLES_USBSERIAL_TRACEINTERRUPTS</code></li></ul></blockquote><p>Console Output:</p><pre><code>ABDE
usbserial_main: Registering USB serial driver
uart_register: Registering /dev/ttyUSB0
usbserial_main: Successfully registered the serial driver
1     Class API call 1: 0000
2     Class error: 19:0000
usbserial_main: ERROR: Failed to open /dev/ttyUSB0 for reading: 107
usbserial_main: Not connected. Wait and try again.
3     Interrupt 1 entry: 0039
4     Interrupt decode 7: 0019
5     Interrupt decode 32: 0019
6     Interrupt decode 6: 0019
7     Class disconnect(): 0000
8     Device pullup(): 0001
9     Interrupt 1 exit: 0000
</code></pre><p>The numbered items are USB USB trace output. You can look in the file <code>drivers/usbdev/usbdev_trprintf.c</code> to see examctly how each output line is formatted. Here is how each line should be interpreted:</p><hr><p>N. USB EVENT ID 8-bit EVENT DATA MEANING 16-bit EVENT DATA 1 TRACE_CLASSAPI_ID1 1 USBSER_TRACECLASSAPI_SETUP1 0000 2 TRACE_CLSERROR_ID1 19 USBSER_TRACEERR_SETUPNOTCONNECTED1 0000 3 TRACE_INTENTRY_ID1 1 LPC17_40_TRACEINTID_USB2 0039 4 TRACE_INTDECODE_ID2 7 LPC17_40_TRACEINTID_DEVSTAT2 0019 5 TRACE_INTDECODE_ID2 32 LPC17_40_TRACEINTID_SUSPENDCHG2 0019 6 TRACE_INTDECODE_ID2 6 LPC17_40_TRACEINTID_DEVRESET2 0019 7 TRACE_CLASS_ID1 3 (See TRACE_CLASSDISCONNECT1) 0000 8 TRACE_DEV_ID1 6 (See TRACE_DEVPULLUP1) 0001 9 TRACE_INTEXIT_ID1 1 LPC17_40_TRACEINTID_USB2 0000</p><hr><p>NOTES:</p><blockquote><ol><li>See include/nuttx/usb/usbdev_trace.h</li><li>See arch/arm/src/lpc17xx_40xx/lpc17_40_usbdev.c</li></ol></blockquote><p>In the above example you can see that:</p><blockquote><ul><li><p><strong>1</strong>. The serial class USB setup method was called for the USB serial class. This is the corresponds to the following logic in <code>drivers/usbdev/pl2303.c</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>static int pl2303_setup(FAR struct uart_dev_s *dev)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>  usbtrace(PL2303_CLASSAPI_SETUP, 0);</span></span>
<span class="line"><span>  ...</span></span></code></pre></div></li><li><p><strong>2</strong>. An error occurred while processing the setup command because no configuration has yet been selected by the host. This corresponds to the following logic in <code>drivers/usbdev/pl2303.c</code>:</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>static int pl2303_setup(FAR struct uart_dev_s *dev)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>  /* Check if we have been configured */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  if (priv-&gt;config == PL2303_CONFIGIDNONE)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      usbtrace(TRACE_CLSERROR(USBSER_TRACEERR_SETUPNOTCONNECTED), 0);</span></span>
<span class="line"><span>      return -ENOTCONN;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  ...</span></span></code></pre></div></blockquote></li><li><p><strong>3-6</strong>. Here is a USB interrupt that suspends and resets the device.</p></li><li><p><strong>7-8</strong>. During the interrupt processing the serial class is disconnected</p></li><li><p><strong>9</strong>. And the interrupt returns</p></li></ul></blockquote><p><strong>USB Monitor</strong>. The <em>USB monitor</em> is an application in the <code>apps/system/usbmonitor</code> that provides a convenient way to get debug trace output. If tracing is enabled, the USB device will save encoded trace output in in-memory buffer; if the USB monitor is also enabled, that trace buffer will be periodically emptied and dumped to the system logging device (the serial console in most configurations). The following are some of the relevant configuration options:</p><hr><p>Device Drivers -&gt; USB Device Driver Support . <code>CONFIG_USBDEV_TRACE=y</code> Enable USB trace feature <code>CONFIG_USBDEV_TRACE_NRECORDS=nnnn</code> Buffer nnnn records in memory. If you lose trace data, . then you will need to increase the size of this buffer . (or increase the rate at which the trace buffer is emptied). <code>CONFIG_USBDEV_TRACE_STRINGS=y</code> Optionally, convert trace ID numbers to strings. . This feature may not be supported by all drivers.</p><hr><hr><p>Application Configuration -&gt; NSH LIbrary . <code>CONFIG_NSH_USBDEV_TRACE=n</code> Make sure that any built-in tracing from NSH is disabled. <code>CONFIG_NSH_ARCHINIT=y</code> Enable this option only if your board-specific logic . has logic to automatically start the USB monitor. . Otherwise the USB monitor can be started or stopped . with the usbmon_start and usbmon_stop commands from the NSH console.</p><hr><p>+----------------------------------+----------------------------------+ | Application Configuration -&gt; | . | | System NSH Add-Ons | | +----------------------------------+----------------------------------+ | <code>CONFIG_USBMONITOR=y</code> | &gt; Enable the USB monitor daemon | +----------------------------------+----------------------------------+ | <code>C | &gt; Sets the USB monitor daemon | | ONFIG_USBMONITOR_STACKSIZE=nnnn</code> | &gt; stack size to nnnn. The | | | &gt; default is 2KiB. | +----------------------------------+----------------------------------+ | <code>CONFIG_USBMONITOR_PRIORITY=50</code> | Sets the USB monitor daemon | | | priority to nnnn. | +----------------------------------+----------------------------------+ | . | This priority should be low so | | | that it does not | +----------------------------------+----------------------------------+ | . | interfere with other operations, | | | but not so low that | +----------------------------------+----------------------------------+ | . | you cannot dump the buffered USB | | | data sufficiently | +----------------------------------+----------------------------------+ | . | rapidly. The default is 50. | +----------------------------------+----------------------------------+ | <code> | &gt; Dump the buffered USB data | | CONFIG_USBMONITOR_INTERVAL=nnnn</code> | &gt; every nnnn seconds. | +----------------------------------+----------------------------------+ | . | If you lose buffered USB trace | | | data, then dropping | +----------------------------------+----------------------------------+ | . | this value will help by | | | increasing the rate at which | +----------------------------------+----------------------------------+ | . | the USB trace buffer is emptied. | +----------------------------------+----------------------------------+ | <code>CONFIG_USBMONITOR_TRACEINIT=y</code> | Selects which USB event(s) that | | | you want to be traced. | +----------------------------------+----------------------------------+ | <code>CONFIG_USBMONITOR_TRACECLASS=y</code> | . | +----------------------------------+----------------------------------+ | <code>CON | . | | FIG_USBMONITOR_TRACETRANSFERS=y</code> | | +----------------------------------+----------------------------------+ | <code>CONF | . | | IG_USBMONITOR_TRACECONTROLLER=y</code> | | +----------------------------------+----------------------------------+ | <code>CONF | . | | IG_USBMONITOR_TRACEINTERRUPTS=y</code> | | +----------------------------------+----------------------------------+</p><p>NOTE: If USB debug output is also enabled, both outputs will appear on the serial console. However, the debug output will be asynchronous with the trace output and, hence, difficult to interpret.</p>`,35)]))}const E=t(a,[["render",i]]);export{_ as __pageData,E as default};
