import{_ as a,c as s,al as n,o as t}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/drivers.md","filePath":"en/guides/drivers.md"}'),i={name:"en/guides/drivers.md"};function r(o,e,l,p,d,c){return t(),s("div",null,e[0]||(e[0]=[n(`<h1 id="drivers" tabindex="-1">Drivers <a class="header-anchor" href="#drivers" aria-label="Permalink to &quot;Drivers&quot;">​</a></h1><p>Some NuttX boards don&#39;t have full support for all the on-chip peripherals. If you need support for this hardware, you will either need to port a driver from another chip, or write one yourself. This section discusses how to do that.</p><h2 id="porting-a-driver" tabindex="-1">Porting a Driver <a class="header-anchor" href="#porting-a-driver" aria-label="Permalink to &quot;Porting a Driver&quot;">​</a></h2><p>Often support for on-chip peripherals exists in a closely related chip, or even a different family or from a different manufacturer. Many chips are made up of different Intellectual Property (IP) blocks that are licensed from vendors like Cadence, Synopsys, and others. The IP blocks may be similar enough to use another chip&#39;s driver with little modification.</p><ul><li><p>Find a similar driver in NuttX source code:</p><ul><li>Look at register names listed in the datasheet for the peripheral.</li><li>Search the NuttX codebase for the register names (try several different ones).</li><li>Note that you&#39;ll have to compare the datasheet to the header and code files to see if there are differences; there will usually be some differences between architectures, and they can be significant.</li></ul></li><li><p>Find a similar driver in U-Boot, Zephyr or BSD Unix (OpenBSD, FreeBSD, NetBSD) source code:</p><ul><li>Only for inspiration, you can&#39;t copy code because of license incompatibility and Apache Foundation restrictions. (Apache License 2.0 and BSD code can come in with a software grant agreement from the original authors; this can sometimes be hard to get. Ask on the mailing list if you&#39;re unsure.)</li><li>But you can debug to see how the driver works.</li><li><a href="https://www.denx.de/wiki/U-Boot" target="_blank" rel="noreferrer">U-Boot</a> drivers are often easier to understand than BSD Unix drivers because U-Boot is simpler.</li></ul></li><li><p>Understanding how the driver works</p><p>Here are a couple of techniques that helped me.</p><blockquote><ul><li><p>printf debugging</p><ul><li><p>Sprinkle <code>custinfo()</code> logging statements through your code to see execution paths and look at variables while the code is running. The reason to use <code>custinfo()</code> as opposed to the other logging shortcuts (<code>mcinfo()</code>, etc.) is that you can turn on and off other other logging and still see your custom debug logging. Sometimes it&#39;s useful to quiet the flood of logging that comes from a particular debug logging shortcut.</p></li><li><p>Note that printing info to the console will affect timing.</p></li><li><p>Keep a file with just your debug settings in it, like this (<code>debugsettings</code>):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CONFIG_DEBUG_CUSTOM_INFO=y</span></span>
<span class="line"><span>(etc..)</span></span></code></pre></div></li><li><p>Add the settings to the end of your <code>.config</code> file after running <code>make menuconfig</code> (that will reorder the file, making it harder to see and change the debug settings if you need to).</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> cat .config debugsettings &gt; .config1 ; mv .config1 .config</span></span></code></pre></div></li><li><p>If you are using interrupts and threads (many things in NuttX run in different threads as a response to interrupts), you can use printf debugging to see overlapping execution.</p><ul><li><p>Interrupts - here&#39;s how to inspect the C stack frame to see what execution environment is currently running:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uint32_t frame = 0;  /* MUST be the very first thing in the function */</span></span>
<span class="line"><span>uint32_t p_frame;</span></span>
<span class="line"><span>frame++;             /* make sure that frame doesn&#39;t get optimized out */</span></span>
<span class="line"><span>p_frame = (uint32_t)(&amp;frame);</span></span>
<span class="line"><span>custinfo(&quot;p_frame: %08x\\n&quot;, p_frame);</span></span></code></pre></div></li><li><p>Threads - here&#39;s how to get the thread identifier to see which thread is currently executing:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pthread_t thread_id = pthread_self();</span></span>
<span class="line"><span>custinfo(&quot;pthread_id: %08x\\n&quot;, thread_id);</span></span></code></pre></div></li></ul></li><li><p>stack frame printf</p></li><li><p>thread printf</p></li></ul></li><li><p><a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noreferrer">GDB --- the GNU Debugger</a></p><p>GDB is a great tool. In this guide we&#39;ve already used it to load our program and run it. But it can do a lot more. You can single-step through code, examine variables and memory, set breakpoints, and more. I generally use it from the commandline, but have also used it from an IDE like JetBrains&#39; Clion, where it&#39;s easier to see the code context.</p><p>One add-on that I found to be essential is the ability to examine blocks of memory, like buffers that NuttX uses for reading and writing to storage media or network adapters. This <a href="https://stackoverflow.com/a/54784260/431222" target="_blank" rel="noreferrer">Stack Overflow question on using GDB to examine memory</a> includes a GDB command that is very handy. Add this to your <code>.gdbinit</code> file, and then use the <code>xxd</code> command to dump memory in an easy-to-read format:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>define xxd</span></span>
<span class="line"><span>  if argc &lt; 2</span></span>
<span class="line"><span>    set size = sizeof(*arg0)</span></span>
<span class="line"><span>  else</span></span>
<span class="line"><span>    set size = arg1</span></span>
<span class="line"><span>  end</span></span>
<span class="line"><span>  dump binary memory dump.bin arg0 ((void *)arg0)+size</span></span>
<span class="line"><span>  eval &quot;shell xxd -o %d dump.bin; rm dump.bin&quot;, ((void *)arg0)</span></span>
<span class="line"><span>end</span></span>
<span class="line"><span>document xxd</span></span>
<span class="line"><span>  Dump memory with xxd command (keep the address as offset)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  xxd addr [size]</span></span>
<span class="line"><span>    addr -- expression resolvable as an address</span></span>
<span class="line"><span>    size -- size (in byte) of memory to dump</span></span>
<span class="line"><span>            sizeof(*addr) is used by default end</span></span></code></pre></div><p>Here&#39;s a short GDB session that shows what this looks like in practice. Note that the memory location being examined (<code>0x200aa9eo</code> here) is a buffer being passed to <code>mmcsd_readsingle</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Program received signal SIGTRAP, Trace/breakpoint trap.</span></span>
<span class="line"><span>0x200166e8 in up_idle () at common/arm_idle.c:78</span></span>
<span class="line"><span>78  }</span></span>
<span class="line"><span>(gdb) b mmcsd_readsingle</span></span>
<span class="line"><span>Breakpoint 1 at 0x2006ea70: file mmcsd/mmcsd_sdio.c, line 1371.</span></span>
<span class="line"><span>(gdb) c</span></span>
<span class="line"><span>Continuing.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Breakpoint 1, mmcsd_readsingle (priv=0x200aa8c0, buffer=0x200aa9e0 &quot;WRTEST  TXT \\030&quot;, startblock=2432) at mmcsd/mmcsd_sdio.c:1371</span></span>
<span class="line"><span>1371      finfo(&quot;startblock=%d\\n&quot;, startblock);</span></span>
<span class="line"><span>(gdb) xxd 0x200aa9e0 200</span></span>
<span class="line"><span>200aa9e0: 5752 5445 5354 2020 5458 5420 1800 0000  WRTEST  TXT ....</span></span>
<span class="line"><span>200aa9f0: 0000 0000 0000 0000 0000 5500 1100 0000  ..........U.....</span></span>
<span class="line"><span>200aaa00: 5752 5445 5354 3520 5458 5420 1800 0000  WRTEST5 TXT ....</span></span>
<span class="line"><span>200aaa10: 0000 0000 0000 0000 0000 5800 1500 0000  ..........X.....</span></span>
<span class="line"><span>200aaa20: e552 5445 5854 3620 5458 5420 1800 0000  .RTEXT6 TXT ....</span></span>
<span class="line"><span>200aaa30: 0000 0000 0000 0000 0000 5600 1200 0000  ..........V.....</span></span>
<span class="line"><span>200aaa40: 5752 5445 5354 3620 5458 5420 1800 0000  WRTEST6 TXT ....</span></span>
<span class="line"><span>200aaa50: 0000 0000 0000 0000 0000 5600 1200 0000  ..........V.....</span></span>
<span class="line"><span>200aaa60: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span></span>
<span class="line"><span>200aaa70: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span></span>
<span class="line"><span>200aaa80: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span></span>
<span class="line"><span>200aaa90: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span></span>
<span class="line"><span>200aaaa0: 0000 0000 0000 0000                      ........</span></span></code></pre></div></li></ul></blockquote></li></ul><h2 id="nuttx-drivers-as-a-reference" tabindex="-1">NuttX Drivers as a Reference <a class="header-anchor" href="#nuttx-drivers-as-a-reference" aria-label="Permalink to &quot;NuttX Drivers as a Reference&quot;">​</a></h2><p>If you&#39;re not porting a NuttX driver from another architecture, it still helps to look at other similar NuttX drivers, if there are any. For instance, when implementing an Ethernet driver, look at other NuttX Ethernet drivers; for an SD Card driver, look at other NuttX SD Card drivers. Even if the chip-specific code won&#39;t be the same, the structure to interface with NuttX can be used.</p><h2 id="using-chip-datasheets" tabindex="-1">Using Chip Datasheets <a class="header-anchor" href="#using-chip-datasheets" aria-label="Permalink to &quot;Using Chip Datasheets&quot;">​</a></h2><p>To port or write a driver, you&#39;ll have to be familiar with the information in the chip datasheet. Definitely find the datasheet for your chip, and read the sections relevant to the peripheral you&#39;re working with. Doing so ahead of time will save a lot of time later.</p><p>Another thing that&#39;s often helpful is to refer to sample code provided by the manufacturer, or driver code from another operating system (like U-Boot, Zephyr, or FreeBSD) while referring to the datasheet --- seeing how working code implements the necessary algorithms often helps one understand how the driver needs to work.</p><ul><li><p>How to use a datasheet</p><p>Key pieces of information in System-on-a-Chip (SoC) datasheets are usually:</p><ul><li>Chip Architecture Diagram --- shows how the subsections of the chip (CPU, system bus, peripherals, I/O, etc.) connect to each other.</li><li>Memory Map --- showing the location of peripheral registers in memory. This info usually goes into a header file.</li><li>DMA Engine --- if Direct Memory Access (DMA) is used, this may have info on how to use it.</li><li>Peripheral --- the datasheet usually has a section on how the peripheral works. Key parts of this include: <ul><li>Registers List --- name and offset from the base memory address of the peripheral. This needs to go into a header file.</li><li>Register Map --- what is the size of each register, and what do the bits mean? You will need to create <code>#defines</code> in a header file that your code will use to operate on the registers. Refer to other driver header files for examples.</li></ul></li></ul></li></ul><h2 id="logic-analyzers" tabindex="-1">Logic Analyzers <a class="header-anchor" href="#logic-analyzers" aria-label="Permalink to &quot;Logic Analyzers&quot;">​</a></h2><p>For drivers that involve input and output (I/O), especially that involve complex protocols like SD Cards, SPI, I2C, etc., actually seeing the waveform that goes in and out the chip&#39;s pins is extremely helpful. <a href="https://en.wikipedia.org/wiki/Logic_analyzer" target="_blank" rel="noreferrer">Logic Analyzers</a> can capture that information and display it graphically, allowing you to see if the driver is doing the right thing on the wire.</p><h2 id="dma-debugging" tabindex="-1">DMA Debugging <a class="header-anchor" href="#dma-debugging" aria-label="Permalink to &quot;DMA Debugging&quot;">​</a></h2><ul><li>Dump registers before, during, and after transfer. Some NuttX drivers (<code>sam_sdmmc.c</code> or <code>imxrt_sdmmc.c</code> for example) have built-in code for debugging register states, and can sample registers before, during, and immediately after a DMA transfer, as well as code that can dump the peripheral registers in a nicely-formatted way onto the console device (which can be a serial console, a network console, or memory). Consider using something like this to see what&#39;s happening inside the chip if you&#39;re trying to debug DMA transfer code.</li><li>Compare register settings to expected settings determined from the datasheet or from dumping registers from working code in another operating system (U-Boot, Zephyr, FreeBSD, etc.).</li><li>Use the <code>xxd</code> GDB tool mentioned above to dump NuttX memory buffers before, during, and after a transfer to see if data is being transferred correctly, if there are over- or under-runs, or to diagnose data being stored in incorrect locations.</li><li>printf debugging register states can also help here.</li><li>Remember that logging can change the timing of any algorithms you might be using, so things may start or stop working when logging is added or removed. Definitely test with logging disabled.</li></ul>`,15)]))}const g=a(i,[["render",r]]);export{u as __pageData,g as default};
