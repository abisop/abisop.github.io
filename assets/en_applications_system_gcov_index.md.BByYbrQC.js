import{_ as o,c as a,al as t,o as n}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"gcov gcov tool","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/system/gcov/index.md","filePath":"en/applications/system/gcov/index.md"}'),l={name:"en/applications/system/gcov/index.md"};function s(p,e,i,c,r,d){return n(),a("div",null,e[0]||(e[0]=[t(`<h1 id="gcov-gcov-tool" tabindex="-1"><code>gcov</code> gcov tool <a class="header-anchor" href="#gcov-gcov-tool" aria-label="Permalink to &quot;\`gcov\` gcov tool&quot;">​</a></h1><p>gcov is a tool for testing code coverage. After the program is run, you can view the line coverage, function coverage, and branch coverage of each file.</p><h2 id="support" tabindex="-1">Support <a class="header-anchor" href="#support" aria-label="Permalink to &quot;Support&quot;">​</a></h2><p>The current system supports four code coverage detection implementations:</p><ol><li>GCC native implementation</li><li>CLANG native implementation</li><li>GCC coverage nuttx mini version</li><li>CLANG coverage nuttx mini version</li></ol><p>The following table shows the specific differences between the four implementations ends 24.11.26：</p><p>Support GCC-native CLANG-native GCC-nuttx-mini CLANG-nuttx-mini Compiler version: ALL ALL GCC 13.2 and below CLANG 17.0 and below</p><p>Program coverage statistics support:</p><p>Main Program √ √ √ √ Interrupt Program × √ √ √</p><p>Architecture Support:</p><blockquote><p>arm √ √ √ √ arm64 √ √ √ riscv √ √ X86_X64 √ √ xtensa √ √ sim √ √</p></blockquote><h3 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to &quot;Usage&quot;">​</a></h3><h2 id="app-usage" tabindex="-1">App-Usage <a class="header-anchor" href="#app-usage" aria-label="Permalink to &quot;App-Usage&quot;">​</a></h2><p>Usage:</p><pre><code>gcov [-d path] [-t strip] [-r] [-h]
</code></pre><p>Where:</p><blockquote><p>-d dump the coverage, path is the path to the coverage file, the default output is to stdout -t strip the path prefix number -r reset the coverage -h show this text and exits.</p></blockquote><h2 id="examples-of-applicable-platforms" tabindex="-1">Examples of applicable platforms <a class="header-anchor" href="#examples-of-applicable-platforms" aria-label="Permalink to &quot;Examples of applicable platforms&quot;">​</a></h2><ol><li>SIM platform usage</li></ol><blockquote><ol><li>Please enable the following config</li></ol><blockquote><p># Support instrumentation of all codes in sim 1. CONFIG_COVERAGE_TOOLCHAIN=y</p><p># Enable instrumentation 2. CONFIG_COVERAGE_ALL=y</p><p># Enable gcov app 3. CONFIG_SYSTEM_GCOV=y</p></blockquote><ol start="2"><li>Compile and run <code>\` After the code is compiled, a *.gcno file with the same name will be generated next to the *.o file. After the compilation is completed, run the code to be tested, and exit the sim after the execution is completed</code>\`</li><li>Run the gcov app <code>\` gcov -d path_to_gcno_file</code>\`</li><li>Check whether the generation is successful <code>\` Execute the following command in the project root directory to check whether there is a gcda file generated (code coverage data) find ./ -name &quot;*.gcno&quot; find ./ -name &quot;*.gcda&quot;</code>\`</li><li>Examples: <code>\` ./tools/configure.sh sim:nsh nsh: poweroff ./nuttx/tools/gcov.py -t gcov Then open ./gcov/result/index.html with your browser</code>\`</li></ol></blockquote><ol start="2"><li>Applicable to device</li><li>Applicable to device</li></ol><blockquote><p>Due to differences in implementation methods, the device side is divided into GCC and CLANG</p><ol><li>GCC</li></ol><blockquote><ol><li>Please enable the following config</li></ol><blockquote><p># Recommended to use nuttx mini version CONFIG_COVERAGE_MINI=y</p><p># Enable gcov app CONFIG_SYSTEM_GCOV=y</p><p># Please add different compilation options in makefile according to the compiler CFLAGS += -fprofile-arcs -ftest-coverage -fno-inline</p></blockquote><ol start="2"><li>Run the gcov app <code>\` gcov -d path_to_gcno_file</code>\`</li><li>Export data</li></ol><blockquote><p>After running the code on the device, execute the gcov -d /tmp/gcov command in the nuttx command line to save the generated data to the file system. You need to use your method to export the file to the host</p></blockquote><ol start="4"><li>Generate Report</li></ol><blockquote><ol><li>Install the tool</li></ol><blockquote><p>sudo apt install lcov</p></blockquote><ol start="2"><li>Generate report</li></ol><blockquote><p>Run the following command to generate coverage report</p><p># By default, it is generated in the root directory of the vela project. Add parameters to specify the report generation location # The -t parameter specifies the gcov version, which needs to match the gcc version</p><p># sim ./tools/gcov.py -t gcov</p><p># arm platform ./tools/gcov.py -t arm-none-eabi-gcov</p></blockquote></blockquote><ol start="5"><li>Impact and precautions <code>\` 1. Before using the .tools/gcov.sh tool, you need to ensure that *.gcno and *.gcda files exist 2. If *.gcno does not exist, recompile the code after distclean. 3. If *.gcda does not exist, please check and use poweroff to exit Vela normally</code>\`</li></ol></blockquote><ol start="2"><li>CLANG</li></ol><blockquote><p># There is a ready-made defconfig in NXboards/arm/mps/mps3-an547/configs/gcov # which can be used for reference</p><ol><li>Please enable the following config</li></ol><blockquote><p># Recommended to use nuttx mini version CONFIG_COVERAGE_MINI=y</p><p># Enable gcov app CONFIG_SYSTEM_GCOV=y</p><p># Please add different compilation options in makefile according to the compiler CFLAGS += -fprofile-instr-generate -fcoverage-mapping</p></blockquote><ol start="2"><li>Modify the linker script</li></ol><blockquote><p>Please find the corresponding storage location in the link script for the following data：</p><p>For detailed examples, please refer to boards/arm/mps/mps3-an547/scripts/flash.ld</p><div class="language-none vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">none</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>__llvm_prf_names : {</span></span>
<span class="line"><span>    __start__llvm_prf_names = .;</span></span>
<span class="line"><span>    KEEP (*(__llvm_prf_names))</span></span>
<span class="line"><span>    __end__llvm_prf_names = .;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>__llvm_prf_data : {</span></span>
<span class="line"><span>    __start__llvm_prf_data = .;</span></span>
<span class="line"><span>    KEEP (*(__llvm_prf_data))</span></span>
<span class="line"><span>    __end__llvm_prf_data = .;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>__llvm_prf_vnds : {</span></span>
<span class="line"><span>    __start__llvm_prf_vnds = .;</span></span>
<span class="line"><span>    KEEP (*(__llvm_prf_vnds))</span></span>
<span class="line"><span>    __end__llvm_prf_vnds = .;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>__llvm_prf_cnts : {</span></span>
<span class="line"><span>    __start__llvm_prf_cnts = .;</span></span>
<span class="line"><span>    KEEP (*(__llvm_prf_cnts))</span></span>
<span class="line"><span>    __end__llvm_prf_cnts = .;</span></span>
<span class="line"><span>}</span></span></code></pre></div></blockquote><ol start="3"><li>Run the gcov app</li></ol><blockquote><p><code>\` gcov -d path_to_gcno_file</code>\`</p></blockquote><ol start="4"><li>Export data</li><li>Generate Report</li></ol><blockquote><p>Please execute the following command, where</p><ol><li>xxxfile: the file for exporting data on the device</li><li>xxxelf: the ELF file corresponding to the device</li></ol><p># Convert the exported coverage data file llvm-profdata merge -sparse xxxfile -o result.profdata</p><p># Generate a visualization html file llvm-cov show -format=html xxxelf -instr-profile=result.profdata -output-dir=./coverage/html</p></blockquote></blockquote></blockquote>`,22)]))}const f=o(l,[["render",s]]);export{m as __pageData,f as default};
