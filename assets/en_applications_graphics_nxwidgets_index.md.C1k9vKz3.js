import{_ as i,c as n,j as e,a as t,al as s,o as a}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"nxwidgets NXWidgets","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/graphics/nxwidgets/index.md","filePath":"en/applications/graphics/nxwidgets/index.md"}'),l={name:"en/applications/graphics/nxwidgets/index.md"};function r(d,o,c,u,h,p){return a(),n("div",null,o[0]||(o[0]=[e("h1",{id:"nxwidgets-nxwidgets",tabindex:"-1"},[e("code",null,"nxwidgets"),t(" NXWidgets "),e("a",{class:"header-anchor",href:"#nxwidgets-nxwidgets","aria-label":'Permalink to "`nxwidgets` NXWidgets"'},"​")],-1),e("p",null,[t("In order to better support NuttX based platforms, a special graphical userinterface has been created called NXWidgets. NXWidgets is written in C++ and integrates seamlessly with the NuttX "),e("code",{class:"interpreted-text",role:"ref"},"NX graphics subsystem <nxgraphics>"),t(' in order to provide graphic objects, or "widgets," in the NX Graphics Subsystem')],-1),e("p",null,"Some of the features of NXWidgets include:",-1),e("ul",null,[e("li",null,[e("strong",null,"Conservative C++"),t('. NXWidgets is written entirely in C++ but using only selected "embedded friendly" C++ constructs that are fully supported under NuttX. No additional C++ support libraries are required.')]),e("li",null,[e("strong",null,"NX Integration"),t(". NXWidgets integrate seamlessly with the "),e("code",{class:"interpreted-text",role:"ref"},"NX graphics subsystem <nxgraphics>"),t(". Think of the X server under Linux ... the NX graphics system is like a tiny X server that provides windowing under NuttX. By adding NXWidgets, you can support graphics objects like buttons and text boxes in the NX windows and toolbars.")]),e("li",null,[e("strong",null,"Small Footprint"),t(". NXWidgets is tailored for use MCUs in embedded applications. It is ideally suited for mid- and upper-range of most MCU families. A complete NXWidgets is possible in as little as 40K of FLASH and maybe 4K of SRAM.")]),e("li",null,[e("strong",null,"Output Devices"),t(". NXWidgets will work on the high-end frame buffer devices as well as on LCDs connected via serial or parallel ports to a small MCU.")]),e("li",null,[e("strong",null,"Input Devices"),t(". NXWidgets will accept position and selection inputs from a mouse or a touchscreen. It will also support character input from a keyboard such as a USB keyboard. NXWidgets supports on very special widget called CKeypad that will provide keyboard input via an on-screen keypad that can be operated via mouse or touchscreen inputs.")]),e("li",null,[e("strong",null,"Many Graphic Objects"),t(". Some of the graphic objects supported by NXWidgets include labels, buttons, text boxes, button arrays, check boxes, cycle buttons, images, sliders, scrollable list boxes, progress bars, and more.")]),e("li",null,[e("strong",null,"DOxygen Documentation"),t(" DOxygen documentation is available.")])],-1),s(`<p>Note: Many of the fundamental classed in NxWidgets derive from the Antony Dzeryn&#39;s &quot;Woopsi&quot; project which also has a BSD style license. See the COPYING file for details.</p><h2 id="nxwidgets-doxygen-documentation" tabindex="-1">NXWidgets Doxygen Documentation <a class="header-anchor" href="#nxwidgets-doxygen-documentation" aria-label="Permalink to &quot;NXWidgets Doxygen Documentation&quot;">​</a></h2><p>NXWidgets supports building HTML documentation via Doxygen. We should integrate this into the Sphinx documentation build.</p><p>Thanks go to Jose Pablo Carballo for contributing this!</p><h3 id="directory-structure" tabindex="-1">Directory Structure <a class="header-anchor" href="#directory-structure" aria-label="Permalink to &quot;Directory Structure&quot;">​</a></h3><ul><li><p><code>Kconfig</code></p><p>This is a <code>Kconfig</code> file that should be provided at <code>apps/NxWidgets/Kconfig</code>. When copied to that location, it will be used by the NuttX configuration systems to configure settings for NxWidgets and NxWM</p></li><li><p><code>nxwidgets</code></p><p>The source code, header files, and build environment for NxWidgets is provided in this directory.</p></li><li><p><code>UnitTests</code></p><p>Provides a collection of unit-level tests for many of the individual widgets provided by <code>nxwidgets</code>.</p></li></ul><h3 id="doxygen" tabindex="-1">Doxygen <a class="header-anchor" href="#doxygen" aria-label="Permalink to &quot;Doxygen&quot;">​</a></h3><h4 id="installing-the-necessary-packages-in-ubuntu" tabindex="-1">Installing the necessary packages in Ubuntu <a class="header-anchor" href="#installing-the-necessary-packages-in-ubuntu" aria-label="Permalink to &quot;Installing the necessary packages in Ubuntu&quot;">​</a></h4><ol><li><p>Install the following packages:</p><pre><code> sudo aptitude install doxygen doxygen-doc doxygen-gui dot2tex graphviz
</code></pre></li><li><p>(Optional) Install Doxygen from the latest sourcode.</p><p>The Ubuntu package is outdated. The newer the version of Doxygen, the better the documentation looks.</p><p>Place yourself in some temporary folder where you can download the source, and run [1]:</p><pre><code> svn co https://doxygen.svn.sourceforge.net/svnroot/doxygen/trunk doxygen-svn
 cd doxygen-svn
 ./configure
 make
 make install
</code></pre></li></ol><h4 id="generating-documentation" tabindex="-1">Generating documentation <a class="header-anchor" href="#generating-documentation" aria-label="Permalink to &quot;Generating documentation&quot;">​</a></h4><p>Two ways described here:</p><ol><li><p>Use the provided <code>gendoc.sh</code> script:</p><pre><code>trunk/NXWidgets/Doxygen/gendoc.sh
</code></pre><p>The script only needs the argument to the absolute path where to place the generated documentation. I.e.:</p><pre><code> cd /path/to/nuttx/trunk/NXWidgets/Doxygen/
 mkdir doc
 ./gendoc.sh PWD/doc
</code></pre></li><li><p>Using the <code>Doxyfile</code> directly:</p><p>The file <code>Doxyfile</code> contains the configuration of the Doxygen settings for the run, edit only if necessary.</p><p>To generate the documentation type:</p><pre><code> cd /path/to/nuttx/trunk/NXWidgets/Doxygen/
 doxygen Doxyfile
</code></pre></li></ol><h4 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h4><p>[1] <a href="http://www.stack.nl/~dimitri/doxygen/download.html" target="_blank" rel="noreferrer">http://www.stack.nl/~dimitri/doxygen/download.html</a></p><h3 id="unit-tests" tabindex="-1">Unit Tests <a class="header-anchor" href="#unit-tests" aria-label="Permalink to &quot;Unit Tests&quot;">​</a></h3><h4 id="installing-and-building-the-unit-tests" tabindex="-1">Installing and Building the Unit Tests <a class="header-anchor" href="#installing-and-building-the-unit-tests" aria-label="Permalink to &quot;Installing and Building the Unit Tests&quot;">​</a></h4><ol><li><p>Setup NuttX</p><ol><li><p>Configure NuttX</p><p>Configure NuttX to run one of the target configurations. For example, let&#39;s assume that you are using the <code>sim/nsh2</code> configuration. The <code>sim/nsh2</code> configuration was specially created for use NXWidgets on the simulation platform. A similar, special configuration <code>stm3210e-eval/nsh2</code> is also for the <code>STM3210E-EVAL</code> available. However, the unit test can be run on other configurations (see steps d and e below).</p><p><strong>Note</strong>: There are some other special configurationsrecommended for unit-leveling testing of NxWM because the configuration is more complex in that case. These are:</p><ol><li><p><code>sim/nxwmm</code>, or the simulated platform (no touchscreen), and</p></li><li></li></ol><pre><code>\`stm3240g-evel\`, for the \`STM3240G-EVAL\` board (with the STMPE11

:   touchscreen)
</code></pre><p>We will assume the <code>sim/nsh2</code> configuration in this discussion. The <code>sim/nsh2</code> configuration is installed as follows:</p><pre><code>cd &lt;nuttx-directory-path&gt;
make distclean
tools/configure.sh sim:nsh2
</code></pre><p>Where:</p><p><code>&lt;nuttx-directory-path&gt;</code> is the full, absolute path to the NuttX build directory</p><p>If you are using the <code>sim/nsh2</code> or <code>stm3210e-eval</code> configurations, then skip to step 2 (Hmmm.. better check 1d) too).</p><p>There may be certain requirements for the configuration that you select... for example, certain widget tests may require touchscreen support or special font selections. These test-specific requirements are addressed below under &quot;Unit Test Directories&quot;</p></li><li><p>Enable C++ Support</p><p>If you are not using the <code>sim/nsh2</code> or <code>stm3210e-eval</code>, you will need to add the following definitions to the NuttX configuration at <code>nuttx/.config</code> to enable C++ support:</p><pre><code>CONFIG_HAVE_CXX=y
</code></pre><p>Check first, some configurations already have C++ support enabled (As of this writing <strong>ONLY</strong> the <code>sim/nsh2</code> and <code>stm321-e-eval</code> configurations have C++ support pre-enabled).</p></li><li><p>Enable Debug Options</p><p>If you are running on a simulated target, then you might also want to enable debug symbols:</p><pre><code>CONFIG_DEBUG_SYMBOLS=y
</code></pre><p>Then you can run the simulation using GDB or DDD which is a very powerful debugging environment!</p></li><li><p>Special configuration requirements for the nxwm unit test:</p><pre><code>CONFIG_NXTERM=y
</code></pre></li><li><p>Other <code>.config</code> file changes -- NSH configurations only.</p><p>If the configuration that you are using supports NSH and NSH built-in tasks then all is well. If it is an NSH configuration, then you will have to define the following in your <code>nuttx/.config</code> file as well (if it is not already defined):</p><pre><code>CONFIG_NSH_BUILTIN_APPS=y
</code></pre><p><code>sim/nsh2</code> and <code>stm3210e-eval/nsh2</code> already has this setting. You do not need to change anything further in the <code>nuttx/.config</code> file if you are using either of these configurations.</p></li><li><p>Other <code>.config</code> file changes -- NON-NSH configurations only.</p><p>Entry Point. You will need to set the entry point in the .config file. For NSH configurations, the entry point will always be <code>nsh_main</code> and you will see that setting like:</p><pre><code>CONFIG_INIT_ENTRYPOINT=&quot;nsh_main&quot;
</code></pre><p>If you are not using in NSH, then each unit test has a unique entry point. That entry point is the name of the unit test directory in all lower case plus the suffix <code>_main</code>. So, for example, the correct entry for the <code>UnitTests/CButton</code> would be:</p><pre><code>CONFIG_INIT_ENTRYPOINT=&quot;cbutton_main&quot;
</code></pre><p>And the correct entry point for <code>UnitTests/nxwm</code> would be:</p><pre><code>CONFIG_INIT_ENTRYPOINT=&quot;nxwm_main&quot;
</code></pre><p>etc.</p><p>For non-NSH configurations (such as the <code>sim/touchscreen</code>) you will have to remove the configuration setting that provided the <code>main</code> function so that you use the <code>main</code> in the unit test code instead. So, for example, with the <code>sim/touchscreen</code> configuration you need to remove the following from the NuttX configuration file (<code>.config</code>):</p><pre><code>CONFIG_EXAMPLES_TOUSCHCREEN=y  ## REMOVE (provided &quot;tc_main&quot;)
</code></pre></li></ol></li><li><p>Adjust the Stack Size</p><p>If using an simulation configuration (like <code>sim/nsh2</code>) and your unit test uses X11 as its display device, then you would have to increase the size of unit test stack as described below under &quot;Stack Size Issues with the X11 Simulation&quot;.</p></li><li><p>Build NuttX including the unit test and the NXWidgets library:</p><pre><code>cd &lt;nuttx-directory-path&gt;
. ./setenv.sh
make
</code></pre></li></ol><h4 id="work-arounds" tabindex="-1">Work-Arounds <a class="header-anchor" href="#work-arounds" aria-label="Permalink to &quot;Work-Arounds&quot;">​</a></h4><h5 id="build-issues" tabindex="-1">Build Issues <a class="header-anchor" href="#build-issues" aria-label="Permalink to &quot;Build Issues&quot;">​</a></h5><ol><li><p>I have seen this error on Cygwin building C++ code:</p><pre><code>LD:  nuttx.rel
ld: skipping incompatible /home/patacongo/projects/nuttx/nuttx/trunk/nuttx/libxx//liblibxx.a when searching for -llibxx
ld: cannot find -llibxx
</code></pre><p>The problem seems to be caused because <code>gcc</code> build code for 32-bit mode and <code>g++</code> builds code for 64-bit mode. Add the <code>-m32</code> option to the <code>g++</code> command line seems to fix the problem. In <code>Make.defs</code>:</p><pre><code>CXXFLAGS = -m32 (ARCHWARNINGSXX) (ARCHOPTIMIZATION) \\
           (ARCHCXXFLAGS) (ARCHINCLUDESXX) (ARCHDEFINES) (EXTRADEFINES) -pipe
</code></pre></li><li><p>Stack Size Issues with the X11 Simulation</p><p>When you run the NuttX simulation, it uses stacks allocated by NuttX from the NuttX heap. The memory management model is exactly the same in the simulation as it is real, target system. This is good because this produces a higher fidelity simulation.</p><p>However, when the simulation calls into Linux/Cygwin libraries, it will still use these small simulation stacks. This happens, for example, when you call into the system to get and put characters to the console window or when you make x11 calls into the system. The programming model within those libraries will assume a Linux/Cygwin environment where the stack size grows dynamically</p><p>As a consequence, those system libraries may allocate large data structures on the stack and overflow the small NuttX stacks. X11, in particular, requires large stacks. If you are using X11 in the simulation, make sure that you set aside a &quot;lot&quot; of stack for the X11 system calls (maybe 8 or 16Kb). The stack size for the thread that begins with user start is controlled by the configuration setting <code>CONFIG_INIT_STACKSIZE</code>; you may need to increase this value to larger number to survive the X11 system calls.</p><p>If you are running X11 applications as NSH add-on programs, then the stack size of the add-on program is controlled in another way. Here are the steps for increasing the stack size in that case:</p><pre><code>cd ../apps/namedapps  # Go to the namedapps directory
vi namedapps_list.h   # Edit this file and increase the stack size of the add-on
rm .built *.o         # This will force the namedapps logic to rebuild
</code></pre></li></ol><h4 id="unit-tests-directories" tabindex="-1">Unit Tests Directories <a class="header-anchor" href="#unit-tests-directories" aria-label="Permalink to &quot;Unit Tests Directories&quot;">​</a></h4><p>The following provide simple unit tests for each of the NXWidgets. In addition, these unit tests provide examples for the use of each widget type.</p><ul><li><code>CButton</code><ul><li>Exercises the <code>CButton</code> widget.</li><li>Depends on <code>CLabel</code>.</li></ul></li><li><code>CButtonArray</code><ul><li>Exercises the <code>CButtonArray</code> widget.</li></ul></li><li><code>CCheckBox</code><ul><li>Exercises the <code>CCheckBox</code> widget.</li><li>Depends on <code>CLabel</code> and <code>CButton</code>.</li></ul></li><li><code>CGlyphButton</code><ul><li>Exercises the <code>CGlyphButton</code> widget.</li><li>Depends on <code>CLabel</code> and <code>CButton</code>.</li></ul></li><li><code>CImage</code><ul><li>Exercises the <code>CImage</code> widget.</li></ul></li><li><code>CLabel</code><ul><li>Exercises the <code>CLabel</code> widget.</li></ul></li><li><code>CProgressBar</code><ul><li>Exercises the <code>CProgressBar</code> widget.</li></ul></li><li><code>CRadioButton</code><ul><li>Exercises the <code>CRadioButton</code> and <code>CRadioButtonGroup</code> widgets.</li><li>Depends on <code>CLabel</code> and <code>CButton</code>.</li></ul></li><li><code>CScrollBarHorizontal</code><ul><li>Exercises the <code>ScrollbarHorizontal</code>.</li><li>Depends on <code>CSliderHorizontal</code> and <code>CGlyphButton</code>.</li></ul></li><li><code>CScrollBarVertical</code><ul><li>Exercises the <code>ScrollbarHorizontal</code>.</li><li>Depends on <code>CSliderVertical</code> and <code>CGlyphButton</code>.</li></ul></li><li><code>CSliderHorizontal</code><ul><li>Exercises the <code>CSliderHorizontal</code>.</li><li>Depends on <code>CSliderHorizontalGrip</code>.</li></ul></li><li><code>CSliderVertical</code><ul><li>Exercises the <code>CSliderVertical</code>.</li><li>Depends on <code>CSliderVerticalGrip</code>.</li></ul></li><li><code>CTextBox</code><ul><li>Exercises the <code>CTextBox</code> widget.</li><li>Depends on <code>CLabel</code>.</li></ul></li></ul>`,23)]))}const f=i(l,[["render",r]]);export{m as __pageData,f as default};
