import{_ as t,c as i,al as o,o as n}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"NSH \\"Built-In\\" Applications","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/nsh/builtin.md","filePath":"en/applications/nsh/builtin.md"}'),a={name:"en/applications/nsh/builtin.md"};function l(s,e,c,p,d,u){return n(),i("div",null,e[0]||(e[0]=[o(`<h1 id="nsh-built-in-applications" tabindex="-1">NSH &quot;Built-In&quot; Applications <a class="header-anchor" href="#nsh-built-in-applications" aria-label="Permalink to &quot;NSH \\&quot;Built-In\\&quot; Applications&quot;">​</a></h1><p><strong>Overview.</strong> In addition to these commands that are a part of NSH, external programs can also be executed as NSH commands. These external programs are called &quot;Built-In&quot; Applications for historic reasons. That terminology is somewhat confusing because the actual NSH commands as described above are truly &quot;built-into&quot; NSH whereas these applications are really external to NuttX.</p><p>These applications are built-into NSH in the sense that they can be executed by simply typing the name of the application at the NSH prompt. Built-in application support is enabled with these configuration option:</p><blockquote><ul><li><code>CONFIG_BUILTIN</code>: Enable NuttX support for builtin applications.</li><li><code>CONFIG_NSH_BUILTIN_APPS</code>: Enable NSH support for builtin applications.</li></ul></blockquote><p>When these configuration options are set, you will also be able to see the built-in applications if you enter &quot;nsh&gt; help&quot;. They will appear at the bottom of the list of NSH commands under:</p><pre><code>Builtin Apps:
</code></pre><p>Note that no detailed help information beyond the name of the built-in application is provided.</p><h2 id="built-in-applications" tabindex="-1">Built-In Applications <a class="header-anchor" href="#built-in-applications" aria-label="Permalink to &quot;Built-In Applications&quot;">​</a></h2><p><strong>Overview.</strong> The underlying logic that supports the NSH built-in applications is called &quot;Built-In Applications&quot;. The builtin application logic can be found at <code>apps/builtin</code>. This logic simply does the following:</p><blockquote><ol><li>It supports registration mechanism so that builtin applications can dynamically register themselves at build time, and</li><li>Utility functions to look up, list, and execute the builtin applications.</li></ol></blockquote><p><strong>Built-In Application Utility Functions</strong>. The utility functions exported by the builtin application logic are prototyped in <code>nuttx/include/nuttx/lib/builtin.h</code> and <code>apps/include/builtin.h</code>. These utility functions include:</p><blockquote><ul><li><code>int builtin_isavail(FAR const char *appname);</code> Checks for availability of application registered as <code>appname</code> during build time.</li><li><code>const char *builtin_getname(int index);</code> Returns a pointer to a name of built-in application pointed by the <code>index</code>. This is the utility function that is used by NSH in order to list the available built-in applications when &quot;<code>nsh&gt; help</code>&quot; is entered.</li><li><code>int exec_builtin(FAR const char *appname, FAR const char **argv);</code> Executes built-in builtin application registered during compile time. This is the utility function used by NSH to execute the built-in application.</li></ul></blockquote><p><strong>Autogenerated Header Files</strong>. Application entry points with their requirements are gathered together in two files when NuttX is first built:</p><blockquote><ol><li><code>apps/builtin/builtin_proto.h</code>: Prototypes of application task entry points.</li><li><code>apps/builtin/builtin_list.h</code>: Application specific information and start-up requirements</li></ol></blockquote><p><strong>Registration of Built-In Applications</strong>. The NuttX build occurs in several phases as different build targets are executed: (1) <em>context</em> when the configuration is established, (2) <em>depend</em> when target dependencies are generated, and (3) <em>default</em> (<code>all</code>) when the normal compilation and link operations are performed. Built-in application information is collected during the make <em>context</em> build phase.</p><p>An example application that can be &quot;built-in&quot; is be found in the <code>apps/examples/hello directory</code>. Let&#39;s walk through this specific cause to illustrate the general way that built-in applications are created and how they register themselves so that they can be used from NSH.</p><p><code>apps/examples/hello</code>. The main routine for apps/examples/hello can be found in <code>apps/examples/hello/main.c</code>. The main routine is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int hello_main(int argc, char *argv[])</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  printf(&quot;Hello, World!!\\n&quot;);</span></span>
<span class="line"><span>  return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>This is the built in function that will be registered during the <em>context</em> build phase of the NuttX build. That registration is performed by logic in <code>apps/examples/hello/Makefile</code>. But the build system gets to that logic through a rather tortuous path:</p><blockquote><ol><li>The top-level context make target is in <code>nuttx/Makefile</code>. All build targets depend upon the <em>context</em> build target. For the <code>apps/</code> directory, this build target will execute the <em>context</em> target in the <code>apps/Makefile</code>.</li><li>The <code>apps/Makefile</code> will, in turn, execute the <em>context</em> targets in all of the configured sub-directories. In our case will include the <code>Makefile</code> in <code>apps/examples</code>.</li><li>And finally, the <code>apps/examples/Makefile</code> will execute the <em>context</em> target in all configured <code>example</code>sub-directories, getting us finally to <code>apps/examples/Makefile</code> which is covered below.</li></ol></blockquote><p><strong>NOTE</strong>: Since this context build phase can only be executed one time, any subsequent configuration changes that you make will, then, not be reflected in the build sequence. That is a common area of confusion. Before you can instantiate the new configuration, you have to first get rid of the old configuration. The most drastic way to this is:</p><pre><code>make distclean
</code></pre><p>But then you will have to re-configuration NuttX from scratch. But if you only want to re-build the configuration in the <code>apps/</code> sub-directory, then there is a less labor-intensive way to do that. The following NuttX make command will remove the configuration only from the <code>apps/</code> directory and will let you continue without re-configuring everything:</p><pre><code>make apps_distclean
</code></pre><p>Logic for the <code>context</code> target in <code>apps/examples/hello/Makefile</code> registers the <code>hello_main()</code> application in the <code>builtin</code>&#39;s <code>builtin_proto.h</code>and <code>builtin_list.h</code> files. That logic that does that in <code>apps/examples/hello/Makefile</code> is abstracted below:</p><blockquote><ol><li><p>First, the <code>Makefile</code> includes <code>apps/Make.defs</code>:</p><pre><code>include (APPDIR)/Make.defs
</code></pre><p>This defines a macro called <code>REGISTER</code> that adds data to the <em>builtin</em> header files:</p><pre><code>define REGISTER
    @echo &quot;Register: 1&quot;
    @echo &quot;{ \\&quot;1\\&quot;, 2, 3, 4 },&quot; &gt;&gt; &quot;(APPDIR)/builtin/builtin_list.h&quot;
    @echo &quot;EXTERN int 4(int argc, char *argv[]);&quot; &gt;&gt; &quot;(APPDIR)/builtin/builtin_proto.h&quot;
endef
</code></pre><p>When this macro runs, you will see the output in the build &quot;<code>Register: hello</code>&quot;, that is a sure sign that the registration was successful.</p></li><li><p>The make file then defines the application name (<code>hello</code>), the task priority (default), and the stack size that will be allocated in the task runs (2K):</p><pre><code>APPNAME         = hello
PRIORITY        = SCHED_PRIORITY_DEFAULT
STACKSIZE       = 2048
</code></pre></li><li><p>And finally, the <code>Makefile</code> invokes the <code>REGISTER</code> macro to added the <code>hello_main()</code> builtin application. Then, when the system build completes, the <code>hello</code> command can be executed from the NSH command line. When the <code>hello</code> command is executed, it will start the task with entry point <code>hello_main()</code> with the default priority and with a stack size of 2K:</p><pre><code>context:
  (call REGISTER,(APPNAME),(PRIORITY),(STACKSIZE),(APPNAME)_main)
</code></pre></li></ol></blockquote><p><strong>Other Uses of Built-In Application.</strong> The primary purpose of builtin applications is to support command line execution of applications from NSH. However, there is one other use of builtin applications that should be mentioned.</p><blockquote><ol><li><strong>binfs</strong>. <em>binfs</em> is a tiny file system located at <code>apps/builtin/binfs.c</code>. This provides an alternative what of visualizing installed builtin applications. Without <em>binfs</em>, you can see the installed builtin applications using the NSH help command. <em>binfs</em> will create a tiny pseudo-file system mounted at <code>/bin</code>. Using <em>binfs</em>, you can see the available builtin applications by listing the contents of <code>/bin</code> directory. This gives some superficial Unix-like compatibility, but does not really add any new functionality.</li></ol></blockquote><h2 id="synchronous-built-in-applications" tabindex="-1">Synchronous Built-In Applications <a class="header-anchor" href="#synchronous-built-in-applications" aria-label="Permalink to &quot;Synchronous Built-In Applications&quot;">​</a></h2><p>By default, built-in commands started from the NSH command line will run asynchronously with NSH. If you want to force NSH to execute commands then wait for the command to execute, you can enable that feature by adding the following to the NuttX configuration file:</p><pre><code>CONFIG_SCHED_WAITPID=y
</code></pre><p>This configuration option enables support for the standard <code>waitpid()</code> RTOS interface. When that interface is enabled, NSH will use it to wait, sleeping until the built-in application executes to completion.</p><p>Of course, even with <code>CONFIG_SCHED_WAITPID=y</code> defined, specific applications can still be forced to run asynchronously by adding the ampersand (&amp;) after the NSH command.</p>`,33)]))}const m=t(a,[["render",l]]);export{h as __pageData,m as default};
