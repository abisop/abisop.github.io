import{_ as t,c as a,al as s,o}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"NuttX Protected Build","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/protected_build.md","filePath":"en/guides/protected_build.md"}'),i={name:"en/guides/protected_build.md"};function n(l,e,r,c,d,h){return o(),a("div",null,e[0]||(e[0]=[s(`<h1 id="nuttx-protected-build" tabindex="-1">NuttX Protected Build <a class="header-anchor" href="#nuttx-protected-build" aria-label="Permalink to &quot;NuttX Protected Build&quot;">​</a></h1><p>Warning</p><p>Migrated from : <a href="https://cwiki.apache.org/confluence/display/NUTTX/NuttX+Protected+Build" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/NuttX+Protected+Build</a></p><h2 id="the-traditional-flat-build" tabindex="-1">The Traditional &quot;Flat&quot; Build <a class="header-anchor" href="#the-traditional-flat-build" aria-label="Permalink to &quot;The Traditional \\&quot;Flat\\&quot; Build&quot;">​</a></h2><p>The traditional NuttX build is a &quot;flat&quot; build. By flat, I mean that when you build NuttX, you end up with a single &quot;blob&quot; called <code>nuttx</code>. All of the components of the build reside in the same address space. All components of the build can access all other components of the build.</p><h2 id="the-two-pass-protected-build" tabindex="-1">The &quot;Two Pass&quot; Protected Build <a class="header-anchor" href="#the-two-pass-protected-build" aria-label="Permalink to &quot;The \\&quot;Two Pass\\&quot; Protected Build&quot;">​</a></h2><p>The NuttX protected build, on the other hand, is a &quot;two-pass&quot; build and generates two &quot;blobs&quot;: (1) a separately compiled and linked [kernel]{.title-ref} blob called, again, [nuttx]{.title-ref} and separately compiled and linked [user]{.title-ref} blob called in <code>nuttx_user.elf</code> (in the existing build configurations). The user blob is created on pass 1 and the kernel blob is created on pass2.</p><p>These two make commands are identical:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>make</span></span>
<span class="line"><span>make pass1 pass2</span></span></code></pre></div><p>But the second is clearer and I prefer to use it for the protected build. In the second case, the user and kernel blobs are built separately; in the first, the kernel and user blob builds may be intermixed and somewhat confusing. You can also build the kernel and user blobs separately with one of the following commands:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>make pass1</span></span>
<span class="line"><span>make pass2</span></span></code></pre></div><p>At the end of the build, there will be several files in the top-level NuttX build directory. From Pass 1:</p><ul><li><code>nuttx_user.elf</code>. The pass1 user-space ELF file</li><li><code>nuttx_user.hex</code>. The pass1 Intel HEX format file (selected in <code>defconfig</code>)</li><li><code>User.map</code>. Symbols in the user-space ELF file</li></ul><p>From Pass 2:</p><ul><li><code>nuttx</code>. The pass2 kernel-space ELF file</li><li><code>nuttx.hex</code>. The pass2 Intel HEX file (selected in <code>defconfig</code>)</li><li><code>System.map</code>. Symbols in the kernel-space ELF file</li></ul><h2 id="the-memory-protection-unit" tabindex="-1">The Memory Protection Unit <a class="header-anchor" href="#the-memory-protection-unit" aria-label="Permalink to &quot;The Memory Protection Unit&quot;">​</a></h2><p>If the MCU supports a Memory Protection Unit (MPU), then the logic within the kernel blob all execute in kernel-mode, i.e., with all privileges. These privileged threads can access all memory, all CPU instructions, and all MCU registers. The logic executing within the user-mode blob, on the other hand, all execute in user-mode with certain restrictions as enforced by the MCU and by the MPU. The MCU may restrict access to certain registers and machine instructions; with the MPU, access to all kernel memory resources are prohibited from the user logic. This includes the kernel blob&#39;s FLASH, .bss/.data storage, and the kernel heap memory.</p><h2 id="advantages-of-the-protected-build" tabindex="-1">Advantages of the Protected Build <a class="header-anchor" href="#advantages-of-the-protected-build" aria-label="Permalink to &quot;Advantages of the Protected Build&quot;">​</a></h2><p>The advantages of such a protected build are (1) security and (2) modularity. Since the kernel resources are protected, it will be much less likely that a misbehaving task will crash the system or that a wild pointer access will corrupt critical memory. This security also provides a safer environment in which to execute 3rd party software and prevents &quot;snooping&quot; into the kernel memory from the hosted applications.</p><p>Modularity is assured because there is a strict control of the exposed kernel interfaces. In the flat build, all symbols are exposed and there is no enforcement of a kernel API. With the protected build, on the other hand, all interactions with the kernel from the user application logic must use [system calls]{.title-ref} (or [syscalls]{.title-ref}) to interface with the OS. A system call is necessary to transition from user-mode to kernel-mode; all user-space operating system interfaces are via syscall [proxies]{.title-ref}. Then, while in kernel mode, the kernel system call handler will perform the OS service requested by the application. At the conclusion of system processing, user-privileges are restored and control is return to the user application. Since the only interactions with the kernel can be through support system calls, modularity of the OS is guaranteed.</p><h2 id="user-space-proxies-kernel-space-stubs" tabindex="-1">User-Space Proxies/Kernel-Space Stubs <a class="header-anchor" href="#user-space-proxies-kernel-space-stubs" aria-label="Permalink to &quot;User-Space Proxies/Kernel-Space Stubs&quot;">​</a></h2><p>The same OS interfaces are exposed to the application in both the &quot;flat&quot; build and the protected build. The difference is that in the protected build, the user-code interfaces with a [proxy]{.title-ref} for the OS function. For example, here is what a proxy for the OS <code>getpid()</code> interface:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;unistd.h&gt;</span></span>
<span class="line"><span>#include &lt;syscall.h&gt;</span></span>
<span class="line"><span>pid_t getpid(void)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    return (pid_t)sys_call0(SYS_getpid);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Thus the <code>getpid()</code> proxy is a stand-in for the real OS <code>getpid()</code> interface that executes a system call so the kernel code can perform the real <code>getpid()</code> operation on behalf of the user application. Proxies are auto-generated for all exported OS interfaces using the CSV file <code>syscall/syscall.csv</code> and the program <code>tools/mksyscalls</code>. Similarly, on the kernel-side, there are auto-generated [stubs]{.title-ref} that map the system calls back into real OS calls. These, however, are internal to the OS and the implementation may be architecture-specific. See the <code>README.txt</code> files in those directories for further information.</p><h2 id="combining-intel-hex-files" tabindex="-1">Combining Intel HEX Files <a class="header-anchor" href="#combining-intel-hex-files" aria-label="Permalink to &quot;Combining Intel HEX Files&quot;">​</a></h2><p>One issue that you may face is that the two pass builds creates two FLASH images. Some debuggers that I use will allow me to write each image to FLASH separately. Others will expect to have a single Intel HEX image. In this latter case, you may need to combine the two Intel HEX files into one. Here is how you can do that:</p><ol><li>The [tail]{.title-ref} of the <code>nuttx.hex</code> file should look something like this (with my comments and spaces added):</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> tail nuttx.hex</span></span>
<span class="line"><span># 00, data records</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>:10 9DC0 00 01000000000800006400020100001F0004</span></span>
<span class="line"><span>:10 9DD0 00 3B005A0078009700B500D400F300110151</span></span>
<span class="line"><span>:08 9DE0 00 30014E016D0100008D</span></span>
<span class="line"><span># 05, Start Linear Address Record</span></span>
<span class="line"><span>:04 0000 05 0800 0419 D2</span></span>
<span class="line"><span># 01, End Of File record</span></span>
<span class="line"><span>:00 0000 01 FF</span></span></code></pre></div><p>Use an editor such as vi to remove the 05 and 01 records.</p><ol start="2"><li>The [head]{.title-ref} of the <code>nuttx_user.hex</code> file should look something like this (again with my comments and spaces added):</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> head nuttx_user.hex</span></span>
<span class="line"><span># 04, Extended Linear Address Record</span></span>
<span class="line"><span>:02 0000 04 0801 F1</span></span>
<span class="line"><span># 00, data records</span></span>
<span class="line"><span>:10 8000 00 BD89 01084C800108C8110208D01102087E</span></span>
<span class="line"><span>:10 8010 00 0010 00201C1000201C1000203C16002026</span></span>
<span class="line"><span>:10 8020 00 4D80 01085D80010869800108ED83010829</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>Nothing needs to be done here. The <code>nuttx_user.hex</code> file should be fine.</p><ol start="3"><li>Combine the edited nuttx.hex and un-edited <code>nuttx_user.hex</code> file to produce a single combined hex file:</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> cat nuttx.hex nuttx_user.hex &gt;combined.hex</span></span></code></pre></div><p>Then use the <code>combined.hex</code> file with for FLASH/JTAG tool. If you do this a lot, you will probably want to invest a little time to develop a tool to automate these steps.</p><h2 id="files-and-directories" tabindex="-1">Files and Directories <a class="header-anchor" href="#files-and-directories" aria-label="Permalink to &quot;Files and Directories&quot;">​</a></h2><p>Here is a summary of directories and files used by the STM32F4Discovery protected build:</p><ul><li><code>boards/arm/stm32/stm32f4discovery/configs/kostest</code>. This is the kernel mode OS test configuration. The two standard configuration files can be found in this directory: (1) <code>defconfig</code> and (2) <code>Make.defs</code>.</li><li><code>boards/arm/stm32/stm32f4discovery/kernel</code>. This is the first past build directory. The Makefile in this directory is invoked to produce the pass1 object (<code>nuttx_user.elf</code> in this case). The second pass object is created by <code>arch/arm/src/Makefile</code>. Also in this directory is the file <code>userspace.c</code>. The user-mode blob contains a header that includes information need by the kernel blob in order to interface with the user-code. That header is defined in by this file.</li><li><code>boards/arm/stm32/stm32f4discovery/scripts</code>. Linker scripts for the kernel mode build are found in this directory. This includes (1) <code>memory.ld</code> which hold the common memory map, (2) <code>user-space.ld</code> that is used for linking the pass1 user-mode blob, and (3) <code>kernel-space.ld</code> that is used for linking the pass1 kernel-mode blob.</li></ul><h2 id="alignment-regions-and-subregions" tabindex="-1">Alignment, Regions, and Subregions <a class="header-anchor" href="#alignment-regions-and-subregions" aria-label="Permalink to &quot;Alignment, Regions, and Subregions&quot;">​</a></h2><p>There are some important comments in the <code>memory.ld</code> file that are worth duplicating here:</p><p>&quot;The STM32F407VG has 1024Kb of FLASH beginning at address 0x0800:0000 and 192Kb of SRAM. SRAM is split up into three blocks:</p><ul><li>&quot;112KB of SRAM beginning at address 0x2000:0000</li><li>&quot;16KB of SRAM beginning at address 0x2001:c000</li><li>&quot;64KB of CCM SRAM beginning at address 0x1000:0000</li></ul><p>&quot;When booting from FLASH, FLASH memory is aliased to address 0x0000:0000 where the code expects to begin execution by jumping to the entry point in the 0x0800:0000 address range.</p><p>&quot;For MPU support, the kernel-mode NuttX section is assumed to be 128Kb of FLASH and 4Kb of SRAM. That is an excessive amount for the kernel which should fit into 64KB and, of course, can be optimized as needed... Allowing the additional memory does permit addition debug instrumentation to be added to the kernel space without overflowing the partition.</p><p>&quot;Alignment of the user space FLASH partition is also a critical factor: The user space FLASH partition will be spanned with a single region of size 2||n bytes. The alignment of the user-space region must be the same. As a consequence, as the user-space increases in size, the alignment requirement also increases.</p><p>&quot;This alignment requirement means that the largest user space FLASH region you can have will be 512KB at it would have to be positioned at 0x08800000. If you change this address, don&#39;t forget to change the <code>CONFIG_NUTTX_USERSPACE</code> configuration setting to match and to modify the check in <code>kernel/userspace.c</code>.</p><p>&quot;For the same reasons, the maximum size of the SRAM mapping is limited to 4KB. Both of these alignment limitations could be reduced by using multiple MPU regions to map the FLASH/SDRAM range or perhaps with some clever use of subregions.&quot;</p><h2 id="memory-management" tabindex="-1">Memory Management <a class="header-anchor" href="#memory-management" aria-label="Permalink to &quot;Memory Management&quot;">​</a></h2><p>At present, there are two options for memory management in the NuttX protected build:</p><h3 id="single-user-heap" tabindex="-1">Single User Heap <a class="header-anchor" href="#single-user-heap" aria-label="Permalink to &quot;Single User Heap&quot;">​</a></h3><p>By default, there is only a single user-space heap and heap allocator that is shared by both kernel- and user-modes. PROs: Simple and makes good use of the heap memory space, CONs: Awkward architecture and no security for kernel-mode allocations.</p><h3 id="dual-partitioned-heaps" tabindex="-1">Dual, Partitioned Heaps <a class="header-anchor" href="#dual-partitioned-heaps" aria-label="Permalink to &quot;Dual, Partitioned Heaps&quot;">​</a></h3><p>Two configuration options can change this behavior:</p><ul><li><code>CONFIG_MM_MULTIHEAP=y</code>. This changes internal memory manager interfaces so that multiple heaps can be supported.</li><li><code>CONFIG_MM_KERNEL_HEAP=y</code>. Uses the multi-heap capability to enable a kernel heap</li></ul><p>If this both options are defined defined, the two heap partitions and two copies of the memory allocators are built:</p><p>One un-protected heap partition that will allocate user accessible memory that is shared by both the kernel- and user-space code. That allocator physically resides in the user address space so that it can be called directly by both the user- and kernel-space code. There is a header at the beginning of the user-space blob; the kernel-space code gets address of the user-space allocator from this header.</p><p>And another protected heap partition that will allocate protected memory that is only accessible from the kernel code. This allocator is built into the kernel block. This separate protected heap is required if you want to support security features.</p><p>NOTE: There are security issues with calling into the user space allocators in kernel mode. That is a security hole that could be exploit to gain control of the system! Instead, the kernel code should switch to user mode before entering the memory allocator stubs (perhaps via a trap). The memory allocator stubs should then trap to return to kernel mode (as does the signal handler now).</p><h3 id="the-traditional-approach" tabindex="-1">The Traditional Approach <a class="header-anchor" href="#the-traditional-approach" aria-label="Permalink to &quot;The Traditional Approach&quot;">​</a></h3><p>A more traditional approach would use something like the interface <code>sbrk()</code>. The <code>sbrk()</code> function adds memory to the heap space allocation of the calling process. In this case, there would still be kernel- and user-mode instances of the memory allocators. Each would <code>sbrk()</code> as necessary to extend their heap; the pages allocated for the kernel-mode allocator would be protected but the pages allocated for the user-mode allocator would not. PROs: Meets all of the needs. CONs: Complex. Memory losses due to quantization.</p><p>This approach works well with CPUs that have very capable Memory Management Units (MMUs) that can coalesce the srbk-ed chunks to a contiguous, [virtual]{.title-ref} heap region. Without an MMU, the sbrk-ed memory would not be contiguous; this would limit the sizes of allocations due to the physical pages.</p><p>Many MCUs will have Memory Protection Units (MPUs) that can support the security features (only). However these lower end MPUs may not support sufficient mapping capability to support this traditional approach. The ARMv7-M MPU, for example, only supports eight protection regions to manage all FLASH and SRAM and so this approach would not be technically feasible for th ARMv7-M family (Cortex-M3/4).</p><h2 id="comparing-the-flat-build-configuration-with-the-protected-build-configuration" tabindex="-1">Comparing the &quot;Flat&quot; Build Configuration with the Protected Build Configuration <a class="header-anchor" href="#comparing-the-flat-build-configuration-with-the-protected-build-configuration" aria-label="Permalink to &quot;Comparing the \\&quot;Flat\\&quot; Build Configuration with the Protected Build Configuration&quot;">​</a></h2><p>Compare, for example the configuration <code>boards/arm/stm32/stm32f4discovery/configs/ostest</code> and the configuration <code>boards/arm/stm32/stm32f4discovery/configs/kostest</code>. These two configurations are identical except that one builds a &quot;flat&quot; version of OS test and the other builds a kernel version of the OS test. See the file <code>boards/arm/stm32/stm32f4discovery/README.txt</code> for more details about those configurations.</p><p>The configurations can be compared using the <code>cmpconfig</code> tool:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cd tools</span></span>
<span class="line"><span>make -f Makefile.host cmpconfig</span></span>
<span class="line"><span>cd ..</span></span>
<span class="line"><span>tools/cmpconfig boards/arm/stm32/stm32f4discovery/configs/ostest/defconfig boards/arm/stm32/stm32f4discovery/configs/kostest/defconfig</span></span></code></pre></div><p>Here is a summary of the meaning of all of the important differences in the configurations. This should be enough information for you to convert any configuration from a &quot;flat&quot; to a protected build:</p><ul><li><p><code>CONFIG_BUILD_2PASS=y</code>. This enables the two pass build.</p></li><li><p><code>CONFIG_BUILD_PROTECTED=y</code>. This option enables the &quot;two pass&quot; protected build.</p></li><li><p><code>CONFIG_PASS1_BUILDIR=&quot;boards/arm/stm32/stm32f4discovery/kernel&quot;</code>. This tells the build system the (relative) location of the pass1 build directory.</p></li><li><p><code>CONFIG_PASS1_OBJECT=&quot;&quot;</code>. In some &quot;two pass&quot; build configurations, the build system need to know the name of the first pass object. This setting is not used for the protected build.</p></li><li><p><code>CONFIG_NUTTX_USERSPACE=0x08020000</code>. This is the expected location where the user-mode blob will be located. The user-mode blob contains a header that includes information need by the kernel blob in order to interface with the user-code. That header will be expected to reside at this location.</p></li><li><p><code>CONFIG_PASS1_TARGET=&quot;all&quot;</code>. This is the build target to use for invoking the pass1 make.</p></li><li><p><code>CONFIG_MM_MULTIHEAP=y</code>. This changes internal memory manager interfaces so that multiple heaps can be supported.</p></li><li><p><code>CONFIG_MM_KERNEL_HEAP=y</code>. NuttX supports the option of using a single user-accessible heap or, if this options is defined, two heaps: (1) one that will allocate user accessible memory that is shared by both the kernel- and user-space code, and</p><p>(2) one that will allocate protected memory that is only accessible from the kernel code. Separate heap memory is required if you want to support security features.</p></li><li><p><code>CONFIG_MM_KERNEL_HEAPSIZE=8192</code>. This determines an approximate size for the kernel heap. The standard heap space is partitioned into a kernel- and user-heap space. This size of the kernel heap is only approximate because the user heap is subject to stringent alignment requirements. Because of the alignment requirements, the actual size of the kernel heap could be considerable larger than this.</p></li><li><p><code>CONFIG_BOARD_EARLY_INITIALIZE=y</code>. This setting enables a special, [early]{.title-ref} initialization call to initialize board-specific resources.</p></li><li><p><code>CONFIG_BOARD_LATE_INITIALIZE=y</code>. This setting enables a special initialization call to initialize [late]{.title-ref} board-specific resources. The difference between <code>CONFIG_BOARD_EARLY_INITIALIZE</code> and <code>CONFIG_BOARD_LATE_INITIALIZE</code> is that the <code>CONFIG_BOARD_EARLY_INITIALIZE</code> logic runs earlier in initialization before the full operating system is up and running. <code>CONFIG_BOARD_LATE_INITIALIZE</code>, on the other hand, runs at the completion of initialization, just before the user applications are started. Neither <code>CONFIG_BOARD_EARLY_INITIALIZE</code> nor <code>CONFIG_BOARD_LATE_INITIALIZE</code> are used in the OS test configuration but other configurations (such as NSH) require some application-specific initialization before the application can run. In the &quot;flat&quot; build, such initialization is performed as part of the application start-up sequence. These includes such things as initializing device drivers. These same initialization steps must be performed in kernel mode for the protected build and <code>CONFIG_BOARD_LATE_INITIALIZE</code>. See <code>boards/arm/stm32/stm32f4discovery/src/up_boot.c</code> for an example of such board initialization code.</p></li><li><p><code>CONFIG_NSH_ARCHINITIALIZE</code> is not defined. The setting <code>CONFIG_NSH_ARCHINITIALIZE</code> does not apply to the OS test configuration, however, this is noted here as an example of initialization that cannot be performed in the protected build.</p></li></ul><p>Architecture-Specific Options:</p><ul><li><code>CONFIG_SYS_RESERVED=8</code>. The user application logic interfaces with the kernel blob using system calls. The architecture-specific logic may need to reserved a few system calls for its own internal use. The ARMv7-M architectures all require 8 reserved system calls.</li><li><code>CONFIG_SYS_NNEST=2</code>. System calls may be nested. The system must retain information about each nested system call and this setting is used to set aside resources for nested system calls. In the current architecture, a maximum nesting level of two is all that is needed.</li><li><code>CONFIG_ARMV7M_MPU=y</code>. This settings enables support for the ARMv7-M Memory Protection Unit (MPU). The MPU is used to prohibit user-mode access to kernel resources.</li><li><code>CONFIG_ARMV7M_MPU_NREGIONS=8</code>. The ARMv7-M MPU supports 8 protection regions.</li></ul><h2 id="size-expansion" tabindex="-1">Size Expansion <a class="header-anchor" href="#size-expansion" aria-label="Permalink to &quot;Size Expansion&quot;">​</a></h2><p>The protected build will, or course, result in a FLASH image that is larger than that of the corresponding &quot;flat&quot; build. How much larger? I don&#39;t have the numbers in hand, but you can build <code>boards/arm/stm32/stm32f4discovery/configs/nsh</code> and <code>boards/arm/stm32/stm32f4discovery/configs/kostest</code> and compare the resulting binaries for yourself using the <code>size</code> command.</p><p>Increases in size are expected because:</p><ul><li>The syscall layer is included in the protected build but not the flat build.</li><li>The kernel-size _syscal_l stubs will cause all enabled OS code to be drawn into the build. In the flat build, only those OS interfaces actually called by the application will be included in the final objects.</li><li>The dual memory allocators will increase size.</li><li>Code duplication. Some code, such as the C library, will be duplicated in both the kernel- and user-blobs, and</li><li>Alignment. The alignments required by the MPU logic will leave relatively large regions of FLASH (and perhaps RAM) is not usable.</li></ul><h2 id="performance-issues" tabindex="-1">Performance Issues <a class="header-anchor" href="#performance-issues" aria-label="Permalink to &quot;Performance Issues&quot;">​</a></h2><p>The only performance differences using the protected build should result as a consequence of the [sycalls]{.title-ref} used to interact with the OS vs. the direct C calls as used in the flat build. If your performance is highly dependent upon high rate OS calls, then this could be an issue for you. But, in the typical application, OS calls do not often figure into the critical performance paths.</p><p>The [syscalls]{.title-ref} are, ultimately, software interrupts. If the platform does not support prioritized, nested interrupts then the [syscall]{.title-ref} execution could also delay other hardware interrupt processing. However, [sycall]{.title-ref} processing is negligible: they really just configure to return to in supervisor mode and vector to the [syscall]{.title-ref} stub. They should be lightning fast and, for the typical real-time applications, should cause no issues.</p>`,77)]))}const m=t(i,[["render",n]]);export{u as __pageData,m as default};
