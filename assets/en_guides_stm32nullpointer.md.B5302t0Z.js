import{_ as t,c as a,al as o,o as n}from"./chunks/framework.NFAqBSgQ.js";const d=JSON.parse('{"title":"STM32 Null Pointer Detection","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/stm32nullpointer.md","filePath":"en/guides/stm32nullpointer.md"}'),s={name:"en/guides/stm32nullpointer.md"};function i(r,e,l,c,p,h){return n(),a("div",null,e[0]||(e[0]=[o(`<h1 id="stm32-null-pointer-detection" tabindex="-1">STM32 Null Pointer Detection <a class="header-anchor" href="#stm32-null-pointer-detection" aria-label="Permalink to &quot;STM32 Null Pointer Detection&quot;">​</a></h1><h2 id="the-null-pointer-problem" tabindex="-1">The NULL Pointer Problem <a class="header-anchor" href="#the-null-pointer-problem" aria-label="Permalink to &quot;The NULL Pointer Problem&quot;">​</a></h2><p>A common cause of software bugs is null pointers. Pointers may be NULL if they are un-initialized and un-checked. The use of NULL pointers almost always results in something bad happening. Often, NULL pointer access can cause error exceptions and or diagnostic crashes. But on MCUs that have valid address decoding at address 0x0000:0000, the use of NULL pointers may not cause a crash at all but may, instead, cause strange behaviors that can sometimes be difficult to debug.</p><h2 id="cortex-m-memory" tabindex="-1">Cortex-M Memory <a class="header-anchor" href="#cortex-m-memory" aria-label="Permalink to &quot;Cortex-M Memory&quot;">​</a></h2><p>The Cortex-M family (Cortex-M0, M3, and M4) are such MCUs. They have their interrupt vectors positioned at address zero. Because of this, NULL pointer accesses will not necessarily cause crashes. Instead, the NULL pointers will access memory in the vicinity of the vector table and who knows what will happen next?</p><h2 id="stm32-memory-aliasing" tabindex="-1">STM32 Memory Aliasing <a class="header-anchor" href="#stm32-memory-aliasing" aria-label="Permalink to &quot;STM32 Memory Aliasing&quot;">​</a></h2><p>The STMicro STM32 family of Cortex-M3/4 MCUs do things a little differently. FLASH is physically addressed at address 0x0800:0000; the STM32 vector table is then physically located at 0x0800:0000 instead of 0x0000:0000. If the STM32 hardware is configured to boot from FLASH, then the the STM32 will remap the FLASH memory so that is aliased at address 0x0000:00000. In that way, the STM32 can boot from FLASH or external memory or any other memory region that it is capable of mapping.</p><p>In the NuttX linker scripts, the applications are linked to execute from the physical FLASH region at address 0x0800:0000. All valid FLASH memory access will then access memory in the 0x0800:0000 FLASH address range. But illegal NULL pointer access will access the aliased copy of FLASH beginning at 0x0000:0000. So we still have the problem.</p><h2 id="the-cortex-m-memory-protection-unit" tabindex="-1">The Cortex-M Memory Protection Unit <a class="header-anchor" href="#the-cortex-m-memory-protection-unit" aria-label="Permalink to &quot;The Cortex-M Memory Protection Unit&quot;">​</a></h2><p>The Memory Protection Unit (MPU) is an optional component of a Cortex-M implementation. Most popular Cortex-M3/4 MCUs do support the MPU. The MPU can be used to protect regions of memory so that if there is any attempted, unauthorized access to certain memory regions, then a memory protection violation exception will occur and the system will detect the illegal access.</p><p>See the ARM website for more information about the Cortex-M3/4 families and the Cortex-M3/4 MPU. See, for example <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dai0179b/CHDFDFIG.html" target="_blank" rel="noreferrer">2.2. Memory Protection Unit (MPU)</a>.</p><h2 id="using-the-mpu-to-detect-null-pointer-usage" tabindex="-1">Using the MPU to Detect Null Pointer Usage <a class="header-anchor" href="#using-the-mpu-to-detect-null-pointer-usage" aria-label="Permalink to &quot;Using the MPU to Detect Null Pointer Usage&quot;">​</a></h2><p>So, for the STM32, one thing that we can do is to program the MPU to prohibit software access to the memory region beginning at address 0x0000:0000. Petteri Aimonen posted a code snippet on the NuttX Forum showing how to do this. Here is Petteri&#39;s post:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* Catch any null pointer dereferences */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int region = 0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>putreg32(region, MPU_RNR);</span></span>
<span class="line"><span>putreg32(0, MPU_RBAR);</span></span>
<span class="line"><span>putreg32(MPU_RASR_ENABLE | MPU_RASR_SIZE_LOG2(20) | (0xFF &lt;&lt; MPU_RASR_SRD_SHIFT) | MPU_RASR_AP_NONO, MPU_RASR);</span></span>
<span class="line"><span>mpu_control(true, false, true);</span></span></code></pre></div>`,14)]))}const u=t(s,[["render",i]]);export{d as __pageData,u as default};
