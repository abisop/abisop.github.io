import{_ as t,c as a,al as n,o as i}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Integrating with Newlib","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/integrate_newlib.md","filePath":"en/guides/integrate_newlib.md"}'),s={name:"en/guides/integrate_newlib.md"};function o(l,e,d,c,p,h){return i(),a("div",null,e[0]||(e[0]=[n(`<h1 id="integrating-with-newlib" tabindex="-1">Integrating with Newlib <a class="header-anchor" href="#integrating-with-newlib" aria-label="Permalink to &quot;Integrating with Newlib&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Integrating+with+Newlib" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Integrating+with+Newlib</a></p><h2 id="built-in-c-library" tabindex="-1">Built-In C Library <a class="header-anchor" href="#built-in-c-library" aria-label="Permalink to &quot;Built-In C Library&quot;">​</a></h2><p>NuttX has its own, tiny, built-in C library. Along with that C library are all of the headers files with the definitions specific to that built-in C library. The definitions in those header files are not compatible with the definitions that you will find in the header files that come with any other C library and trying to mix these with header files from other C libraries is bound to cause you problems.</p><p>When GCC is built, it is built against a C library. The NuttX [buildroot]{.title-ref} tools are, of course, built against the built-in NuttX C-library and would seem to be the obvious choice of tools to use. But there are many reasons to use other tool chains. As examples, the NuttX [buildroot]{.title-ref} tools have some limitations in C++ support. Another example, is that you might want to use the higher-performance math library that is included in some other implementation of the C library.</p><p>There are many C libraries available: [glibc]{.title-ref} and [uClibc]{.title-ref} are commonly used with Linux tools. These should be avoided. Most embedded toolchains will be built against [newlib]{.title-ref}. So if you are not using the NuttX buildroot toolchain, you will most likely be using a toolchain that has [newlib]{.title-ref} built into it. Because of this, you may see issues if you include [newlib]{.title-ref} header files into your NuttX code.</p><h2 id="header-file-issues" tabindex="-1">Header File Issues <a class="header-anchor" href="#header-file-issues" aria-label="Permalink to &quot;Header File Issues&quot;">​</a></h2><h3 id="math-h" tabindex="-1">math.h <a class="header-anchor" href="#math-h" aria-label="Permalink to &quot;math.h&quot;">​</a></h3><p>Nuttx includes a built-in math library that can be selected with <code>CONFIG_LIBM=y</code>. There are reasons to use an external math library, however: The NuttX math library is written in C and will not be as performant as a custom math library tuned for your processor architecture. There some addition issues with the NuttX math libraries as documented in the top-level TODO list.</p><p>Many people choose to use the [newlib]{.title-ref} math library. If you include <code>math.h</code> without selecting <code>CONFIG_LIBM=y</code>, you will probably get the [newlib]{.title-ref} math library and you will certainly see a compilation error involving the definition of the type <code>wint_t</code>.</p><p>There have been many work arounds described in the NuttX forum. Here are a few:</p><ul><li>Copy the newlib <code>math.h</code> to <code>nuttx/include/math.h</code> and remove the reference to <code>wint_t</code>.</li><li>Add the following to <code>nuttx/libc/stdio/lib_libvsprintf.c</code>. I especially dislike this solution because it involves modification to a NuttX header file that cannot be accepted upstream.</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* Include floating point functions */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef CONFIG_LIBC_FLOATINGPOINT</span></span>
<span class="line"><span>#  include &quot;wchar.h&quot;</span></span>
<span class="line"><span>#  include &quot;stdio/lib_libdtoa.c&quot;</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><ul><li>Provide your own version of <code>math.h</code> (for GCC only) containing the following. And add the path to this <code>math.h</code> to your <code>CFLAGS</code> include path arguments. The path can specified by adding <code>-system</code> or <code>-I</code> to the CFLAGS. The path to this <code>math.h</code> must be defined last so that it has precedence. This will include the NuttX <code>wint_t</code> definition, then continue to include the default version of <code>math.h</code>.</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifndef _MYMATH_H</span></span>
<span class="line"><span>#define _MYMATH_H</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#include &quot;wchar.h&quot;</span></span>
<span class="line"><span>#include_next &lt;math.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#endif /* _MYMATH_H */</span></span></code></pre></div><ul><li>The PX4 team uses these patches to <a href="https://github.com/PX4/Firmware/blob/nuttx_v3/nuttx-patches/c%2B%2B11.patch" target="_blank" rel="noreferrer">cwhar</a> and <a href="https://github.com/PX4/Firmware/blob/nuttx_v3/nuttx-patches/math.h.patch" target="_blank" rel="noreferrer">math.h</a> to solve the issue. But note the comments in that code:</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* N.B. The following definitions are enabled at this time to allow the PX4</span></span>
<span class="line"><span>* development to continue until there is a SAFE  solution to foreign</span></span>
<span class="line"><span>* (non-nuttx) header file inclusion. There is a potential of a binary</span></span>
<span class="line"><span>* incompatibility and runtime errors, memory overwrites or corruption</span></span>
<span class="line"><span>* VVVVVVVVVVVVVVVVVVVVVVVVVV Begin Warning VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV</span></span>
<span class="line"><span>*/</span></span></code></pre></div><ul><li>Some people have suggested adding the type definition of <code>wint_t</code> to <code>nuttx/include/sys/types.h</code> merely because that header file will then be included into the newlib <code>math.h</code>. This inclusion, of course, also [very dangerous]{.title-ref} since the types in the NuttX <code>sys/types.h</code> header file may not agree with the types in the pre-compiled newlib math library. This solution is not recommended, in any case. The type <code>wint_t</code> is already correctly defined in <code>nuttx/include/sys/wchar.h</code> which is the one and only correct location per <a href="http://pubs.opengroup.org/onlinepubs/007908775/xsh/wchar.h.html" target="_blank" rel="noreferrer">OpenGroup.org</a>. It is a mystery to me why the newlib <code>math.h</code> header file uses <code>wint_t</code> without including <code>wchar.h</code>. If it did, then there would then this compilation issue would not exist (there could still be subtle binary compatibility issues).</li><li>The ideal solution would be to integrate a third-party, optimized, ARM math library into NuttX, building it using only NuttX header files. That would guarantee no binary incompatibility and would be a very useful contribution to NuttX.</li></ul><p>Changes to the <code>nuttx/arch/&lt;architecture&gt;/src/Makefile</code> may also be required so that the linker can find and include the math library (similar to the existed logic in the <code>Makefile</code> to find <code>libgcc.a</code>).</p><p>Update: This issue may have finally been resolved with this commit:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>commit 894ca622e6a408e5fa858a3fee46fb16f32cf86c</span></span>
<span class="line"><span>Author: Xiang Xiao \\&lt;xiaoxiang@xiaomi.com\\&gt;</span></span>
<span class="line"><span>Date:   Mon Aug 27 06:26:37 2018 -0600</span></span>
<span class="line"><span></span></span>
<span class="line"><span>include/sys/types:  Move wint_t and wctype_t from wchar.h to</span></span>
<span class="line"><span>types.h.  This change is compatible as before since wchar.h</span></span>
<span class="line"><span>include types.h indirectly.  This fixes a compilation error with</span></span>
<span class="line"><span>newlib&#39;s math.h:  &#39;unknown type name wint_t&#39;</span></span></code></pre></div><h3 id="cmath" tabindex="-1">cmath <a class="header-anchor" href="#cmath" aria-label="Permalink to &quot;cmath&quot;">​</a></h3><p>This error has been reported:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/nuttx/include/cxx/cmath:124:11: error: &#39;::log2l&#39; has not been declared...</span></span></code></pre></div><p>Apparently the function logic <code>log2l()</code> is defined in the NuttX <code>math.h</code> and added to the <code>std::</code> namespace in <code>cmath</code>. But, apparently, the newlib <code>math.h</code> does not prototype <code>lib2l()</code>.</p><p>If you plan to use the newlib <code>math.h</code> and the NuttX <code>cmath</code>, then you probably have to modify <code>cmath</code> as well.</p><h3 id="alloca-h" tabindex="-1">alloca.h <a class="header-anchor" href="#alloca-h" aria-label="Permalink to &quot;alloca.h&quot;">​</a></h3><p>If your imported application includes <code>alloca.h</code>, then you will run into the same kinds of issues. Nuttx does not provide this header file an so you will probably end up including the newlib version of <code>alloca.h</code> which has similar disastrous results.</p><p>One solution for GCC (only) would be to provide you own <code>alloca.h</code> containing:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifndef _ALLOCA_H</span></span>
<span class="line"><span>#define _ALLOCA_H</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#define alloca __builtin_alloca</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#endif /* _ALLOCA_H */</span></span></code></pre></div><p>And add the path to this <code>alloca.h</code> to your <code>CFLAG</code> include path arguments. The path can specified by adding <code>-system</code> or <code>-I</code> to the CFLAGS. The path to this <code>alloca.h</code> must be defined last so that it has precedence.</p><p>However, if you include newlib header files that include other <code>alloc.h</code> you may still end up including the newlib <code>alloca.h</code>. So another solution might be to include your own <code>math.h</code>, for example, which contains something like like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifndef _MYMATH_H</span></span>
<span class="line"><span>#define _MYMATH_H</span></span>
<span class="line"><span>#ifndef _ALLOCA_H</span></span>
<span class="line"><span>#define _ALLOCA_H</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#define alloca __builtin_alloca</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#endif /* _ALLOCA_H */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#include_next &lt;math.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#endif /* _MYMATH_H */</span></span></code></pre></div><p>This will provide the <code>alloca()</code> definition, then continue to include the default version of <code>math.h</code>. This works because the idempotence pre-processor variable <code>_ALLOC_H</code> matches the same idempotence variable used in the newlib <code>alloca.h</code>. Thus, any sneak inclusion of <code>alloca.h</code> with have not effect.</p><h2 id="c-issues" tabindex="-1">C++ Issues <a class="header-anchor" href="#c-issues" aria-label="Permalink to &quot;C++ Issues&quot;">​</a></h2><p>Most of the C++ issues that have not so much to do with header files as with C++ name mangling and strict typing.</p><h3 id="new-operator" tabindex="-1">new Operator <a class="header-anchor" href="#new-operator" aria-label="Permalink to &quot;new Operator&quot;">​</a></h3><p>The prototype for the C++ new operator is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void *operator new(size_t nbytes)</span></span></code></pre></div><p>However, <code>size_t</code>, in turn, defined to be either <code>unsigned long</code> or <code>unsigned int</code> in the toolchain. This differs with different versions of GCC toolchains and has nothing to do with header file inclusion. NuttX supports a configuration option to work around this, change new to either:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_CXX_NEWLONG</span></span>
<span class="line"><span>void *operator new(unsigned long nbytes)</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>void *operator new(unsigned int nbytes)</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><p>This C++ name mangling issue has been around for years and varies from GCC compiler to GCC compiler, apparently due to some [newlib]{.title-ref} configuration difference.</p><h3 id="uint32-t" tabindex="-1">uint32_t <a class="header-anchor" href="#uint32-t" aria-label="Permalink to &quot;uint32\\_t&quot;">​</a></h3><p>Similarly, you may find that the definition of <code>uint32_t</code> in NuttX may be incompatible with your toolchain&#39;s libraries. You may, perhaps, see errors like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>error: redeclaration of &#39;typedef long unsigned int std::uint_least32_t&#39;</span></span></code></pre></div><p>The definition in the ARM header file at <code>nuttx/arch/arm/include/types.h</code> is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef signed int _int32_t;</span></span>
<span class="line"><span>typedef unsigned int _uint32_t;</span></span></code></pre></div><p>On ARM platforms, <code>unsigned long</code> and <code>unsigned int</code> are both 32-bit integers so it does not matter which definition you use. But it does matter if you are concerned about the C++ name mangling associated with the use of size_t by your compiler. If you see errors such as the above, then you can replace these type definition to avoid C++ name mangling incompatibilities like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef signed long _int32_t;</span></span>
<span class="line"><span>typedef unsigned long _uint32_t;</span></span></code></pre></div><p>But this now may result in additional problems, now there may be incompatibilities between definition of <code>size_t</code> uses in NuttX and the definition of <code>size_t</code> used in the libraries.</p><h3 id="size-t" tabindex="-1">size_t <a class="header-anchor" href="#size-t" aria-label="Permalink to &quot;size\\_t&quot;">​</a></h3><p><code>size_t</code> should be an integer type wide enough to hold the size of the largest memory object. So <code>size_t</code> really depends on the size of the underlying pointer type. For CPUs with 16-bit addressing, for example, the width of <code>size_t</code> should be 16-bits; for CPUs with 32-bit addressing, the width should be 32-bits.</p><p><code>uint32_t</code>, of course, should always be 32-bits in width.</p><p>Using newlib header files, you also encounter incompatibilities between the definitions of some types, the types <code>uint32_t</code> and <code>size_t</code> is often the sources of problems. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>error: redeclaration of &#39;typedef unsigned int std::size_t&#39;</span></span></code></pre></div><p>The root cause of this issue is that the community cannot decide on the correct definition of <code>size_t</code>. NuttX uses this [flexible]{.title-ref} definition of <code>size_t</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef uint32_t size_t;</span></span></code></pre></div><p>It is [flexible]{.title-ref} in the sense that <code>uint32_t</code> is determined by architecture specific header files, [not]{.title-ref} the RTOS itself. That definition will be either <code>unsigned long</code> or <code>unsigned int</code>. So the <code>size_t</code> type compatibility can differ with different compilers and also with different architectures (NOTE that since <code>size_t</code> should be wide enough to hold the size of the largest addressable object. <code>uint32_t</code> only works for 32-bit addressable machines. Perhaps, <code>size_t</code> should really be defined as type <code>uintptr_t</code>?).</p><p>This can be fixed by changing the definition of <code>uint32_t</code> as described above. But that could introduce <code>uint32_t</code> name mangling incompatibilities. In that case, you have no option but to decouple the definition of <code>size_t</code> from <code>uint32_t</code> by changing the definition in <code>nuttx/include/sys/types.h</code> to:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef unsigned int size_t;</span></span></code></pre></div><p>or</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>typedef unsigned long size_t;</span></span></code></pre></div><p>whichever resolves the incompatibility.</p>`,64)]))}const b=t(s,[["render",o]]);export{u as __pageData,b as default};
