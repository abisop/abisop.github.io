import{_ as a,c as n,al as t,o as s}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Zynq UltraScale+ RFSoC ZCU111","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm64/zynq-mpsoc/boards/zcu111/index.md","filePath":"en/platforms/arm64/zynq-mpsoc/boards/zcu111/index.md"}'),o={name:"en/platforms/arm64/zynq-mpsoc/boards/zcu111/index.md"};function i(l,e,p,r,c,d){return s(),n("div",null,e[0]||(e[0]=[t(`<h1 id="zynq-ultrascale-rfsoc-zcu111" tabindex="-1">Zynq UltraScale+ RFSoC ZCU111 <a class="header-anchor" href="#zynq-ultrascale-rfsoc-zcu111" aria-label="Permalink to &quot;Zynq UltraScale+ RFSoC ZCU111&quot;">​</a></h1><p>chip:xczu28dr, chip:fpga, chip:zynq, chip:ultrascale</p><p>The <a href="https://www.xilinx.com/products/boards-and-kits/zcu111.html" target="_blank" rel="noreferrer">ZCU111</a> is a development board based on the Zynq UltraScale+ RFSoC(XCZU28DR) from XilinX(AMD).</p><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h2><ul><li></li></ul><pre><code>**RF Data Converter**

:   -   **12-bit ADC:** 8, Max Rate 4.096G
    -   **14-bit DAC:** 8, Max Rate 6.554G
    -   **SD-FEC:** SD-FEC
</code></pre><ul><li></li></ul><pre><code>**Memory**

:   -   **PS DDR4:** 4GB 64-bit SODIMM
    -   **SD-Card:** Yes
    -   **M.2 SATA Connector:** Yes
    -   **QSPI:** 2
</code></pre><ul><li></li></ul><pre><code>**Communications &amp; Networking**

:   -   **USB UART/JTAG:** 1
    -   **RJ45:** 1
    -   **SFP+:** 4
    -   **USB 3.0:** 1
</code></pre><ul><li></li></ul><pre><code>**Expansion Connectors**

:   -   **FMC-HPC Connector:** 2
    -   **PMOD:** 2
    -   **RFMC 1.0:** 2
    -   **QSPI:** 2
</code></pre><ul><li></li></ul><pre><code>**Control &amp; I/O**

:   -   **I2C:** Yes
    -   **PMBUS:** Yes
    -   **JTAG PC4 Header:** Yes
</code></pre><ul><li></li></ul><pre><code>**Boot Options**

:   -   **ISD Boot:** Yes
    -   **QSPI Boot:** Yes
    -   **JTAG Boot:** Yes
</code></pre><ul><li><strong>DDR4 SODIMM:</strong> 4GB 64-bit, 2400MT/s, attached to Processor Subsystem (PS)</li></ul><h2 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h2><p>Serial console for the PS:</p><p>Pin Signal Notes</p><hr><p>MIO18 UART0 TX USB UART COM0 MIO19 UART0 RX USB UART COM0</p><p>PS-side UART interface and is connected to the FTDI U34 FT4232HL USB-to-Quad-UART bridge port B Connect ZCU111 to our computer with the USB Cable. On our computer start a Serial Terminal and connect to the USB Serial Port at <strong>115200 bps</strong>. NuttX will appear in the Serial Console when it boots on zcu111.</p><h2 id="leds-and-buttons" tabindex="-1">LEDs and Buttons <a class="header-anchor" href="#leds-and-buttons" aria-label="Permalink to &quot;LEDs and Buttons&quot;">​</a></h2><p>The PS-side pushbutton SW19 is connected to MIO22 (pin U1.Y28). The PS-side LED DS50, which is physically placed adjacent to the pushbutton, is connected to MIO23(pin U1.U29).</p><h2 id="networking" tabindex="-1">Networking <a class="header-anchor" href="#networking" aria-label="Permalink to &quot;Networking&quot;">​</a></h2><p>The ZCU111 board uses the TI DP83867IRPAP Ethernet RGMII PHY for Ethernet communications at 10 Mb/s, 100 Mb/s, or 1000 Mb/s. The board supports RGMII mode only. The PHY connection to a user-provided Ethernet cable is through a RJ-45 connector with built-in magnetics. The Ethernet connections from XCZU28DR to the DP83867 PHY device at are listed in fllowing:</p><p>Pin XCZU28DR Name Pin DP83867 Name</p><hr><p>J32 MIO65_ENET_TX_D0 38 TX_DO J34 MIO66_ENET_TX_D1 37 TX_D1 K28 MIO67_ENET_TX_D2 36 TX_D2 K29 MIO68_ENET_TX_D3 35 TX_D3 K30 MIO69_ENET_TX_CTRL 52 TX_EN_TX_CTRL K31 MIO70_ENET_RX_CLK 43 RX_CLK K32 MIO71_ENET_RX_D0 44 RX_DO K33 MIO72_ENET_RX_D1 45 RX_D1 K34 MIO73_ENET_RX_D2 46 RX_D2 L29 MIO74_ENET_RX_D3 47 RX_D3 L30 MIO75_ENET_RX_CTRL 53 RX_DV_RX_CTRL L33 MIO76_ENET_MDC 20 MDC L34 MIO77_ENET_MDIO 21 MDIO</p><p>Networking is supported via GEM3. DHCP is not used in this configuration; rather, a hard-coded IP address of 192.168.0.15 is used with a netmask of 255.255.255.0. The host is assumed to be 192.168.0.101 in places. You can reconfigure to enabled DHCPC or to change these addresses as you see fit.</p><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><p>Each configuration is maintained in a sub-directory and can be selected as follow:</p><pre><code>tools/configure.sh zcu111:&lt;subdir&gt;
</code></pre><p>Where &lt;subdir&gt; is one of the following:</p><h3 id="jtag" tabindex="-1">jtag <a class="header-anchor" href="#jtag" aria-label="Permalink to &quot;jtag&quot;">​</a></h3><p>Basic NuttShell configuration for JTAG boot mode (nsh console enabled in UART0, UART and JTAG exposed via FT4232HL USB-to-Quad-UART bridge port and USB cable).</p><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>Basic NuttShell configuration for Flash boot mode. We need create boot image with zynqmp_fsbl.elf, zynqmp_pmufw.elf, bl31.elf and nuttx.elf in Vivado SDK or XSCT shell. Also we need copy BOOT.BIN into SD Card(in SD card boot mode) or Flash it into the QSPI FLASH(in QSPI boot mode).</p><h3 id="netjtag" tabindex="-1">netjtag <a class="header-anchor" href="#netjtag" aria-label="Permalink to &quot;netjtag&quot;">​</a></h3><p>This is a network enabled configuration based on the NuttShell (NSH) for JTAG boot mode</p><h3 id="netnsh" tabindex="-1">netnsh <a class="header-anchor" href="#netnsh" aria-label="Permalink to &quot;netnsh&quot;">​</a></h3><p>This is a network enabled configuration based on the NuttShell (NSH). We need create boot image with zynqmp_fsbl.elf, zynqmp_pmufw.elf, bl31.elf and nuttx.elf in Vivado SDK or XSCT shell. Also we need Flash BOOT.BIN intothe QSPI FLASH(in QSPI boot mode).</p><h2 id="arm64-toolchain" tabindex="-1">ARM64 Toolchain <a class="header-anchor" href="#arm64-toolchain" aria-label="Permalink to &quot;ARM64 Toolchain&quot;">​</a></h2><p>There are two ways to install the toolchain for Zynq MPSoC: The first way is download the ARM64 Toolchain <code>aarch64-none-elf</code> from <a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads" target="_blank" rel="noreferrer">Arm GNU Toolchain Downloads</a>. Add the downloaded toolchain <code>gcc-arm-...-aarch64-none-elf/bin</code> to the <code>PATH</code> Environment Variable such as:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> echo &quot;export PATH=/home/username/tools/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf/bin:PATH&quot; &gt;&gt; ~/.profile</span></span></code></pre></div><p>You can edit your .profile files if you don&#39;t use bash.</p><p>The second way is install Vivado SDK or Vitis development environment which included a complete <code>aarch64-none-elf</code> toolchain and we also add it to the <code>PATH</code> Environment Variable such as:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> echo &quot;export PATH=/home/username/tools/Xilinx/SDK/2018.3/gnu/aarch64/lin/aarch64-none/bin:PATH&quot; &gt;&gt; ~/.profile</span></span></code></pre></div><p>You can edit your .profile files if you don&#39;t use bash.</p><p>Note: nuttx.elf build by toolchain install in first way can&#39;t be debugged by Vivado SDK which use toolchain of second way for gdb version incompatibility.</p><p>Check the ARM64 Toolchain:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> aarch64-none-elf-gcc -v</span></span></code></pre></div><h2 id="building" tabindex="-1">Building <a class="header-anchor" href="#building" aria-label="Permalink to &quot;Building&quot;">​</a></h2><p>There are two types of NuttX image for Zynq MPSoC: debug by JTAG and boot from FLASH.</p><h3 id="debug-by-jtag" tabindex="-1">debug by jtag <a class="header-anchor" href="#debug-by-jtag" aria-label="Permalink to &quot;debug by jtag&quot;">​</a></h3><p>We just configure the NuttX project and build the project:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> cd nuttx</span></span>
<span class="line"><span> tools/configure.sh zcu111:jtag</span></span>
<span class="line"><span> make</span></span></code></pre></div><p>Set the Project to nuttx and Application to nuttx.elf for psu_cortexa53_0 in Vivado SDK Debug Configuration. Just click Debug button then we can debug NuttX.</p><h3 id="boot-from-flash" tabindex="-1">boot from flash <a class="header-anchor" href="#boot-from-flash" aria-label="Permalink to &quot;boot from flash&quot;">​</a></h3><p>To boot from FLASH, we have to create BOOT.BIN image and flash it into QSPI FLASH or SD card. To create BOOT.BIN in addition to building nuttx.elf, we also need to build zynqmp_fsbl.elf, zynqmp_pmufw.elf and bl31.elf To build nuttx.elf we just configure the NuttX project and build the project:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> cd nuttx</span></span>
<span class="line"><span> tools/configure.sh zcu111:nsh</span></span>
<span class="line"><span> make</span></span></code></pre></div><h3 id="build-bl31-elf" tabindex="-1">build bl31.elf <a class="header-anchor" href="#build-bl31-elf" aria-label="Permalink to &quot;build bl31.elf&quot;">​</a></h3><p>To build bl31.elf we should fetch Fetch sources of ARM Trusted Firmware (ATF) and checkout the tags that corresponding to the SDK version. Take Vivado 2018.3 for example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> git clone https://github.com/Xilinx/arm-trusted-firmware.git</span></span>
<span class="line"><span> cd arm-trusted-firmware</span></span>
<span class="line"><span> git checkout xilinx-v2018.3</span></span></code></pre></div><p>By default, the Arm-trusted firmware builds for OCM space at address 0xFFFEA000, and ATF assume that UBoot or nuttx.elf located at address 0x08000000. Then we just build bl31.elf with:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> make CROSS_COMPILE=aarch64-none-elf- PLAT=zynqmp RESET_TO_BL31=1</span></span></code></pre></div><p>But, with DEBUG flag set to 1, it can&#39;t fit in OCM, so by default with DEBUG=1, it builds for DDR location 0x1000 with build flag DEBUG=1 mentioned while building. Alternatively, user has always an option to build for the location of their choice by specifying the build flags ZYNQMP_ATF_MEM_BASE, ZYNQMP_ATF_MEM_SIZE while building. The flag ZYNQMP_ATF_MEM_BASE specifies the base address of ATF and flag ZYNQMP_ATF_MEM_SIZE specifies the maximum size the ATF image can be. what&#39;s more we can specifies the target address of Uboot or nuttx.elf by PRELOADED_BL33_BASE. for zcu111:nsh configuration Example bl31 build command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> make CROSS_COMPILE=aarch64-none-elf- PLAT=zynqmp RESET_TO_BL31=1 ZYNQMP_ATF_MEM_BASE=0x10000 ZYNQMP_ATF_MEM_SIZE=0x40000 PRELOADED_BL33_BASE=0x100000</span></span></code></pre></div><p>If we don&#39;t dubug bl31 we just build bl31 in following command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> make CROSS_COMPILE=aarch64-none-elf- PLAT=zynqmp RESET_TO_BL31=1 PRELOADED_BL33_BASE=0x100000</span></span></code></pre></div><p>After the build process completes the bl31.elf binary is created within the /build/zynqmp/release/bl31 directory.</p><h3 id="build-zynqmp-pmufw-elf" tabindex="-1">build zynqmp_pmufw.elf <a class="header-anchor" href="#build-zynqmp-pmufw-elf" aria-label="Permalink to &quot;build zynqmp\\_pmufw.elf&quot;">​</a></h3><p>The Platform Management Unit (PMU) in Zynq MPSoC has a Microblaze with 32 KB of ROM and 128 KB of RAM. The ROM is pre-loaded with PMU Boot ROM (PBR) which performs pre-boot tasks and enters a service mode. For more details on PMU, PBR and PMUFW load sequence, refer to Platform Management Unit (Chapter-6) in Zynq MPSoC TRM (UG1085). PMU RAM can be loaded with a firmware (PMU Firmware) at run-time and can be used to extend or customize the functionality of PMU. Some part of the RAM is reserved for PBR, leaving around 125.7 KB for PMU Firmware. There are usually two flows to create and build a PMU Firmware image for the target, Xilinx Vitis or Vivado SDK IDE or hsi command line. The PMU Firmware is provided as a template application for the PMU processor for any hardware platform including the Zynq MPSoC device. The steps required to create and build it can be applied by selecting the appropriate platform, processor, and template to create zynqmp_pmufw.elf. We can also create PMU Firmware from system hardware project hdf file by hsi command line:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>proc generate_pmufw {} {</span></span>
<span class="line"><span>    if {[file exists pmu_fw/zynqmp_pmufw.elf] != 1} {</span></span>
<span class="line"><span>        set pmufw_design [hsi::create_sw_design pmu_1 -proc psu_pmu_0 -app zynqmp_pmufw]</span></span>
<span class="line"><span>        hsi::add_library libmetal</span></span>
<span class="line"><span>        hsi::generate_app -dir pmu_fw -compile</span></span>
<span class="line"><span>        return &quot;pmu_fw/zynqmp_pmufw.elf&quot;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return &quot;pmu_fw/zynqmp_pmufw.elf&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>In order to call this procs, the user needs to open the hdf (hsi::open_hw_design):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>proc create_pmufw {hdf} {</span></span>
<span class="line"><span>    hsi::open_hw_design hdf</span></span>
<span class="line"><span>    set pmufw [generate_pmufw]</span></span>
<span class="line"><span>    hsi::close_hw_design [hsi::current_hw_design]</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Create a TCL script with HSI commands above -&gt; Create a TCL script with HSI commands above -&gt; Launch XSCT 2018.3 -&gt; Change directory to the zipped directory -&gt; source xsct_script.tcl -&gt; create_pmufw design_1_wrapper.hdf</p><h3 id="build-zynqmp-fsbl-elf" tabindex="-1">build zynqmp_fsbl.elf <a class="header-anchor" href="#build-zynqmp-fsbl-elf" aria-label="Permalink to &quot;build zynqmp\\_fsbl.elf&quot;">​</a></h3><p>First Stage Bootloader (FSBL) for Zynq UltraScale+ MPSoC configures the FPGA with hardware bitstream (if it exists) and loads the Operating System (OS) Image or Standalone (SA) Image or 2nd Stage Boot Loader image from the non-volatile memory (SD/eMMC/QSPI) to Memory (DDR/TCM/OCM) and takes A53/R5 out of reset. It supports multiple partitions, and each partition can be a code image or a bitstream. Each of these partitions, if required, will be authenticated and/or decrypted. FSBL is loaded into OCM and handed off by CSU BootROM after authenticating and/or decrypting (as required) FSBL. There are usually two flows to create and build a PMU Firmware image for the target, Xilinx Vitis or Vivado SDK IDE or hsi command line. To create FSBL by Vitis or Vivado SDK IDE just launch VITIS or Vivado SDK and do following flow:</p><ul><li><p>Provide path where VITIS workspace and project need to be created. With this VITIS workspace will be created</p></li><li><p>(Optional step) To work with local repos, Select &quot;Xilinx&quot; (ALT - x) -&gt; Repositories. Against Local Repositories, click on &quot;New...&quot; and provide path of the local repo</p></li><li><p>Select File--&gt;New--&gt;Application Project to open &quot;New Project&quot; window, provide name for FSBL project</p></li><li></li></ul><pre><code>In the &quot;Platform&quot; section, click on &quot;Create a new platform from hardware (XSA)&quot; and select pre-defined hardware platform for ZynqMP.

:   -   Alternatively, to create a new/custom platform from a .xsa
        file, click on &quot;+&quot;, browse and select the XSA file and a new
        hardware platform is created.
</code></pre><ul><li><p>In the &quot;Domain&quot; window, select the processor psu_cortexa53_0/psu_cortexr5_0, OS as standalone and Language as C.</p></li><li><p>Click Next and select &quot;Zynq MP FSBL&quot;</p></li><li><p>Click &quot;Finish&quot; to generate the A53/R5 FSBL. This populates the FSBL code and also builds it (along with BSP)</p></li><li></li></ul><pre><code>Debug prints in FSBL are now disabled by default. To enable debug prints, define symbol: FSBL\\_DEBUG\\_INFO.

:   -   In VITIS this can be done by: right click on FSBL
        application project -\\&gt; select &quot;C/C++ Build Settings&quot; -\\&gt;
        &quot;Tool Settings&quot; tab -\\&gt; Symbols (under ARM v8 gcc compiler)
    -   Click on Add (+) icon and Enter Value: FSBL\\_DEBUG\\_INFO,
        click on \\&quot;OK\\&quot; to close the \\&quot;Enter Value\\&quot; screen
</code></pre><ul><li>In case any of the source files (FSBL or BSP) need to be modified, browse the file, make the change and save the file, build the project. elf file will be present in the Debug/Release folder of FSBL project.</li></ul><p>To create FSBL by XSCT command line just launch XSCT console and execute following TCL script with HSI commands:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>proc generate_fsbl {} {</span></span>
<span class="line"><span>    if {[file exists zynqmp_fsbl/zynqmp_fsbl.elf] != 1} {</span></span>
<span class="line"><span>        set fsbl_design [hsi::create_sw_design fsbl_1 -proc psu_cortexa53_0 -app zynqmp_fsbl]</span></span>
<span class="line"><span>        common::set_property APP_COMPILER &quot;aarch64-none-elf-gcc&quot; fsbl_design</span></span>
<span class="line"><span>        common::set_property -name APP_COMPILER_FLAGS -value &quot;-DRSA_SUPPORT -DFSBL_DEBUG_INFO -DXPS_BOARD_ZCU111&quot; -objects fsbl_design</span></span>
<span class="line"><span>        hsi::add_library libmetal</span></span>
<span class="line"><span>        hsi::generate_app -dir zynqmp_fsbl -compile</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return &quot;zynqmp_fsbl/zynqmp_fsbl.elf&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>In order to call this procs, the user needs to open the hdf (hsi::open_hw_design):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>proc create_fsbl {hdf} {</span></span>
<span class="line"><span>    hsi::open_hw_design hdf</span></span>
<span class="line"><span>    set fsbl [generate_fsbl]</span></span>
<span class="line"><span>    hsi::close_hw_design [hsi::current_hw_design]</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Create a TCL script with HSI commands above -&gt; Create a TCL script with HSI commands above -&gt; Launch XSCT 2018.3 -&gt; Change directory to the zipped directory -&gt; source xsct_script.tcl -&gt; create_fsbl design_1_wrapper.hdf</p><h3 id="generate-boot-bin-image" tabindex="-1">generate BOOT.bin image <a class="header-anchor" href="#generate-boot-bin-image" aria-label="Permalink to &quot;generate BOOT.bin image&quot;">​</a></h3><p>You can create BOOT.bin images using the BIF attributes and the Bootgen command. For this configuration, the BIF file(named fsbl.bif) contains the following attributes:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>the_ROM_image:</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  [fsbl_config]a53_x64</span></span>
<span class="line"><span>  [bootloader]zynqmp_fsbl.elf</span></span>
<span class="line"><span>  [pmufw_image]zynqmp_pmufw.elf</span></span>
<span class="line"><span>  [destination_cpu = a53-0, exception_level = el-3, trustzone]bl31.elf</span></span>
<span class="line"><span>  [destination_cpu = a53-0, exception_level = el-1]nuttx.elf</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>The Vitis IDE calls the following Bootgen command to generate the BOOT.bin image for this configuration:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>bootgen -image fsbl.bif -arch zynqmp -o .\\BOOT.bin</span></span></code></pre></div><h3 id="flash-boot-bin-to-qspi-flash" tabindex="-1">Flash BOOT.bin to QSPI FLASH <a class="header-anchor" href="#flash-boot-bin-to-qspi-flash" aria-label="Permalink to &quot;Flash BOOT.bin to QSPI FLASH&quot;">​</a></h3><p>We can flash BOOT.bin into QSPI FLASH in following flow:</p><ul><li>In the Vivado SDK/Vitis IDE, select Xilinx -&gt; Program Flash.</li><li>In the Program Flash wizard, browse to and select the BOOT.bin image file that was created as a part of this example.</li><li>Select <strong>qspi-x8-dual_parallel</strong> as the Flash type.</li><li>Set the Offset as 0 and select the BOOT.bin file.</li><li>Click Program to start the process of programming the QSPI flash with the BOOT.bin.</li><li>Wait until you see the message &quot;Flash Operation Successful&quot; in the console.</li></ul><p>Set mode switch SW6 to QSPI32, NuttX will appear in the Serial Console when we power on zcu111.</p>`,99)]))}const b=a(o,[["render",i]]);export{u as __pageData,b as default};
