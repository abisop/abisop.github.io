import{_ as t,c as a,al as s,o as i}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"tcp_ipc_server Server for TCP IPC NuttX","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/examples/tcp_ipc_server/index.md","filePath":"en/applications/examples/tcp_ipc_server/index.md"}'),r={name:"en/applications/examples/tcp_ipc_server/index.md"};function o(n,e,l,c,p,h){return i(),a("div",null,e[0]||(e[0]=[s('<h1 id="tcp-ipc-server-server-for-tcp-ipc-nuttx" tabindex="-1"><code>tcp_ipc_server</code> Server for TCP IPC NuttX <a class="header-anchor" href="#tcp-ipc-server-server-for-tcp-ipc-nuttx" aria-label="Permalink to &quot;`tcp_ipc_server` Server for TCP IPC NuttX&quot;">​</a></h1><h2 id="what-s-this" tabindex="-1">What&#39;s this? <a class="header-anchor" href="#what-s-this" aria-label="Permalink to &quot;What\\&#39;s this?&quot;">​</a></h2><p>This program consists of a server socket &amp; custom messages to establish IPC for multiple applications (client_tcp) and one process that controls LoRaWAN connectivity (server_tcp). For more details about client side, please see client_tcp example.</p><p>This approach using TCP/IP sockets as IPC channel ensures controlled access to LoRaWAN connectivity. The goals of using this approach are:</p><ul><li>Having a solid and reliable infrastructure to ensure IPC works fine for multiple applications simultaneously</li><li>Having the possibility to host different IoT projects and solutions that use LPWAN in a single ESP32</li><li>Having the possibility to validate, test and debug multiple IoT projects and solutions at the same time, under the same connectivity conditions (same signal strength, same antenna, same modem/transceiver, etc.)</li></ul><p>Both client and server work on local network scope.</p><h2 id="how-do-i-use-this" tabindex="-1">How do I use this? <a class="header-anchor" href="#how-do-i-use-this" aria-label="Permalink to &quot;How do I use this?&quot;">​</a></h2><p>In order to test client_tcp &amp; server_tcp together, there are two ways to proceed:</p><ul><li>Init server manually (command: SERVER &amp;), and after successful server init, also init client manually (CLIENT 127.0.0.1)</li><li>init server automatically after boot using NuttShell start up scripts (check: <a href="https://nuttx.apache.org/docs/latest/applications/nsh/installation.html#nuttshell-start-up-scripts" target="_blank" rel="noreferrer">https://nuttx.apache.org/docs/latest/applications/nsh/installation.html#nuttshell-start-up-scripts</a> )</li></ul><h2 id="additional-info" tabindex="-1">Additional info <a class="header-anchor" href="#additional-info" aria-label="Permalink to &quot;Additional info&quot;">​</a></h2><p>Both client_tcp and server_tcp examples have been full covered in NuttX International Workshop 2022. You can watch the full presentation here: <a href="https://www.youtube.com/watch?v=hr0OfTt1KeY" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=hr0OfTt1KeY</a> The server_tcp and client_tcp examples have been developed by Flavio Ipirranga and Pedro Bertoleti from Instituto de Pesquisas Eldorado (IPE) in Brazil.</p>',11)]))}const m=t(r,[["render",o]]);export{u as __pageData,m as default};
