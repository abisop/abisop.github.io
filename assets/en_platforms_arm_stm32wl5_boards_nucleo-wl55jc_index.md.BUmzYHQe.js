import{_ as a,c as t,al as o,o as r}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"ST Nucleo WL55JC","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/stm32wl5/boards/nucleo-wl55jc/index.md","filePath":"en/platforms/arm/stm32wl5/boards/nucleo-wl55jc/index.md"}'),n={name:"en/platforms/arm/stm32wl5/boards/nucleo-wl55jc/index.md"};function i(l,e,s,d,p,u){return r(),t("div",null,e[0]||(e[0]=[o(`<h1 id="st-nucleo-wl55jc" tabindex="-1">ST Nucleo WL55JC <a class="header-anchor" href="#st-nucleo-wl55jc" aria-label="Permalink to &quot;ST Nucleo WL55JC&quot;">​</a></h1><p>chip:stm32, chip:stm32wl, chip:stm32wl55</p><p>The <a href="https://www.st.com/en/evaluation-tools/nucleo-wl55jc.html" target="_blank" rel="noreferrer">Nucleo-WL55JC</a> is a development board for the STM32WL55 SoC from ST. It features 64 I/O, 3 onboard LEDs and buttons, integrated stlink for easy debug and flashing and on-board LoRa receiver with external antenna. NSH can be easily access via virtual serial port from usb.</p><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h2><ul><li>STM32WL55JC MCU, 256K FLASH, 64K SRAM</li><li>32768 Hz LSE crystal</li><li>32 MHz HSE crystal</li><li>Embedded stlink-v3 debugger (debug/flash and virtual serial port)</li><li>Reset button</li><li>3 user programmable LEDs</li><li>3 user programmable buttons</li><li>Power indicator LED</li><li>LoRa radio with antenna</li><li>64 Nucleo I/O</li><li>Arduino compatible pinout</li></ul><h2 id="pin-mapping" tabindex="-1">Pin Mapping <a class="header-anchor" href="#pin-mapping" aria-label="Permalink to &quot;Pin Mapping&quot;">​</a></h2><p>Pin mapping can be altered by (de)soldering bridges, by default board uses following mapping:</p><p>Pin Signal Notes</p><hr><p>PA2 LPUART1 TX Virtual serial port over usb PA3 LPUART2 RX Virtual serial port over usb PB6 USART1 TX D1 on Arduino pinout PB7 PA0 PA1 PC6 USART1 RX Button 1 Button 2 Button 3 R0 on Arduino pinout PB15 Blue LED Active HIGH PB11 Red LED Active HIGH PB9 Green LED Active HIGH</p><h2 id="default-peripherals-configuration" tabindex="-1">Default Peripherals Configuration <a class="header-anchor" href="#default-peripherals-configuration" aria-label="Permalink to &quot;Default Peripherals Configuration&quot;">​</a></h2><h3 id="led" tabindex="-1">LED <a class="header-anchor" href="#led" aria-label="Permalink to &quot;LED&quot;">​</a></h3><p>Green and Red LEDs are used by the system at boot to show system state. Once system is booted these LEDs are for user to control. When CONFIG_ARCH_LEDS is set, Blue LED is reserved by OS for reporting system status. When CONFIG_ARCH_LEDS is not set, OS state won&#39;t be reported on any of the LEDs and all 3 LEDs are available for user right from the start.</p><h3 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h3><p>There are 2 serial ports - USART1 and LPUART1.</p><p>USART1 is connected to arduino D0/D1 pin and LPUART is connected to stlink that provides virtual serial port.</p><p>NSH is configured to use LPUART and virtual serial port. After flashing you can open /dev/ttyACM0 (may change depending on your system) and nsh prompt will be waiting for you there. Serial device does not disappear when flashing and resetting board - it can be left opened and flashing will work without problems.</p><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>Basic NuttShell configuration (console enabled in LPUART1, exposed via USB connection, at 115200 bps 8n1).</p><h3 id="demo" tabindex="-1">demo <a class="header-anchor" href="#demo" aria-label="Permalink to &quot;demo&quot;">​</a></h3><p>This configuration contains demonstration code and programs to show what board is capable of. These programs and settings are usually absolutely useless in production code and are here just to show, by example, what you can do with the board.</p><h2 id="flash-debug" tabindex="-1">Flash &amp; Debug <a class="header-anchor" href="#flash-debug" aria-label="Permalink to &quot;Flash &amp; Debug&quot;">​</a></h2><p>Both flashing and debugging are done using the embedded stlink-v3 debugger. OpenOCD can be invoked in the following way to flash:</p><pre><code>openocd -f interface/stlink.cfg -f target/stm32wlx.cfg \\
    -c &quot;program nuttx.bin exit 0x08000000&quot;
</code></pre><p>To debug attach openocd to stlink with command:</p><pre><code>openocd -f interface/stlink.cfg -f target/stm32wlx.cfg
</code></pre><p>start gdb:</p><pre><code>arm-none-eabi-gdb ./nuttx --tui
</code></pre><p>attach to gdb server:</p><pre><code>target remote localhost:3333
</code></pre><p>(optionally) reset program and start from the very beginning:</p><pre><code>monitor reset halt
</code></pre><p>Remember to generate debug symbol by setting CONFIG_DEBUG_SYMBOLS and optionally (for more natural flow in gdb step) suppress optimization by setting CONFIG_DEBUG_NOOPT.</p>`,34)]))}const b=a(n,[["render",i]]);export{h as __pageData,b as default};
