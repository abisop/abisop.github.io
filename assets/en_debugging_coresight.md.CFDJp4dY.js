import{_ as r,c as t,al as a,o}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"Coresight - HW Assisted Tracing on ARM","description":"","frontmatter":{},"headers":[],"relativePath":"en/debugging/coresight.md","filePath":"en/debugging/coresight.md"}'),i={name:"en/debugging/coresight.md"};function n(s,e,c,d,p,h){return o(),t("div",null,e[0]||(e[0]=[a('<h1 id="coresight-hw-assisted-tracing-on-arm" tabindex="-1">Coresight - HW Assisted Tracing on ARM <a class="header-anchor" href="#coresight-hw-assisted-tracing-on-arm" aria-label="Permalink to &quot;Coresight - HW Assisted Tracing on ARM&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Coresight is an umbrella of technologies allowing for the debugging of ARM based SoC. It includes solutions for JTAG and HW assisted tracing. This document is concerned with the latter.</p><p>HW assisted tracing is becoming increasingly useful when dealing with systems that have many SoCs and other components like GPU and DMA engines. Developers can monitor the behavior of their software as it runs on the device, view real-time data about its execution, and identify and debug issues quickly.</p><p>Coresight omponents are generally categorised as source, link and sinks. The source devices generates a compressed stream representing the processor instruction path based on tracing scenarios. The link devices are responsible for transferring the stream from the source device to the sink device. The sink devices serve as as endpoints to the coresight implementation, either storing the compressed stream in a memory buffer or creating an interface to the outside world where data can be transferred to a host without fear of filling up the onboard coresight memory buffer.</p><p>refer to the following document for more details: <a href="https://developer.arm.com/documentation/102520/latest/" target="_blank" rel="noreferrer">https://developer.arm.com/documentation/102520/latest/</a></p><h2 id="acronyms-and-classification" tabindex="-1">Acronyms and Classification <a class="header-anchor" href="#acronyms-and-classification" aria-label="Permalink to &quot;Acronyms and Classification&quot;">​</a></h2><p>Acronyms:</p><p>PTM:</p><p>: Program Trace Macrocell</p><p>ETM:</p><p>: Embedded Trace Macrocell</p><p>STM:</p><p>: System trace Macrocell</p><p>ETB:</p><p>: Embedded Trace Buffer</p><p>ITM:</p><p>: Instrumentation Trace Macrocell</p><p>TPIU:</p><p>: Trace Port Interface Unit</p><p>TMC-ETR:</p><p>: Trace Memory Controller, configured as Embedded Trace Router</p><p>TMC-ETF:</p><p>: Trace Memory Controller, configured as Embedded Trace FIFO</p><p>Classification:</p><p>Source:</p><p>: ETM, STM, ITM</p><p>Link:</p><p>: Funnel, replicator, TMC-ETF</p><p>Sinks:</p><p>: ETB, TPIU, TMC-ETR</p><h2 id="framework-and-implementation" tabindex="-1">Framework and implementation <a class="header-anchor" href="#framework-and-implementation" aria-label="Permalink to &quot;Framework and implementation&quot;">​</a></h2><p>The coresight framework provides a central point to represent, configure and manage coresight devices on a platform. Any coresight compliant device can register with the framework for as long as they use the right APIs:</p><p><code>struct coresight_desc *desc</code> describes the type of current coresight device and where it connects to. When all the coresight devices are registered, devices throught the tracing stream path can be enablea by calling:</p><p>The <code>coresight_enable</code> function will build the path through srcdev and destdev according the <code>struct coresight_desc *desc</code>.</p>',35)]))}const g=r(i,[["render",n]]);export{m as __pageData,g as default};
