import{_ as o,c as a,al as t,o as i}from"./chunks/framework.NFAqBSgQ.js";const _=JSON.parse('{"title":"nxscope NxScope Library","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/logging/nxscope/index.md","filePath":"en/applications/logging/nxscope/index.md"}'),r={name:"en/applications/logging/nxscope/index.md"};function c(n,e,l,s,p,d){return i(),a("div",null,e[0]||(e[0]=[t('<h1 id="nxscope-nxscope-library" tabindex="-1"><code>nxscope</code> NxScope Library <a class="header-anchor" href="#nxscope-nxscope-library" aria-label="Permalink to &quot;`nxscope` NxScope Library&quot;">​</a></h1><p>This library provides real-time data logging functionality for NuttX.</p><p>The principle of action is to accumulate data gathered in virtual channels and periodically send buffered data through a dedicated interface packed with a custom protocol.</p><p>Supported features:</p><ul><li>up to 255 channels possible</li><li>support for standard data types and user-specific data (<code>enum nxscope_sample_dtype_e</code>)</li><li>support for vector data or point data</li><li>support for character-based channels (text messages)</li><li>support for channel metadata - can be used to enumerate samples or timestamp</li><li>stream buffer overflow detection (<code>NXSCOPE_STREAM_FLAGS_OVERFLOW</code>)</li><li>remote control with commands (<code>enum nxscope_hdr_id_e</code>)</li><li>protocol and interface implementation can be different for control commands and stream data</li><li>(optional) support for user-specific commands (<code>NXSCOPE_HDRID_USER</code> and <code>struct nxscope_callbacks_s</code>)</li><li>(optional) support for samples divider (<code>CONFIG_LOGGING_NXSCOPE_DIVIDER</code>)</li><li>(optional) support for ACK frames (<code>CONFIG_LOGGING_NXSCOPE_ACKFRAMES</code>)</li><li>(optional) support for user-defined types (<code>CONFIG_LOGGING_NXSCOPE_USERTYPES</code>)</li><li>(optional) support for non-buffered critical channels (<code>CONFIG_LOGGING_NXSCOPE_CRICHANNELS</code>)</li></ul><p>A custom interface and a custom protocol can be implemented with <code>struct nxscope_intf_s</code> and <code>struct nxscope_proto_s</code> structures.</p><p>Supported interfaces:</p><ol><li>a serial port: <code>logging/nxscope/nxscope_iser.c</code></li><li>a dummy interface for debug purposes: <code>logging/nxscope/nxscope_idummy.c</code></li></ol><p>A default serial protocol is implemented in <code>apps/logging/nxscope/nxscope_pser.c</code> It just packs NxScope data into simple frames with a CRC-16 checksum.</p><h2 id="external-tools" tabindex="-1">External tools <a class="header-anchor" href="#external-tools" aria-label="Permalink to &quot;External tools&quot;">​</a></h2><ul><li><a href="https://github.com/railab/nxslib" target="_blank" rel="noreferrer">Nxslib</a> - a Python (3.10+) client library for NxScope devices,</li><li><a href="https://github.com/railab/nxscli" target="_blank" rel="noreferrer">Nxscli</a> - a Python (3.10+) command-line interface for NxScope, supporting data capture and visualization</li></ul>',11)]))}const f=o(r,[["render",c]]);export{_ as __pageData,f as default};
