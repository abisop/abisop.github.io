import{_ as t,c as i,al as a,o as r}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"Device Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/implementation/device_drivers.md","filePath":"en/implementation/device_drivers.md"}'),o={name:"en/implementation/device_drivers.md"};function s(n,e,d,c,l,h){return r(),i("div",null,e[0]||(e[0]=[a('<h1 id="device-drivers" tabindex="-1">Device Drivers <a class="header-anchor" href="#device-drivers" aria-label="Permalink to &quot;Device Drivers&quot;">​</a></h1><h2 id="standard-device-drivers" tabindex="-1">Standard Device Drivers <a class="header-anchor" href="#standard-device-drivers" aria-label="Permalink to &quot;Standard Device Drivers&quot;">​</a></h2><p>Device drivers should be implemented in the RTOS and used by applications. Drivers provide access to device functionality for applications. This is a necessary part of the modular RTOS design. In the NuttX directory structure, share-able device drivers reside under <code>drivers/</code> and custom drivers reside in the board-specific directories at <code>nuttx/boards/&lt;arch&gt;/&lt;chip&gt;/&lt;board&gt;/src</code> or <code>nuttx/boards/&lt;arch&gt;/&lt;chip&gt;/drivers</code> that are built into the RTOS.</p><h2 id="bus-drivers" tabindex="-1">Bus Drivers <a class="header-anchor" href="#bus-drivers" aria-label="Permalink to &quot;Bus Drivers&quot;">​</a></h2><p>There a many things that get called drivers in OS; NuttX makes a distinction between device drivers and bus drivers. For example, SPI, PCI, PCMCIA, USB, Ethernet, etc. are buses and not devices. You will never find a device driver for a bus in the NuttX architecture.</p><p>In most devices architectures, devices reside on a bus. A bus is a transport layer that connects the device residing on the bus to a device driver. The bus is managed by a bus driver. The device driver uses the facilities of the bus driver transport layer to interact with the device.</p><p>Consider SPI. SPI is a bus. It provides a serial bus to which many devices may be connected. An SPI device resides on the SPI bus in the sense that is shares the same MISO, MOSI, and clock lines with other devices on the SPI bus (but in SPI, it will have its own dedicated chip select discrete).</p><p>Although we typically use the same term driver to refer to both bus drivers and device drivers, there is one big, fundamental difference: applications interact only with devices drivers and never with bus drivers. Applications never talk directly to PCI, PCMCIA, USB, Ethernet, nor with I2C, SPI, or GPIOs. Applications interface through device drivers that use PCI, PCMCIA, USB, Ethernet, I2C, or SPI. Bus drivers only exist to support the communication between the device driver and the device on the bus.</p><p>Back to SPI... There will never be an application accessible interface to SPI. If your application were to use SPI directly, then you would have have embedded a device driver in your application and would have violated the RTOS functional partition.</p><h2 id="test-drivers" tabindex="-1">Test Drivers <a class="header-anchor" href="#test-drivers" aria-label="Permalink to &quot;Test Drivers&quot;">​</a></h2><p>It would be possible to provide character driver, such as SPI driver, that could perform bus level accesses on behalf of an application. There are not many cases where this would be acceptable, however. One possibility would be to support support testing of bus drivers. There is, an example for I2S here: <code>drivers/audio/i2schar.c</code> with a test case here <code>apps/examples/i2schar</code>. I2S is, of course, very similar to SPI. This interface exists only for testing purposes and would probably not be possible to build any meaningless application with it.</p><h3 id="the-i2c-tool" tabindex="-1">The I2C Tool <a class="header-anchor" href="#the-i2c-tool" aria-label="Permalink to &quot;The I2C Tool&quot;">​</a></h3><p>Of course, like most rules, there are lots of violations. I2C is another bus and the the I2C &quot;driver&quot; is another transport similar in many ways to SPI. For I2C, there is an application at <code>apps/system/i2c</code> alled the &quot;I2C tool&quot; that will allow you access I2C devices from the command line. This is not really just a test tool and not a real part of an application.</p><p>And there is a fundamental flaw in the I2C tool: it uses NuttX internal interfaces and violates the functional partitioning. NuttX has three build mode: (1) A flat build where there is no enforcement of RTOS boundaries. In that flat build, the I2C tool works fine. And (2) a kernel build mode and (3) a protected build mode. In bothof these latter cases, the OS interfaces are strictly enforced. In the kernel pand protected build modes, the I2C tool is not available because it cannot access those NuttX internal interfaces.</p><h2 id="user-space-drivers" tabindex="-1">User Space Drivers <a class="header-anchor" href="#user-space-drivers" aria-label="Permalink to &quot;User Space Drivers&quot;">​</a></h2><p>Above, it was stated that if your application were to use a bus directly, then you would have have embedded a device driver in your application and would violate the RTOS functional partition. Such device built into user applications are referred to as user space drivers in some contexts. There is no plan or intent to support user space drivers in NuttX.</p><h2 id="communication-devices" tabindex="-1">Communication Devices <a class="header-anchor" href="#communication-devices" aria-label="Permalink to &quot;Communication Devices&quot;">​</a></h2><p>What about interface like CAN and UARTs? Why are those exposed as drivers when SPI and I2C are not?</p><p>Semantics are difficult. The general principles that are maintain in the RTOS are clear, but sometimes applying principles in a black and white way is not easy in a world with shades of grey. (And if the principles get in the way of good design then the principles should change).</p><p>In the case of true buses that support generic devices, the principle is a good one. But there are grey areas too.</p><p>CAN seems similar to Ethernet. Both are network interfaces of sorts. You wouldn&#39;t interface directly with Ethernet driver because you need to go through a network stack of some type. The OSI model prevents it.</p><p>UARTs are communication devices. There is no RS-232 bus with devices connected to it. Rather there are peers on the bus that you communicate with. This does not preclude a UART from being used as a low level transfer for a device driver (as with the driver for a wireless modules). Nor does it preclude a stack layer like Modbus from being inserted in the path.</p><p>CAN differs from Ethernet in that it really is a direct peer-to-peer communication, more like a UART. Although you can support a stack like CANOPen on CAN. Currently CAN can be used as a simple character device, or as a network interface using SocketCAN.</p><p>Communication devices support a fundamental peer-to-peer model. CAN and UARTs are basically serial interfaces. But so are SPI, I2C, and USB. But those latter serial interfaces clearly have a host/device, master/slave model associated with them. It make perfectly good sense to think of them as buses that support device interfaces.</p><h2 id="i-o-expander" tabindex="-1">I/O Expander <a class="header-anchor" href="#i-o-expander" aria-label="Permalink to &quot;I/O Expander&quot;">​</a></h2><p>An I/O expander is device that interfaces with the MCU, usually via I2C, and provides additional discrete inputs and outputs. The same rules apply:</p><ul><li><strong>GPIOS are Board-Specific</strong>. Nothing in the system should now about GPIOs except for board specific logic. GPIOs can change from board-toboard. They can come and go. They can be replaced by GPIO expanders. Your (portable) application should not have any knowledge about how any discrete I/O is implemented on the board. There will never be GPIO drivers as a part of the NuttX architecture.</li><li><strong>Common Drivers are Board-Independent</strong>. Nor should common drivers (like those in <code>drivers/</code>) know anything about GPIOs. In ALL cases, the board specific implementation in the board directories creates a &quot;lower half&quot; driver and binds that &quot;lower half&quot; driver with an common &quot;upper half&quot; driver to initialize the driver. Only the board logic has any kind of GPIO knowledge; not the application and not the common &quot;upper half driver&quot;.</li><li><strong>I2C and SPI Drivers are Internal Bus Drivers</strong>. Similarly I2C and SPI drivers are not accessible to applications. These are NOT device drivers but are bus drivers. They should not be accessed directly by applications. Rather, again, the board-specific logic generates a &quot;lower half&quot; driver that provides a common I2C or SPI interface and binds that with an &quot;upper half&quot; driver to initialize the driver.</li></ul><p>None of those rules change if you use an I/O expander, things just get more convoluted.</p><h3 id="example-architecture" tabindex="-1">Example Architecture <a class="header-anchor" href="#example-architecture" aria-label="Permalink to &quot;Example Architecture&quot;">​</a></h3><p>Consider this case for some <code>&lt;board&gt;</code>:</p><ol><li>A discrete joystick is implemented as set of buttons: UP, DOWN, LEFT, RIGHT, and CENTER. The state of each the buttons is sensed as a GPIO input.</li><li>The GPIO button inputs go to I2C I/O expander at say, <code>drivers/ioexpander/myexpander.c</code>, and finally to</li><li>The discrete joystick driver &quot;upper half&quot; driver (<code>drivers/input/djoystick.c</code>).</li></ol><h3 id="implementation-details" tabindex="-1">Implementation Details <a class="header-anchor" href="#implementation-details" aria-label="Permalink to &quot;Implementation Details&quot;">​</a></h3><p>These should be implemented in the following, flexible, portable, layered architecture:</p><ol><li><p>In the end, the application would interact only with a joystick driver interface via standard open/close/read/ioctl operations. It would receive pjoystick information as described in <code>include/nuttx/input/djoystick.h.</code></p></li><li><p>The discrete joystick driver would have been initialized by logic in some file like <code>boards/&lt;arch&gt;/xyz/&lt;board&gt;/src/xyz_djoystick.c</code> when the system was initialized. <code>zyz_joystick.c</code> would have created instance of the <code>struct djoy_lowerhalf_s</code> &quot;lower half&quot; interface as described in <code>nuttx/include/nuttx/input/djoystick.h</code> and would have passed that interface instance to the <code>drivers/input/djoystick.c</code> &quot;upper half&quot; driver to initialize it.</p></li><li><p>As part of the creation of the <code>struct djoy_lowerhalf_s</code> &quot;lower half&quot; interface instance, logic in <code>xyz_djoystick.c</code> would have done the following: It would have created an I2C driver instance by called MCU specific I2C initialization logic then passed this I2C driver instance to the I/O expander initialization interface in <code>drivers/ioexpander/myexpander.c</code> to create the I/O expander interface instance.</p><p>Note that the I/O expander interface should NOT be a normal character driver. It should NOT be accessed via open/close/read/write/ioctl. Rather, it should return an instance of a some <code>struct ioexpander_s</code> interface. That I/O expander interface would be described in <code>nuttx/include/ioexpander/ioexpander.h</code>. It is an internal operating system interface and would never be available to application logic.</p><p>After receiving the I/O expander interface instance, the &quot;lower half&quot; discrete joystick interface would retain this internally as private data. Nothing in the system other than this &quot;lower half&quot; discrete joystick driver needs to know how the joystick is connected on board.</p></li><li><p>After creating the &quot;upper half&quot; discrete joystick interface interface, the &quot;lower half&quot; discrete joystick interface would enable interrupts from the I/O expander device.</p></li><li><p>When a key is pressed, the &quot;lower half&quot; discrete joystick driver would receive an interrupt from the I/O expander. It would then interact with the I/O driver to obtain the current discrete button depressions. The I/O expander driver would interact with I2C to obtain those button settings. Then the discrete joystick interface callback will be called, providing the discrete joystick &quot;upper half&quot; driver with the joystick input.</p></li><li><p>The &quot;upper half&quot; discrete joystick character driver would then return the encoded joystick input to the application in response to a <code>read()</code> from application code.</p></li></ol>',34)]))}const v=t(o,[["render",s]]);export{p as __pageData,v as default};
