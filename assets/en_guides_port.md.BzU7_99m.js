import{_ as t,c as o,al as r,o as i}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"How to port","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/port.md","filePath":"en/guides/port.md"}'),a={name:"en/guides/port.md"};function n(s,e,d,p,l,h){return i(),o("div",null,e[0]||(e[0]=[r('<h1 id="how-to-port" tabindex="-1">How to port <a class="header-anchor" href="#how-to-port" aria-label="Permalink to &quot;How to port&quot;">​</a></h1><p>This guide explains &quot;How to port NuttX&quot;.</p><p>At this guide, the scope of porting is adding a new SoC or board directory, which can be built and has a working example that boots to the NuttShell (NSH).</p><p>The goal of porting is to confirm the booting NuttShell(NSH), the pass of &quot;ostest&quot; and the timer.</p><p>Porting a new SoC and board to NuttX requires modifications on arch, SoC and board directories. For the details, see [[/quick](]{.title-ref}/quick.md)start/organization`, [[/component](]{.title-ref}/component.md)s/arch/index`, [[/component](]{.title-ref}/component.md)s/boards`.</p><p>To port NuttX properly, we have to understand the boot sequence and related kernel configurations. Following links explain them, although these depend on specific kernel version and configurations. (To understand them, we have to read the code deeply.)</p><p>About the implementation, the build system tells you minimal implementation of SoC/Board directory, these implementations are almost done by copying and pasting from other SoC/Board directory if there is the source code for the target HW IP in upstream. If there is not the source code in upstream, the porter has to implement it by himself.</p><h2 id="porting-procedure" tabindex="-1">Porting procedure <a class="header-anchor" href="#porting-procedure" aria-label="Permalink to &quot;Porting procedure&quot;">​</a></h2><p>At first, you have to read and execute [[/quick](]{.title-ref}/quick.md)start/install` and [[/quick](]{.title-ref}/quick.md)start/compiling_make`. After that, try following procedure.</p><hr><p>Step Process Comment</p><p>1 Add the SoC</p><p>2 Add the If the board was not sold in the market, the board directory should be Board located out-of-tree. For details see [[/guide](]{.title-ref}/guide.md)s/customboards`. And if you wanted to add own apps, see [[/guide](]{.title-ref}/guide.md)s/customapps`.</p><p>3 Configure The configure needs to understand related kernel configurations. see [[/guide](]{.title-ref}/guide.md)s/port_relatedkernelconfigrations`.</p><p>4 Compile The compile tells you which source files are needed in SoC/Board directory to pass the compile.</p><p>5 Link The link tells you which symbols are needed in SoC/Board directory to pass the link.</p><p>6 Implement Do implement the symbols which are needed by the link.</p><p>7 Verify Do &quot;apps/testing/ostest&quot;. I think the pass of ostest is the one of proof for proper porting. And check the timer implementation whether the kernel could count the time accurately or not.</p><hr><h2 id="porting-case-studies" tabindex="-1">Porting Case Studies <a class="header-anchor" href="#porting-case-studies" aria-label="Permalink to &quot;Porting Case Studies&quot;">​</a></h2><p>These porting guides depend on specific kernel versions, as some code structures have changed over time. They will still provide a general idea on how to port.</p><blockquote><p>porting-case-studies/*</p></blockquote>',22)]))}const m=t(a,[["render",n]]);export{u as __pageData,m as default};
