import{_ as o,c as i,al as t,o as c}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"Naming and Header File Conventions","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/os/conventions.md","filePath":"en/reference/os/conventions.md"}'),r={name:"en/reference/os/conventions.md"};function n(a,e,d,s,l,h){return c(),i("div",null,e[0]||(e[0]=[t('<h1 id="naming-and-header-file-conventions" tabindex="-1">Naming and Header File Conventions <a class="header-anchor" href="#naming-and-header-file-conventions" aria-label="Permalink to &quot;Naming and Header File Conventions&quot;">​</a></h1><ul><li><p><strong>Common Microprocessor Interfaces</strong>. Any interface that is common to all microprocessors should be prefixed with <code>up_</code> and prototyped in <code>include/nuttx/arch.h</code>. The definitions in that header file provide the common interface between NuttX and the architecture-specific implementation in <code>arch/</code>.</p><blockquote><p><code>up_</code> is supposed to stand for microprocessor; the <code>u</code> is like the Greek letter micron: μ. So it would be <code>μP</code> which is a common shortening of the word microprocessor. I don&#39;t like that name very much. I wish I would have used a more obvious prefix like <code>arch_</code> instead -- then I would not have to answer this question so often.</p></blockquote></li><li><p><strong>Microprocessor-Specific Interfaces</strong>. An interface which is unique to a certain microprocessor should be prefixed with the name of the microprocessor, for example <code>stm32_</code>, and be prototyped in some header file in the <code>arch/</code> directories.</p><p>There is also a <code>arch/&lt;architecture&gt;/include/&lt;chip&gt;/chip.h</code> header file that can be used to communicate other microprocessor-specific information between the board logic and even application logic. Application logic may, for example, need to know specific capabilities of the chip. Prototypes in that <code>chip.h</code> header file should follow the microprocessor-specific naming convention.</p></li><li><p><strong>Common Board Interfaces</strong>. Any interface that is common to all boards should be prefixed with <code>board_</code> and should also be prototyped in <code>include/nuttx/board.h</code>. These <code>board_</code> definitions provide the interface between the board-level logic and the commaon and architecture-specific logic.</p></li><li><p><strong>Board-Specific Interfaces</strong>. Any interface which is unique to a board should be prefixed with the board name, for example <code>stm32f4discovery_</code>. Sometimes the board name is too long so <code>stm32_</code> would be okay too. These should be prototyped in <code>boards/&lt;arch&gt;/&lt;chip&gt;/&lt;board&gt;/src/&lt;board&gt;.h</code> and should not be used outside of that directory since board-specific definitions have no meaning outside of the board directory.</p></li><li><p><strong>Scope of Inclusions</strong>. Header files are made accessible to internal OS logic and to applications through symbolic links and through <em>include paths</em> that are provided to the C/C++ compiler. Through these include paths, the NuttX build system also enforces modularity in the design. For example, one important design principle is architectural <em>layering</em>. In this case I am referring to the OS as layered into application interface, common internal OS logic, and lower level platform-specific layers. The platform-specific layers all reside in the either <code>arch/</code> sub-directories or the <code>boards/</code> subdirectories: The former sub-directories are reserved for microcontroller-specific logic and the latter for board-specific logic.</p><p>In the strict, layered NuttX architecture, the upper level OS services are always available to platform-specific logic. However, the opposite is <em>not</em> true: Common OS logic must never have any dependency on the lower level platform-specific code. The OS logic must be totally agnostic about its hardware environment. Similarly, microcontroller-specific logic was be completely ignorant of board-specific logic.</p><p>This strict layering is enforced in the NuttX build system by controlling the compiler include paths: Higher level code can never include header files from either of the platform-specific source directories; microcontroller-specific code can never include header files from the board-specific source directories. The board-specific directories are, then, at the bottom of the layered hierarchy.</p><p>An exception to these inclusion restrictions is the platform-specific <em>include/</em>. These are made available to higher level OS logic. The microcontroller-specific include directory will be linked at <code>include/arch/chip</code> and, hence, can be included like <code>#include &lt;arch/hardware/chip.h</code>. Similarly, the board-specific include directory will be linked at <code>include/arch/board</code> and, hence, can be included like <code>#include &lt;arch/board/board.h</code>.</p><p>Keeping in the spirit of the layered architecture, these publicly visible header files must <em>not</em> export platform-specific definitions; Only platform-specific realizations of standardized declarations should be visible. Those <em>standardized declarations</em> should appear in common header files such as those provided by <code>include/nuttx/arch.h</code> and <code>include/nuttx/board.h</code>. Similarly, these publicly visible header file must <em>not</em> include files that reside in the inaccessible platform-specific source directories. For example, the board-specific <code>boards/&lt;arch&gt;/&lt;chip&gt;/&lt;board&gt;/include/board.h</code> header file must never include microcontroller-specific header files that reside in <code>arch/&lt;arch&gt;/src/&lt;mcu&gt;</code>. That practice will cause inclusion failures when the publicly visible file is included in common logic outside of the platform-specific source directories.</p></li></ul>',2)]))}const f=o(r,[["render",n]]);export{m as __pageData,f as default};
