import{_ as t,c as a,al as o,o as n}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"README","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/max326xx/boards/max32660-evsys/README.md","filePath":"en/platforms/arm/max326xx/boards/max32660-evsys/README.md"}'),r={name:"en/platforms/arm/max326xx/boards/max32660-evsys/README.md"};function i(s,e,d,l,h,c){return n(),a("div",null,e[0]||(e[0]=[o(`<h1 id="readme" tabindex="-1">README <a class="header-anchor" href="#readme" aria-label="Permalink to &quot;README&quot;">​</a></h1><p>This directory holds NuttX board support for the Maxim Integrated MAX32660-EVSYS board. That board features:</p><p>o MAX32660 Microcontroller - Arm Cortex-M4F, 96MHz - 256KB Flash Memory</p><ul><li>96KB SRAM - 16KB Instruction Cache - Two SPIs - Two I2Cs - Two UARTs - 14 GPIOs o DIP Breakout Board - 100mil Pitch Dual Inline Pin Headers - Breadboard Compatible o Integrated Peripherals - Red Indicator LED - User Pushbutton o MAX32625PICO-Based Debug Adapter - CMSIS-DAP SWD Debugger - Virtual UART Console</li></ul><h1 id="contents" tabindex="-1">Contents <a class="header-anchor" href="#contents" aria-label="Permalink to &quot;Contents&quot;">​</a></h1><p>o Status o Serial Console o LEDs and Buttons o OpenOCD</p><h1 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h1><p>2018-11-21: The port is code complete but completely untested. I am still waiting to receive hardware to perform the bringup. This initial port will support an NSH console: Clock configuration, timer, GPIO pin configuration, ICC, and UART. Additional untested drivers are complete and ready for testing: DMA, GPIO interrupts, RTC, WDT. The following drivers are not implemented: I2C, SPI, I2S. 2018-11-27: I received the MAX32660-EVSYS today and made a little debug progress. Added a run-from-SRAM configuration to keep from locking up the board on bad configurations. The rest of the bring-up will use this SRAM configuration. The NSH prompt comes up, but there is some interrupt-related problem that makes the console unusable. 2018-11-28: Found that the WFI instruction in the IDLE loop was causing instability. System ran OK until it was in IDLE then it became unstable. Commenting out the WIF restores stability. The port now runs safely from FLASH although still with missing UART interrupts. Also fixed the on-board LED which now currently reflects the state. 2018-11-29: Resolved the UART interrupt issue. The NSH configuration now appears fully functional. Removed EXPERIMENTAL from configuration. Brought in the STM32 SPI driver as a starting point. It still does not build correctly. Due to conflicts, only SPI0 will be available. 2018-11-30: Completed coding of the SPI driver. Added board support for SPI and for and SPI-based micro-SD card. Initial testing with no device attached shows that the first single byte SPI transfer hangs with 1 byte in the Tx FIFO and nothing in the Rx FIFO. Data is not moving.</p><p>I need to stop and work on some other things for a while. Here are the things remaining to be done:</p><ul><li>Test the DMA, WDT and RTC drivers. These drivers are complete but untested.</li><li>Finish verification of the SPI0 master driver. It currently hangs as described above.</li><li>Add support for missing drivers.</li></ul><p>Missing drivers include:</p><ul><li>SPI17Y: SPI0 master DMA support, SPI0 Slave</li><li>SPIMSS: SPI1 master/slave, I2C</li><li>I2C0/1 master/slave</li><li>Timer/PWM</li></ul><h1 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h1><p>UART1 Tx and Rx signals at port P0.10 and P0.11 are connected to the programming and debug header JH2 pins 2 and 3 through 1kΩ resistors. This provides a convenient way to communicate with a PC though the virtual serial port available in Maxim&#39;s CMSIS-DAP debug adapter. The series resistors allow for these signals to be overdriven by other circuits without modifying the board.</p><h1 id="leds-and-buttons" tabindex="-1">LEDs and Buttons <a class="header-anchor" href="#leds-and-buttons" aria-label="Permalink to &quot;LEDs and Buttons&quot;">​</a></h1><h2 id="leds" tabindex="-1">LEDs <a class="header-anchor" href="#leds" aria-label="Permalink to &quot;LEDs&quot;">​</a></h2><p>A single red LED is available driven by GPIO P0.13.</p><p>This LED is not used by the board port unless CONFIG_ARCH_LEDS is defined. In that case, the usage by the board port is defined in include/board.h and src/sam_autoleds.c. The LED is used to encode OS-related events as follows:</p><pre><code>------------------- ----------------------- ------
SYMBOL              Meaning                 LED
------------------- ----------------------- ------
LED_STARTED         NuttX has been started  OFF
LED_HEAPALLOCATE    Heap has been allocated OFF
LED_IRQSENABLED     Interrupts enabled      OFF
LED_STACKCREATED    Idle stack created      ON
LED_INIRQ           In an interrupt         N/C
LED_SIGNAL          In a signal handler     N/C
LED_ASSERTION       An assertion failed     N/C
LED_PANIC           The system has crashed  FLASH
</code></pre><p>Thus if the LED is statically on, NuttX has successfully booted and is, apparently, running normally. If the LED is flashing at approximately 2Hz, then a fatal error has been detected and the system has halted.</p><h2 id="buttons" tabindex="-1">Buttons <a class="header-anchor" href="#buttons" aria-label="Permalink to &quot;Buttons&quot;">​</a></h2><p>An single button is available on GPIO P0.12 for use by software.</p><h1 id="openocd" tabindex="-1">OpenOCD <a class="header-anchor" href="#openocd" aria-label="Permalink to &quot;OpenOCD&quot;">​</a></h1><h2 id="starting-openocd" tabindex="-1">Starting OpenOCD <a class="header-anchor" href="#starting-openocd" aria-label="Permalink to &quot;Starting OpenOCD&quot;">​</a></h2><p>An Eclipse based toolchain is available for download from Maxim Integrated. If you (like me) are not an IDE user then the good news is the OpenOCD for the MAX32660 is available within that toolchain.</p><p>As of this writing, the OpenOCD changes for the MAX32660 are not yet incorporated into the mainline OpenOCD code so the Maxim Integrated version within the Eclipse-based toolchain is the only show in town. Patches for the MAX32660 have been submitted and this will most likely no longer be true as you read this.</p><p>The Eclipse-based toolchain installs by default at C:<code>\\Maxim </code>under Windows. The following script tracks tracks down OpenOCD in that installation (assuming Cygwin, hence the /cygdrive/c for the C: drive:</p><pre><code>#!/bin/sh

set -x

OPENOCD=/cygdrive/c/Maxim/Toolchain/bin/openocd.exe
IFCFG=&quot;C:\\Maxim\\Toolchain\\share\\openocd\\scripts\\interface\\max32660_hdk.cfg&quot;
MCUCFG=&quot;C:\\Maxim\\Toolchain\\share\\openocd\\scripts\\target\\max32660.cfg&quot;

\${OPENOCD} \${1} -f \${IFCFG} # -f \${MCUCFG}
</code></pre><p>Loading Code:</p><p>Code can be loaded into FLASH using the convenient ARM MBED drag&#39;n&#39;drop interface. Or it can be loaded into FLASH (or SRAM) using GDB as follows:</p><p>$ arm-none-eabi-gdb (gdb) target remote localhost:3333 (gdb) mon reset (gdb) mon halt (gdb) load nuttx</p><p>This does not work so reliably for me, however.</p><p>Debugging from FLASH:</p><p>$ arm-none-eabi-gdb (gdb) target remote localhost:3333 (gdb) mon reset (gdb) mon reg pc __start # Set PC to __start entry point (gdb) file nuttx (gdb) b nx_start (gdb) c</p><p>Also not very reliable.</p><p>Debugging from SRAM:</p><p>Same except (1) that the __start entry point is 0x2000011c, not 0x11c, and the code needs to be reloaded into SRAM each time:</p><p>(gdb) target remote localhost:3333 (gdb) mon reset (gdb) mon halt (gdb) load nuttx # Re-load code into SRAM (gdb) mon reg pc __start # Set PC to __start entry point (gdb) file nuttx (gdb) b nx_start (gdb) c</p><p>Recovering from bad code in FLASH:</p><p>In my initial debug effort, I had a lethal bug that I thought had bricked the board. It appears that initialization logic put the MAX32660 in a bad state so that every time that I reset the board, I would re-enter this same bad state and I could not connect the CMSIS-DAP debugger.</p><p>I was able to recover. I jumpered GND to RSTn the used the MBED MSC interface to copy a known safe &#39;SysTick&#39; demo program. The copy hung and timed out with an error message. I yanked the jumper off RSTn and asked to re-try copy. It continued to burn the safe code demo! I fixed it! too much drama.</p>`,41)]))}const b=t(r,[["render",i]]);export{u as __pageData,b as default};
