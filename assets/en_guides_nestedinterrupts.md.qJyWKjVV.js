import{_ as n,c as s,al as t,o as a}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Nested Interrupts","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/nestedinterrupts.md","filePath":"en/guides/nestedinterrupts.md"}'),r={name:"en/guides/nestedinterrupts.md"};function i(l,e,o,p,c,d){return a(),s("div",null,e[0]||(e[0]=[t(`<h1 id="nested-interrupts" tabindex="-1">Nested Interrupts <a class="header-anchor" href="#nested-interrupts" aria-label="Permalink to &quot;Nested Interrupts&quot;">​</a></h1><h2 id="are-nested-interrupts-needed" tabindex="-1">Are Nested Interrupts Needed? <a class="header-anchor" href="#are-nested-interrupts-needed" aria-label="Permalink to &quot;Are Nested Interrupts Needed?&quot;">​</a></h2><p>Most NuttX architectures do not support nested interrupts: Interrupts are disabled when the interrupt is entered and restored when the interrupt returns. Being able to handle nested interrupt is critical in simple architectures where a lot of interrupt level processing is performed: In this case, you can prioritize interrupts and assure that the highest priority interrupt processing is not delayed by lower level interrupt processing.</p><p>In an RTOS model, however, all interrupt processing should be as brief as possible; any extended processing should be deferred to a user task and not performed in the interrupt handler. However, you may find a need to have nested interrupt handling in NuttX too. The lack of support of nested interrupts is not inherently an issue with NuttX and need not be the case; it should be a simple matter to modify the interrupt handling so that interrupts are nested.</p><h2 id="layered-interrupt-handling-architecture" tabindex="-1">Layered Interrupt Handling Architecture <a class="header-anchor" href="#layered-interrupt-handling-architecture" aria-label="Permalink to &quot;Layered Interrupt Handling Architecture&quot;">​</a></h2><p>Interrupt handling occurs in several files. In most implementations, there are several layers of interrupt handling logic:</p><ol><li>Some low-level logic, usually in assembly language, that catches the interrupt and determines the IRQ number. Consider <code>arch/arm/src/armv7-m/up_exception.S</code> as an example for the Cortex-M family.</li><li>That low-level logic than calls some MCU-specific, intermediate level function usually called <code>up_doirq()</code>. An example is <code>arch/arm/src/armv7-m/up_doirq.c</code>.</li><li>That MCU-specific function then calls the NuttX common interrupt dispatching logic <code>irq_dispatch()</code> that can be found at <code>sched/irq_dispatch.c</code>.</li></ol><h2 id="how-to-implement-nested-interrupts-in-the-layered-interrupt-handling-architecture" tabindex="-1">How to Implement Nested Interrupts in the Layered Interrupt Handling Architecture <a class="header-anchor" href="#how-to-implement-nested-interrupts-in-the-layered-interrupt-handling-architecture" aria-label="Permalink to &quot;How to Implement Nested Interrupts in the Layered Interrupt Handling Architecture&quot;">​</a></h2><p>The logic in these first two levels that would have to change to support nested interrupt handling. Here is one technical approach to do that:</p><ol><li>Add a global variable, say <code>g_nestlevel</code>, that counts the interrupt nesting level. It would have an initial value of zero; it would be incremented on each interrupt entry and decremented on interrupt exit (making sure that interrupts are disabled in each case because incrementing and decrementing are not usually atomic operations).</li><li>At the lowest level, there is usually some assembly language logic that will switch from the user&#39;s stack to a special interrupt level stack. This behavior is controlled <code>CONFIG_ARCH_INTERRUPTSTACK</code>. The logic here would have to change in the following way: If <code>g_nestlevel</code> is zero then behave as normal, switching from the user to the interrupt stack; if <code>g_nestlevel</code> is greater than zero, then do not switch stacks. In this latter case, we are already using the interrupt stack.</li><li>In the middle-level, MCU-specific is where the <code>g_nestlevel</code> would be increment. And here some additional decision must be made based on the state of <code>g_nestlevel</code>. If <code>g_nestlevel</code> is zero, then we have interrupted user code and we need to handle the context information specially and handle interrupt level context switches. If <code>g_nestlevel</code> is greater than zero, then the interrupt handler was interrupt by an interrupt. In this case, the interrupt handling must always return to the interrupt handler. No context switch can occur here. No context switch can occur until the outermost, nested interrupt handler returns to the user task.</li><li>You would also need to support some kind of critical section within interrupt handlers to prevent nested interrupts. For example, within the logic of functions like <code>up_block_task()</code>. Such logic must be atomic in any case.</li></ol><p><strong>NOTE 1</strong>: The ARMv7-M could also be configured to use separate MSP and PSP stacks with the interrupt processing using the MSP stack and the tasks all using the PSP stacks. This is not compatible with certain parts of the existing design and would be more effort, but could result in a better solution.</p><p><strong>NOTE 2</strong>: SMP has this same issue as 2 but it is addressed differently: With SMP there is an array of stacks indexed by the CPU number so that all CPUs get to have an interrupt stack. See for example, <a href="https://bitbucket.org/nuttx/nuttx/src/ca4ef377fb789ddc3e70979b28acb6730ff6a98c/arch/arm/src/lc823450/chip.h" target="_blank" rel="noreferrer">LC823450</a> or <a href="https://bitbucket.org/nuttx/nuttx/src/ca4ef377fb789ddc3e70979b28acb6730ff6a98c/arch/arm/src/imx6/chip.h" target="_blank" rel="noreferrer">i.MX6</a> SMP logic.</p><p>A generic <code>up_doirq()</code> might look like the following. It can be very simple because interrupts are disabled:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uint32_t *up_doirq(int irq, uint32_t *regs)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  /* Current regs non-zero indicates that we are processing an interrupt;</span></span>
<span class="line"><span>   * current_regs is also used to manage interrupt level context switches.</span></span>
<span class="line"><span>   */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  current_regs = regs;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Deliver the IRQ */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  irq_dispatch(irq, regs);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* If a context switch occurred while processing the interrupt then</span></span>
<span class="line"><span>   * current_regs may have change value.  If we return any value different</span></span>
<span class="line"><span>   * from the input regs, then the lower level will know that a context</span></span>
<span class="line"><span>   * switch occurred during interrupt processing.</span></span>
<span class="line"><span>   */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  regs = (uint32_t*)current_regs;</span></span>
<span class="line"><span>  current_regs = NULL;</span></span>
<span class="line"><span>  return regs;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>What has to change to support nested interrupts is:</p><ol><li>If we are nested, then we must retain the original value of <code>current_regs</code>. This will be need when the outermost interrupt handler returns in order to handle interrupt level context switches.</li><li>If we are nested, then we need to always return the same value of <code>regs</code> that was received.</li></ol><p>So the modified version of <code>up_doirq()</code> would be as follows. Here we assume that interrupts are enabled.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uint32_t *up_doirq(int irq, uint32_t *regs)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  irqstate_t flags;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Current regs non-zero indicates that we are processing an interrupt;</span></span>
<span class="line"><span>   * regs holds the state of the interrupted logic; current_regs holds the</span></span>
<span class="line"><span>   * state of the interrupted user task.  current_regs should, therefore,</span></span>
<span class="line"><span>   * only be modified for outermost interrupt handler (when g_nestlevel == 0)</span></span>
<span class="line"><span>   */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  flags = irqsave();</span></span>
<span class="line"><span>  if (g_nestlevel == 0)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      current_regs = regs;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  g_nestlevel++</span></span>
<span class="line"><span>  irqrestore(flags);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Deliver the IRQ */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  irq_dispatch(irq, regs);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Context switches are indicated by the returned value of this function.</span></span>
<span class="line"><span>   * If a context switch occurred while processing the interrupt then</span></span>
<span class="line"><span>   * current_regs may have change value.  If we return any value different</span></span>
<span class="line"><span>   * from the input regs, then the lower level will know that a context</span></span>
<span class="line"><span>   * switch occurred during interrupt processing.  Context switching should</span></span>
<span class="line"><span>   * only be performed when the outermost interrupt handler returns.</span></span>
<span class="line"><span>   */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  flags = irqsave();</span></span>
<span class="line"><span>  g_nestlevel--;</span></span>
<span class="line"><span>  if (g_nestlevel == 0)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      regs = (uint32_t*)current_regs;</span></span>
<span class="line"><span>      current_regs = NULL;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Note that interrupts are left disabled.  This needed if context switch</span></span>
<span class="line"><span>   * will be performed.  But, any case, the correct interrupt state should</span></span>
<span class="line"><span>   * be restored when returning from the interrupt.</span></span>
<span class="line"><span>   */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return regs;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p><strong>NOTE:</strong> An alternative, cleaner design might also be possible. If one were to defer all context switching to a <em>PendSV</em> handler, then the interrupts could vector to the <code>do_irq()</code> logic and then all interrupts would be naturally nestable.</p><h2 id="svcall-vs-pendsv" tabindex="-1">SVCall vs PendSV <a class="header-anchor" href="#svcall-vs-pendsv" aria-label="Permalink to &quot;SVCall vs PendSV&quot;">​</a></h2><p>An issue that may be related to nested interrupt handling is the use of the <code>SVCall</code> exceptions in NuttX. The <code>SVCall</code> exception is used as a classic software interrupt in NuttX for performing context switches, user- to kernel-mode changes (and vice versa), and also for system calls when NuttX is built as a kernel.</p><p><code>SVCall</code> exceptions are never performed from interrupt level, handler mode processing; only from thread mode logic. The <code>SVCall</code> exception is used as follows to perform the system call:</p><ul><li>All interrupts are disabled: There are a few steps the must be performed in a critical section. Those setups and the <code>SVCall</code> must work as a single, uninterrupted atomic action.</li><li>A special register setup is put in place: Parameters are passed to the <code>SVCall</code> in registers just as with a normal function call.</li><li>The Cortex SVC instruction is executed. This causes the <code>SVCall</code> exception which is dispatched to the <code>SVCall</code> exception handler. This exception must occur while the input register setup is in place; it cannot be deferred and perform at some later time. The <code>SVCall</code> exception handler decodes the registers and performs the requested operation. If no context switch occurs, the <code>SVCall</code> will return to the caller immediately.</li><li>Upon return interrupts will be re-enabled.</li></ul><p>So what does this have to do with nested interrupt handling? Since interrupts are disabled throughout the <code>SVCall</code> sequence, nothing really. However, there are some concerns because if the <code>BASEPRI</code> is used to disable interrupts then the <code>SVCall</code> exception must have the highest priority: The <code>BASEPRI</code> register is set to disable all interrupt except for the <code>SVCall</code>.</p><p>The motivation for supporting nested interrupts is, presumably, to make sure that certain high priority interrupts are not delayed by lower processing interrupt handling. Since the <code>SVCall</code> exception has highest priority, it will delay all other interrupts (but, of course, disabling interrupt also delays all other interrupts).</p><p>The PendSV exception is another mechanism offered by the Cortex architecture. It has been suggested that some of these issues with the <code>SVCall</code> exception could be avoided by using the PendSV interrupt. The architecture that would use the PendSV exception instead of the <code>SVCall</code> interrupt is not clear in my mind. But I will keep this note here for future reference if this were to become as issue.</p><h2 id="what-could-go-wrong" tabindex="-1">What Could Go Wrong? <a class="header-anchor" href="#what-could-go-wrong" aria-label="Permalink to &quot;What Could Go Wrong?&quot;">​</a></h2><p>Whenever you deal with logic at software hardware interface, lots of things can go wrong. But, aside from that general risk, the only specific NuttX risk issue is that you may uncover some subtle interrupt level logic that assumes that interrupts are already disabled. In those cases, additional critical sections may be needed inside of the interrupt level processing. The likelihood of such a thing is probably pretty low, but cannot be fully discounted.</p>`,28)]))}const g=n(r,[["render",i]]);export{u as __pageData,g as default};
