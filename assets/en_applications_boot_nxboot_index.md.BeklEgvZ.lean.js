import{_ as s,c as t,j as e,a,al as i,o}from"./chunks/framework.NFAqBSgQ.js";const b=JSON.parse('{"title":"nxboot NuttX Bootloader","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/boot/nxboot/index.md","filePath":"en/applications/boot/nxboot/index.md"}'),r={name:"en/applications/boot/nxboot/index.md"};function p(l,n,d,c,h,u){return o(),t("div",null,n[0]||(n[0]=[e("h1",{id:"nxboot-nuttx-bootloader",tabindex:"-1"},[e("code",null,"nxboot"),a(" NuttX Bootloader "),e("a",{class:"header-anchor",href:"#nxboot-nuttx-bootloader","aria-label":'Permalink to "`nxboot` NuttX Bootloader"'},"​")],-1),e("p",null,"NuttX Bootloader (nxboot) can be used to provide update and recovery capabilities for NuttX based devices. The bootloader implements an algorithm that uses three partitions/areas: primary, secondary and tertiary. Primary area is used to run the image and thus is usually located in a program memory. Secondary and tertiary areas are used to store update image or recovery image and can be located on external flash memory for example.",-1),e("p",null,"The images for the bootloader have version located in their headers. Note that bootloader/image characteristics may differ for different version and a portable application should take this into account.",-1),e("h2",{id:"algorithm-description",tabindex:"-1"},[a("Algorithm Description "),e("a",{class:"header-anchor",href:"#algorithm-description","aria-label":'Permalink to "Algorithm Description"'},"​")],-1),e("p",null,"The update is performed with a simple copy from update area to primary area with recovery being created in recovery area if not already present. Once image is confirmed by the user, the image in update area is confirmed as well, update area becomes recovery area and vice versa. This means the recovery is always present (except for the first update) and subsequent updates just copy image from update to primary. This makes the update significantly faster and more considerable to flash wear while keeping the recovery/revert possibility.",-1),e("p",null,"Not confirmed image is reverted to recovery image if reboot occurs.",-1),e("p",null,[a("The bootable image consists of a header :c"),e("code",{class:"interpreted-text",role:"struct"},"nxboot_img_header"),a(" containing magic value, header version, header size, CRC32 of the image including some parts of the header, size of the image excluding the header, platform identifier, pointer to extended headers and and firmware version. The header is located prior to the image itself and has a configurable size "),e("code",null,"CONFIG_NXBOOT_HEADER_SIZE"),a(". The CRC is calculated from the entire image including header except for magic, header version and header size fields. Extended headers are currently not supported, but the header already has a reserved space for a pointer to it.")],-1),e("p",null,"The image compatible with nxboot bootloader can be uploaded both directly to the primary area via physical programmer as STlink or JTAG and to the update partition via some external application (over Ethernet, USB, CAN, etc.). The update and recovery slots can be located in the the primary flash as well, but this halts the program execution during write operations, so it is not recommended if external flash can be used. The uploaded image is detected by the bootloader during the next boot and update occurs.",-1),e("p",null,[a("Bootloader has an internal magic value that is used to detect updated images. Once update occurs, the image is copied from update to primary partition with the internal magic value and the first erase page of the update slot is erased. The image with internal magic value is considered valid only if its recovery exists, therefore the image confirmation is done by writing the first erase page (copying by write page size from primary) back to the update slot. It is recommended to use :c"),e("code",{class:"interpreted-text",role:"func"},"nxboot_confirm"),a(" API to confirm the image. This approach wears the first sector of the update partition a bit more, but avoids image's tails completely and simplifies both internal and API logic.")],-1),e("p",null,[a("The application can use function :c"),e("code",null,"nxboot_get_state"),a('{.interpreted-text role="func"} to determine what partition is update and recovery and thus where the update image should be stored. It is also possible to use function :c'),e("code",{class:"interpreted-text",role:"func"},"nxboot_open_update_partition"),a(" that determines the correct partition for updates and returns the opened file descriptor. This is a recommended approach as it avoids possible mistakes.")],-1),i("",35)]))}const g=s(r,[["render",p]]);export{b as __pageData,g as default};
