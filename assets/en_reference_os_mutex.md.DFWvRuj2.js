import{_ as t,c as i,al as a,o as r}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"Mutual Exclusion lock","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/os/mutex.md","filePath":"en/reference/os/mutex.md"}'),n={name:"en/reference/os/mutex.md"};function s(o,e,l,h,u,c){return r(),i("div",null,e[0]||(e[0]=[a('<h1 id="mutual-exclusion-lock" tabindex="-1">Mutual Exclusion lock <a class="header-anchor" href="#mutual-exclusion-lock" aria-label="Permalink to &quot;Mutual Exclusion lock&quot;">​</a></h1><h2 id="nxmutex" tabindex="-1">nxmutex <a class="header-anchor" href="#nxmutex" aria-label="Permalink to &quot;nxmutex&quot;">​</a></h2><p>Use [nxmutex]{.title-ref} prefixed api to protect resources. In fact, nxmutex is implemented based on nxsem. The difference between nxmutex and nxsem is that nxmutex supports priority inheritance by default, nxsem do not support priority inheritance by default.</p><h3 id="typical-usage" tabindex="-1">Typical Usage <a class="header-anchor" href="#typical-usage" aria-label="Permalink to &quot;Typical Usage&quot;">​</a></h3><p>Call nxmutex_init() for driver, when two tasks will use driver, their timing will be:</p><p>taskA taskB</p><hr><p>nxmutex_lock() nxmutex_lock() get lock running wait for lock nxmutex_unlock() wait for lock - get lock running - nxmutex_unlock()</p><h2 id="priority-inheritance" tabindex="-1">Priority inheritance <a class="header-anchor" href="#priority-inheritance" aria-label="Permalink to &quot;Priority inheritance&quot;">​</a></h2><p>If [CONFIG_PRIORITY_INHERITANCE]{.title-ref} is chosen, the priority of the task holding the mutex may be changed. This is an example:</p><blockquote><p class="title-ref">There are three tasks. Their priorities are high, medium, and low. We refer to them as [Htask]{.title-ref} [Mtask]{.title-ref} [Ltask]</p><p>[Htask]{.title-ref} and [Ltask]{.title-ref} will hold the same mutex. [Mtask]{.title-ref} does not hold mutex</p></blockquote><p>if [CONFIG_PRIORITY_INHERITANCE]{.title-ref} is not chosen, task running order</p><p>: 1. [Ltask]{.title-ref} hold a mutex first 2. Then [Htask]{.title-ref} running, [Htask]{.title-ref} can&#39;t hold the mutex,so wait 3. Then [Mtask]{.title-ref} running, because [Mtask]{.title-ref} priority higher than [Ltask]{.title-ref}. 4. When [Mtask]{.title-ref} finish, [Ltask]{.title-ref} will start running. 5. When [Ltask]{.title-ref} finish, [Htask]{.title-ref} will start running.</p><p>From the above process, we can see that the medium-priority tasks run ahead of the high-priority tasks, which is unacceptable.</p><p>if [CONFIG_PRIORITY_INHERITANCE]{.title-ref} is chosen, task running order</p><p class="title-ref">: 1. [Ltask]{.title-ref} hold a mutex first. 2. Then [Htask]{.title-ref} running, [Htask]{.title-ref} can&#39;t hold the mutex, then boost the priority of [Ltask]</p><p>to be the same as [Htask]{.title-ref}.</p><p>: 1. Because [Ltask]{.title-ref} priority is higher than [Mtask]{.title-ref},so [Mtask]{.title-ref} not running. 2. When &#39;Ltask&#39; finish, [Htask]{.title-ref} will start running. 3. When [Htask]{.title-ref} finish, [Mtask]{.title-ref} will start running.</p><p>Priority inheritance prevents medium-priority tasks from running ahead of high-priority tasks</p><h2 id="api-description" tabindex="-1">Api description <a class="header-anchor" href="#api-description" aria-label="Permalink to &quot;Api description&quot;">​</a></h2>',20)]))}const k=t(n,[["render",s]]);export{f as __pageData,k as default};
