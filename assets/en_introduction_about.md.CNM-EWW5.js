import{_ as t,c as i,al as o,o as l}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"About Apache NuttX","description":"","frontmatter":{},"headers":[],"relativePath":"en/introduction/about.md","filePath":"en/introduction/about.md"}'),a={name:"en/introduction/about.md"};function r(s,e,n,d,u,c){return l(),i("div",null,e[0]||(e[0]=[o('<h1 id="about-apache-nuttx" tabindex="-1">About Apache NuttX <a class="header-anchor" href="#about-apache-nuttx" aria-label="Permalink to &quot;About Apache NuttX&quot;">​</a></h1><p>NuttX is a real time embedded operating system (RTOS). Its goals are:</p><ul><li><p><strong>Small Footprint</strong> Usable in all but the tightest micro-controller environments, the focus is on the tiny-to-small, deeply embedded environment.</p></li><li><p><strong>Rich Feature OS Set</strong> The goal is to provide implementations of most standard POSIX OS interfaces to support a rich, multi-threaded development environment for deeply embedded processors.</p><p>NON-GOALS: It is not a goal to provide the level of OS features like those provided by Linux. In order to work with smaller MCUs, small footprint must be more important than an extensive feature set. But standard compliance is more important than small footprint. Surely a smaller RTOS could be produced by ignoring standards. Think of NuttX is a tiny Linux work-alike with a much reduced feature set.</p></li><li><p><strong>Highly Scalable</strong> Fully scalable from tiny (8-bit) to moderate embedded (64-bit). Scalability with rich feature set is accomplished with: Many tiny source files, link from static libraries, highly configurable, use of weak symbols when available.</p></li><li><p><strong>Standards Compliance</strong> NuttX strives to achieve a high degree of standards compliance. The primary governing standards are POSIX and ANSI standards. Additional standard APIs from Unix and other common RTOS&#39;s are adopted for functionality not available under these standards or for functionality that is not appropriate for the deeply-embedded RTOS (such as <code>fork()</code>).</p><p>Because of this standards conformance, software developed under other standard OSs (such as Linux) should port easily to NuttX.</p></li><li><p><strong>Real-Time</strong> Fully pre-emptible; fixed priority, round-robin, and &quot;sporadic&quot; scheduling.</p></li><li><p><strong>Totally Open</strong> Non-restrictive Apache license.</p></li><li><p><strong>GNU Toolchains</strong> Compatible GNU toolchains based on <a href="http://buildroot.uclibc.org/" target="_blank" rel="noreferrer">buildroot</a> available for <a href="https://bitbucket.org/nuttx/buildroot/downloads/" target="_blank" rel="noreferrer">download</a> to provide a complete development environment for many architectures.</p></li></ul><h2 id="feature-set" tabindex="-1">Feature Set <a class="header-anchor" href="#feature-set" aria-label="Permalink to &quot;Feature Set&quot;">​</a></h2><p>Key features of NuttX include:</p><ul><li><strong>Standards Compliant Core Task Management</strong><ul><li>Fully pre-emptible.</li><li>Naturally scalable.</li><li>Highly configurable.</li><li>Easily extensible to new processor architectures, SoC architecture, or board architectures. [[/reference/o](]{.title-ref}/reference/o.md)s/index` is available.</li><li>FIFO and round-robin scheduling.</li><li>Realtime, deterministic, with support for priority inheritance</li><li>Tickless Operation</li><li>POSIX/ANSI-like task controls, named message queues, counting semaphores, clocks/timers, signals, pthreads, robust mutexes, cancellation points, environment variables, filesystem.</li><li>Standard default signal actions (optional).</li><li>VxWorks-like task management and watchdog timers.</li><li>BSD socket interface.</li><li>Extensions to manage pre-emption.</li><li>Optional tasks with address environments (<em>Processes</em>).</li><li>Loadable kernel modules; lightweight, embedded shared libraries.</li><li>Memory Configurations: (1) Flat embedded build, (2) Protected build with MPU, and (3) Kernel build with MMU.</li><li>Memory Allocators: (1) standard heap memory allocation, (2) granule allocator, (3) shared memory, and (4) dynamically sized, per-process heaps.</li><li>Inheritable &quot;controlling terminals&quot; and I/O re-direction.</li><li>Pseudo-terminals</li><li>On-demand paging.</li><li>System logging.</li><li>May be built either as an open, flat embedded RTOS or as a separately built, secure, monolithic kernel with a system call interface.</li><li>Built-in, per-thread CPU load measurements.</li><li>Well documented in the NuttX User Guide.</li></ul></li><li><strong>File system</strong><ul><li>Tiny, in-memory, root pseudo-file-system.</li><li>Virtual file system (VFS) supports drivers and mountpoints.</li><li>Mount-able volumes. Bind mountpoint, filesystem, and block device driver.</li><li>Generic system logging (SYSLOG) support.</li><li>FAT12/16/32 filesystem support with optional FAT long file name support1.</li><li>NFS Client. Client side support for a Network File System (NFS, version 3, UDP).</li><li>NXFFS. The tiny NuttX wear-leveling FLASH file system.</li><li>SMART. FLASH file system from Ken Pettit.</li><li>SPIFFS. FLASH file system, originally by Peter Anderson.</li><li>LittleFS. FLASH file system from ARM mbed..</li><li>ROMFS filesystem support (XIP capable).</li><li>CROMFS (Compressed ROMFS) filesystem support.</li><li>TMPFS RAM filesystem support.</li><li>BINFS pseudo-filesystem support.</li><li>HOSTFS filesystem support (simulation only).</li><li>Union filesystem - Supports combining and overlaying file systems.</li><li>UserFS - User application file system.</li><li><code>procfs/</code> pseudo-filesystem support.</li><li>[[/component](]{.title-ref}/component.md)s/binfmt` with support for the following formats: <ul><li>Separately linked ELF modules.</li><li>Separately linked [[/component](]{.title-ref}/component.md)s/nxflat` modules. NXFLAT is a binary format that can be XIP from a file system.</li><li>&quot;Built-In&quot; applications.</li></ul></li><li>PATH variable support.</li><li>File transfers via TFTP and FTP (<code>get</code> and <code>put</code>), HTML (<code>wget</code>), and Zmodem (<code>sz</code> and <code>rz</code>). Intel HEX file conversions. <ul><li>FAT long file name support may be subject to certain Microsoft patent restrictions if enabled. See the top-level <code>NOTICE</code> file for details.</li></ul></li></ul></li><li><strong>Device Drivers</strong><ul><li>Supports character and block drivers as well as specialized driver interfaces.</li><li>Full VFS integration. Asynchronous I/O (AIO)</li><li>Network, USB (host), USB (device), serial, I2C, I2S, NAND, CAN, ADC, DAC, PWM, Quadrature Encoder, I/O Expander, Wireless, generic timer, and watchdog timer driver architectures.</li><li>RAMDISK, pipes, FIFO, <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/random</code>, and loop drivers.</li><li>Generic driver for SPI-based or SDIO-based MMC/SD/SDH cards.</li><li>Graphics: framebuffer drivers, graphic- and segment-LCD drivers. VNC server.</li><li>Audio subsystem: CODECs, audio input and output drivers. Command line and graphic media player applications.</li><li>Cryptographic subsystem.</li><li>[[/component](]{.title-ref}/component.md)s/drivers/special/power/pm/index` sub-system.</li><li>ModBus support provided by built-in <a href="https://www.embedded-experts.at/en/freemodbus/" target="_blank" rel="noreferrer">FreeModBus</a> version 1.5.0.</li></ul></li><li><strong>C/C++ Libraries</strong><ul><li>Standard C Library Fully integrated into the OS.</li><li>Includes floating point support via a Standard Math Library.</li><li>Add-on <a href="http://cxx.uclibc.org/" target="_blank" rel="noreferrer">uClibc++</a> module provides Standard C++ Library (LGPL).</li></ul></li><li><strong>Networking</strong><ul><li>Multiple network interface support; multiple network link layer support.</li><li>IPv4, IPv6, TCP/IP, UDP, ICMP, ICMPv6, IGMPv2 and MLDv1/v2 (client) stacks.</li><li>IP Forwarding (routing) support.</li><li>User space stacks.</li><li>Stream and datagram sockets.</li><li>Address Families: IPv4/IPv6 (<code>AF_INET</code>/<code>AF_INET6</code>), Raw socket (<code>AF_PACKET</code>), raw IEEE 802.15.4 (<code>AF_IEEE802154</code>), raw Bluetooth (<code>AF_BLUETOOTH</code>), and local, Unix domain socket support (<code>AF_LOCAL</code>).</li><li>Special <code>INET</code> protocol sockets: Raw ICMP and ICMPv6 protocol ping sockets (<code>IPPROTO_ICMP</code>/<code>IPPROTO_ICMP6</code>).</li><li>Custom user sockets.</li><li>IP Forwarding.</li><li>DNS name resolution / NetDB</li><li>IEEE 802.11 FullMac</li><li>Radio Network Drivers: IEEE 802.15.4 MAC, Generic Packet Radio, Bluetooth LE</li><li>6LoWPAN for radio network drivers (IEEE 802.15.4 MAC and generic packet radios)</li><li>SLIP, TUN/PPP, Local loopback devices</li><li>A port cJSON</li><li>Small footprint.</li><li>BSD compatible socket layer.</li><li>Networking utilities (DHCP server and client, SMTP client, Telnet server and client, FTP server and client, TFTP client, HTTP server and client, PPPD, NTP client). Inheritable TELNET server sessions (as &quot;controlling terminal&quot;). VNC server.</li><li>ICMPv6 autonomous auto-configuration</li><li>NFS Client. Client side support for a Network File System (NFS, version 3, UDP).</li><li>A NuttX port of Jeff Poskanzer&#39;s <a href="http://acme.com/software/thttpd" target="_blank" rel="noreferrer">THTTPD</a> HTTP server integrated with the NuttX [[/component](]{.title-ref}/component.md)s/binfmt` to provide true, embedded CGI.</li><li>PHY Link Status Management.</li><li>UDP Network Discovery (Contributed by Richard Cochran).</li><li>XML RPC Server (Contributed by Richard Cochran).</li><li>Support for networking modules (e.g., ESP8266).</li></ul></li><li><strong>FLASH Support</strong><ul><li><em>MTD</em>-inspired interface for <em>M</em>emory <em>T</em>echnology <em>D</em>evices.</li><li>NAND support.</li><li><em>FTL</em>. Simple <em>F</em>lash <em>T</em>ranslation <em>L</em>ayer support file systems on FLASH.</li><li>Wear-Leveling FLASH File Systems: NXFFS, SmartFS, SPIFFS.</li><li>Support for SPI-based FLASH and FRAM devices.</li></ul></li><li><strong>USB Host Support</strong><ul><li>USB host architecture for USB host controller drivers and device-dependent USB class drivers.</li><li>USB host controller drivers available for the Atmel SAMA5Dx, NXP LPC17xx, LPC31xx, and STmicro STM32</li><li>Device-dependent USB class drivers available for USB mass storage, CDC/ACM serial, HID keyboard, and HID mouse.</li><li>Seam-less support for USB hubs.</li></ul></li><li><strong>USB Device Support</strong><ul><li><em>Gadget</em>-like architecture for USB device controller drivers and device-dependent USB class drivers.</li><li>USB device controller drivers available for the most MCU architectures including PIC32, Atmel AVR, SAM3, SAM4, SAMv7, and SAMA5Dx, NXP/Freescale LPC17xx, LPC214x, LPC313x, LPC43xx, and Kinetis, Silicon Laboraties EFM32, STMicro STM32 F1, F2, F3, F4, and F7, TI DM320, and others.</li><li>Device-dependent USB class drivers available for USB serial (CDC/ACM and a PL2303 emulation), for USB mass storage, for USB networking (RNDIS and CDC/ECM), DFU, and for a dynamically configurable, composite USB devices.</li><li>Built-in [[/guide](]{.title-ref}/guide.md)s/usbtrace` and USB host trace functionality for non-invasive USB debug.</li></ul></li><li><strong>Graphics Support</strong><ul><li>Framebuffer drivers.</li><li>Graphic LCD drivers for both parallel and SPI LCDs and OLEDs.</li><li>Segment LCD drivers.</li><li>VNC Server.</li><li><code>mmap</code>-able, framebuffer character driver.</li><li>NX: A graphics library, tiny windowing system and tiny font support that works with either framebuffer or LCD drivers. Documented in the [[/component](]{.title-ref}/component.md)s/nxgraphics/index` manual.</li><li>Font management sub-system.</li><li>[[/application](]{.title-ref}/application.md)s/graphics/nxwidgets/index`: NXWidgets is library of graphic objects, or &quot;widgets,&quot; (labels, buttons, text boxes, images, sliders, progress bars, etc.). NXWidgets is written in C++ and integrates seamlessly with the NuttX NX graphics and font management subsystems.</li><li>NxWM is the tiny NuttX window manager based on NX and NxWidgets.</li></ul></li><li><strong>Input Devices</strong><ul><li>Touchscreen, USB keyboard, GPIO-based buttons and keypads.</li></ul></li><li><strong>Analog Devices</strong><ul><li>Support for Analog-to-Digital conversion (ADC), Digital-to-Analog conversion (DAC), multiplexers, and amplifiers.</li></ul></li><li><strong>Motor Control</strong><ul><li>Pulse width modulation (PWM) / Pulse count modulation.</li></ul></li><li><strong>NuttX Add-Ons</strong>. The following packages are available to extend the basic NuttX feature set: <ul><li><strong>NuttShell (NSH)</strong> A small, scalable, bash-like shell for NuttX with rich feature set and small footprint. See the [[/application](]{.title-ref}/application.md)s/nsh/index`.</li><li><strong>BAS 2.4</strong> Seamless integration of Michael Haardt&#39;s BAS 2.4: &quot;Bas is an interpreter for the classic dialect of the programming language BASIC. It is pretty compatible to typical BASIC interpreters of the 1980s, unlike some other UNIX BASIC interpreters, that implement a different syntax, breaking compatibility to existing programs. Bas offers many ANSI BASIC statements for structured programming, such as procedures, local variables and various loop types. Further there are matrix operations, automatic LIST indentation and many statements and functions found in specific classic dialects. Line numbers are not required.&quot;</li></ul></li></ul><h2 id="look-at-all-those-files-and-features-how-can-it-be-a-tiny-os" tabindex="-1">Look at all those files and features... How can it be a tiny OS? <a class="header-anchor" href="#look-at-all-those-files-and-features-how-can-it-be-a-tiny-os" aria-label="Permalink to &quot;Look at all those files and features\\... How can it be a tiny OS?&quot;">​</a></h2><p>The NuttX feature list (above) is fairly long and if you look at the NuttX source tree, you will see that there are hundreds of source files comprising NuttX. How can NuttX be a tiny OS with all of that?</p><blockquote><ul><li><p><strong>Lots of Features -- More can be smaller!</strong></p><p>The philosophy behind that NuttX is that lots of features are great... <em>BUT</em> also that if you don&#39;t use those features, then you should not have to pay a penalty for the unused features. And, with NuttX, you don&#39;t! If you don&#39;t use a feature, it will not be included in the final executable binary. You only have to pay the penalty of increased footprint for the features that you actually use.</p><p>Using a variety of technologies, NuttX can scale from the very tiny to the moderate-size system. I have executed NuttX with some simple applications in as little as 32K <em>total</em> memory (code and data). On the other hand, typical, richly featured NuttX builds require more like 64K (and if all of the features are used, this can push 100K).</p></li><li><p><strong>Many, many files -- More really is smaller!</strong></p></li></ul><blockquote><p>One may be intimidated by the size NuttX source tree. There are hundreds of source files! How can that be a tiny OS? Actually, the large number of files is one of the tricks to keep NuttX small and as scalable as possible. Most files contain only a single function. Sometimes just one tiny function with only a few lines of code. Why?</p><blockquote><ul><li><strong>Static Libraries</strong>. Because in the NuttX build processed, objects are compiled and saved into <em>static libraries</em> (<em>archives</em>). Then, when the file executable is linked, only the object files that are needed are extracted from the archive and added to the final executable. By having many, many tiny source files, you can assure that no code that you do not execute is ever included in the link. And by having many, tiny source files you have better granularity --if you don&#39;t use that tiny function of even just a few lines of code, it will not be included in the binary.</li></ul></blockquote></blockquote></blockquote><ul><li><p><strong>Other Tricks</strong></p><p>As mentioned above, the use of many, tiny source files and linking from static libraries keeps the size of NuttX down. Other tricks used in NuttX include:</p><ul><li><p><strong>Configuration Files</strong>.</p><p>Before you build NuttX, you must provide a configuration file that specifies what features you plan to use and which features you do not. This configuration file contains a long list of settings that control what is built into NuttX and what is not. There are hundreds of such settings (see the <a href="https://cwiki.apache.org/confluence/display/NUTTX/Configuration+Variables?src=contextnavpagetreemode" target="_blank" rel="noreferrer">Configuration Variable Documentation</a> for a partial list that excludes platform specific settings). These many, many configuration options allow NuttX to be highly tuned to meet size requirements. The downside to all of these configuration options is that it greatly complicates the maintenance of NuttX -- but that is my problem, not yours. -</p></li><li><p><strong>Weak Symbols</strong> The GNU toolchain supports <em>weak</em> symbols and these also help to keep the size of NuttX down. Weak symbols prevent object files from being drawn into the link even if they are accessed from source code. Careful use of weak symbols is another trick for keep unused code out of the final binary.</p></li></ul></li></ul>',10)]))}const h=t(a,[["render",r]]);export{m as __pageData,h as default};
