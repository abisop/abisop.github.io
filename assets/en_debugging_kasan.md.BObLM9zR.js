import{_ as a,c as t,al as o,o as r}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"The Kernel Address Sanitizer (KASAN)","description":"","frontmatter":{},"headers":[],"relativePath":"en/debugging/kasan.md","filePath":"en/debugging/kasan.md"}'),i={name:"en/debugging/kasan.md"};function n(s,e,l,d,c,h){return r(),t("div",null,e[0]||(e[0]=[o(`<h1 id="the-kernel-address-sanitizer-kasan" tabindex="-1">The Kernel Address Sanitizer (KASAN) <a class="header-anchor" href="#the-kernel-address-sanitizer-kasan" aria-label="Permalink to &quot;The Kernel Address Sanitizer (KASAN)&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Kernel Address Sanitizer (KASAN) is a dynamic memory safety error detector designed to find out-of-bounds and use-after-free bugs.</p><p>The current version of NuttX has two modes:</p><ol><li>Generic KASAN</li><li>Software Tag-Based KASAN</li></ol><p>Generic KASAN, enabled with CONFIG_MM_KASAN_GENERIC, is the mode intended for debugging, similar to linux user level ASan. This mode is supported on many CPU architectures, but it has significant performance and memory overheads. The current NuttX Generic KASAN can support memory out of bounds detection allocated by the default NuttX heap allocator,which depends on CONFIG_MM_DEFAULT_MANAGER or CONFIG_MM_TLSF_MANAGER, and detection of out of bounds with global variables.</p><p>Software Tag-Based KASAN or SW_TAGS KASAN, enabled with CONFIG_MM_KASAN_SW_TAGS, can be used for both debugging, This mode is only supported for arm64, but its moderate memory overhead allows using it for testing on memory-restricted devices with real workloads.</p><h2 id="support" tabindex="-1">Support <a class="header-anchor" href="#support" aria-label="Permalink to &quot;Support&quot;">​</a></h2><h3 id="architectures" tabindex="-1">Architectures <a class="header-anchor" href="#architectures" aria-label="Permalink to &quot;Architectures&quot;">​</a></h3><p>Generic KASAN is supported on x86_64, arm, arm64, riscv, xtensa and so on.</p><p>Software Tag-Based KASAN modes are supported only on arm64.</p><h2 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to &quot;Usage&quot;">​</a></h2><p>To enable Generic KASAN, configure the kernel with:</p><pre><code>CONFIG_MM_KASAN=y
CONFIG_MM_KASAN_INSTRUMENT_ALL=y
CONFIG_MM_KASAN_GENERIC=y
</code></pre><p>If you want to enable global variable out of bounds detection, you can add configurations based on the above:</p><pre><code>CONFIG_MM_KASAN_GLOBAL=y
</code></pre><p>To enable Software Tag-Based KASAN, configure the kernel with:</p><pre><code>CONFIG_MM_KASAN=y
CONFIG_MM_KASAN_INSTRUMENT_ALL=y
CONFIG_MM_KASAN_SW_TAGS=y
</code></pre><h2 id="implementation-details" tabindex="-1">Implementation details <a class="header-anchor" href="#implementation-details" aria-label="Permalink to &quot;Implementation details&quot;">​</a></h2><p>Generic KASAN:</p><p>Compile with param -fsanitize=kernel-address, Compile-time instrumentation is used to insert memory access checks. Compiler inserts function calls (<code>__asan_load*(addr)</code>, <code>__asan_store*(addr)</code>) before each memory access of size 1, 2, 4, 8, or 16. These functions check whether memory accesses are valid or not by checking corresponding shadow memory.</p><p>It is slightly different from Linux. On the one hand, in terms of the source of the shadow area; NuttX&#39;s shadow area comes from the end of each heap. During heap initialization, it is offset and a kasan region is shaped at the end. Regions between multiple heaps are concatenated using a linked list.</p><p>Secondly, in order to save more memory consumption, the implementation of NuttX adopts a bitmap detection method; For example, in the case of a 32-bit machine, if the NuttX heap allocator allocates four bytes of memory to it, the kasan module will allocate a shadow area of one bit per unit of memory group on a four byte basis. If the shadow area is 0, the memory group can be accessed, otherwise 1 is inaccessible</p><p>Thirdly, the implementation of global variable out of bounds detection for this NuttX is also different from Linux. Due to the particularity of the shadow region, NuttX needs to construct kasan regions separately for the data and bss segments where the global variable is located. Before compiling, add the compile option &#39;--param asan-globals=1&#39;. In this way, the compiler will store all global variable information in this special sections, &#39;.data..LASAN0&#39;, These two segments store information about all global variables and can be parsed using the following structure:</p><pre><code>struct kasan_global {
  const void *beg;                /* Address of the beginning of the global variable. */
  size_t size;                    /* Size of the global variable. */
  size_t size_with_redzone;       /* Size of the variable + size of the redzone. 32 bytes aligned. */
  const void *name;
  const void *module_name;        /* Name of the module where the global variable is declared. */
  unsigned long has_dynamic_init; /* This is needed for C++. */

  /* It will point to a location that stores the file row,
   * column, and file name information of each global variable */

  struct kasan_source_location *location;
  char *odr_indicator;
};
</code></pre><p>In order to reduce the amount of data generated by the compiler occupying the already precious flash space. NuttX&#39;s approach is to use multiple links to extract the global variable information in elf through scripts, construct the region and shadow of the global variables according to the rules of kasan region, form an array, and finally link it to the program. The program concatenates the array to kasan&#39;s region linked list.</p><p>The data generated by the compiler will be placed in a non-existent memory block. After the compilation is completed, this segment will be deleted and will not be copied to the bin file of the final burned board.</p><p>Software Tag-Based KASAN:</p><p>Software Tag-Based KASAN uses a software memory tagging approach to checking access validity. It is currently only implemented for the arm64 architecture.</p><p>Software Tag-Based KASAN uses the Top Byte Ignore (TBI) feature of arm64 CPUs to store a pointer tag in the top byte of kernel pointers. It uses shadow memory to store memory tags associated with each heap allocated memory cell (therefore, it dedicates 1/8 th of the kernel memory for shadow memory).</p><p>On each memory allocation, Software Tag-Based KASAN generates a random tag, tags the allocated memory with this tag, and embeds the same tag into the returned pointer.</p><p>Software Tag-Based KASAN uses compile-time instrumentation to insert checks before each memory access. These checks make sure that the tag of the memory that is being accessed is equal to the tag of the pointer that is used to access this memory. In case of a tag mismatch, Software Tag-Based KASAN prints a bug report.</p><h2 id="for-developers" tabindex="-1">For developers <a class="header-anchor" href="#for-developers" aria-label="Permalink to &quot;For developers&quot;">​</a></h2><h3 id="ignoring-accesses" tabindex="-1">Ignoring accesses <a class="header-anchor" href="#ignoring-accesses" aria-label="Permalink to &quot;Ignoring accesses&quot;">​</a></h3><p>If you want the module you are writing to not be inserted by the compiler, you can add the option &#39;CFLAGS += -fno-sanitize=kernel-address&#39; to a single module. If it is a file, you can write it this way, special_file.o: CFLAGS = -fno-sanitize=kernel-address</p>`,35)]))}const u=a(i,[["render",n]]);export{p as __pageData,u as default};
