import{_ as t,c as o,al as a,j as n,a as s,o as r}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"TI ADS1115","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/character/analog/adc/ads1115/index.md","filePath":"en/components/drivers/character/analog/adc/ads1115/index.md"}'),i={name:"en/components/drivers/character/analog/adc/ads1115/index.md"};function p(c,e,l,d,h,u){return r(),o("div",null,e[0]||(e[0]=[a(`<h1 id="ti-ads1115" tabindex="-1">TI ADS1115 <a class="header-anchor" href="#ti-ads1115" aria-label="Permalink to &quot;TI ADS1115&quot;">​</a></h1><p>Contributed by Jia Lin</p><p>The ADS1115 is a 16-bit, 4-channel ADC made by Texas Instruments which operates over I2C. It can measure voltages from each channel individually, or between different pairs of channels. The ADS1115 also supports a programmable gain amplifier (PGA) and a digital comparator.</p><hr><p>Channel number AINP AINN 0 AIN0 AIN1 1 AIN0 AIN3 2 AIN1 AIN3 3 AIN2 AIN3 4 AIN0 GND 5 AIN1 GND 6 AIN2 GND 7 AIN3 GND</p><hr><p>: Channel Numbers and Corresponding Sources</p><h2 id="driver-interface" tabindex="-1">Driver Interface <a class="header-anchor" href="#driver-interface" aria-label="Permalink to &quot;Driver Interface&quot;">​</a></h2><p>To register the ADS1115 device driver as a standard NuttX analog device on your board, you can use something similar to the below code for the RP2040.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;nuttx/analog/ads1115.h&gt;</span></span>
<span class="line"><span>#include &lt;nuttx/analog/adc.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Register ADS1115 ADC. */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct adc_dev_s *ads1115 = ads1115_initialize(rp2040_i2cbus_initialize(0),</span></span>
<span class="line"><span>                                               CONFIG_ADC_ADS1115_ADDR);</span></span>
<span class="line"><span>if (ads1115 == NULL)</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    syslog(LOG_ERR, &quot;Failed to initialize ADS1115\\n&quot;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ret = adc_register(&quot;/dev/adc1&quot;, ads1115);</span></span>
<span class="line"><span>if (ret &lt; 0)</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    syslog(LOG_ERR, &quot;Failed to register ADS1115 device driver: %d\\n&quot;, ret);</span></span>
<span class="line"><span>  }</span></span></code></pre></div><p>If you have a measurement from the ADS1115, you can convert it into a voltage like so:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#define FSR (2.048)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct adc_msg_s msg;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Some code here to read the ADC device, you can read the ADC driver docs */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>double voltage = ((double)msg.am_data  * FSR) / (32768.0);</span></span></code></pre></div>`,12),n("p",null,[s("Once registered, this driver can be interacted with using the ADC example ("),n("code",{class:"interpreted-text",role:"ref"},"adc-example"),s("). Be sure to enable the software trigger, since the ADS1115 driver does not support hardware triggers (interrupts). You can also change the number of samples per group up to 8 for all 8 channels of the ADC.")],-1),a('<p>You may need to increase the [CONFIG_ADC_FIFOSIZE]{.title-ref} value to something larger than 8 in order to be able to store all the ADC measurements after a measurement trigger (i.e 9).</p><h2 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h2><hr><p>Name Description CONFING_ADC_ADS1115_I2C_FREQUENCY I2C frequency of the ADS1115 CONFIG_ADC_ADS1115_ADDR I2C address of the ADS1115 CONFIG_ADC_ADS1115_CHANNEL Default ADC channel to read CONFIG_ADC_ADS1115_PGA Gain of the ADS1115 CONFIG_ADC_ADS1115_CONTINOUS Continuous mode of the ADS1115 CONFIG_ADC_ADS1115_DR Data rate of the ADS1115 CONFIG_ADC_ADS1115_COMP_MODE Mode of the ADS1115 comparator, traditional or window CONFIG_ADC_ADS1115_COMP_POL Polarity of the ADS1115 comparator, active high or active low CONFIG_ADC_ADS1115_COMP_LAT Latching mode of the ADS1115 comparator, traditional or latching CONFIG_ADC_ADS1115_COMP_QUE Comparator queue of the ADS1115, which changes when the ALRT/RDY pin is asserted. CONFIG_ADC_ADS1115_HI_THRESH HIGH_THRESH register of the ADS1115 CONFIG_ADC_ADS1115_LO_THRESH LOW_THRESH register of the ADS1115</p><hr><p>: Configuration Options</p><hr><p>Value in Kconfig Data Rate 0 8 SPS 1 16 SPS 2 32 SPS 3 64 SPS 4 128 SPS 5 250 SPS 6 475 SPS 7 860 SPS</p><hr><p>: Data Rates</p><hr><p>Value in Kconfig Full Scale Range (FSR) 0 ±6.144V 1 ±4.096V 2 ±2.048V 3 ±1.024V 4 ±0.512V 5 ±0.256V 6 ±0.256V 7 ±0.256V</p><hr><p>: PGA Values</p><hr><p>Value in Kconfig Comparator Queue 0 Assert after one conversion 1 Assert after two conversions 2 Assert after four conversions 3 Disable comparator</p><hr><p>: Comparator Queue Values</p><h2 id="additional-ioctl-commands" tabindex="-1">Additional ioctl Commands <a class="header-anchor" href="#additional-ioctl-commands" aria-label="Permalink to &quot;Additional ioctl Commands&quot;">​</a></h2><p>There are various additional ioctl() commands that can be used with the ADS1115 driver. These mostly allow for changes of configuration in runtime.</p><p>This command changes the gain of the ADS1115 driver. The argument passed should be of type ads1115_pga_e, which corresponds to the gain seen above.</p><p>This command changes the ADS1115 to operate in continuous or single-shot mode.</p><p>This command changes the data rate of the ADS1115 driver. The argument passed should be of type ads1115_dr_e, which corresponds to the data rate seen above.</p><p>This command changes the ADS1115 to operate in either traditional or window comparator mode.</p><p>This command changes the ADS1115 to operate in either active high or active low mode.</p><p>This command changes the ADS1115 to operate in either traditional or latching comparator mode.</p><p>This command changes the comparator queue feature of the ADS1115. The argument passed should be of type ads1115_comp_queue_e, which corresponds to the comparator queue seen above.</p><p>This command changes the HIGH_THRESH register of the ADS1115. The argument passed should be of type uint16_t, which corresponds to the HIGH_THRESH register value.</p><p>This command changes the LOW_THRESH register of the ADS1115. The argument passed should be of type uint16_t, which corresponds to the LOW_THRESH register value.</p>',29)]))}const A=t(i,[["render",p]]);export{m as __pageData,A as default};
