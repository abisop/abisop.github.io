import{_ as t,c as r,al as s,o}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Sensor Cluster (Obsolete)","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/special/sensors/sensors_cluster.md","filePath":"en/components/drivers/special/sensors/sensors_cluster.md"}'),n={name:"en/components/drivers/special/sensors/sensors_cluster.md"};function a(i,e,l,d,c,p){return o(),r("div",null,e[0]||(e[0]=[s(`<p>Warning</p><p>This interface is not commonly used in NuttX and is not recommended for implementing new sensors. It should be removed in the future.</p><h1 id="sensor-cluster-obsolete" tabindex="-1">Sensor Cluster (Obsolete) <a class="header-anchor" href="#sensor-cluster-obsolete" aria-label="Permalink to &quot;Sensor Cluster (Obsolete)&quot;">​</a></h1><h2 id="common-sensor-register-interface" tabindex="-1">Common Sensor Register Interface <a class="header-anchor" href="#common-sensor-register-interface" aria-label="Permalink to &quot;Common Sensor Register Interface&quot;">​</a></h2><p>Contributed by Bob Feretich</p><p>Background and problem statement:</p><p>The capabilities and performance of modern sensors have grown tremendously. Most sensors are now capable of some degree of autonomous behavior and several permit the user to load firmware into them and perform as nanocontrollers. Other sensors have very sophisticated built-in digital filters that can be programmed with hundreds of parameters.</p><p>Currently most sensor drivers in the NuttX drivers/sensors directory implement file_ops open(), close(), and read() functions. The open() function initializes the sensor and places it in a mode where it can transfer live data in a default configuration. The close() function places the sensor in a low power shutdown mode. The read() function returns the most recent data sample from the sensor&#39;s most used data output registers. The write() function is rarely implemented and when it is there is no consistency in its use. The lseek() and poll() functions seem to be completely ignored. This results in the sensors being operated in only their most primitive modes using a fixed &quot;default configuration&quot;.</p><p>To work around this problem sensor drivers have implemented ioctl() functions to perform configuration, program the sensor, and manage autonomous activity. Ioctls provide a method where user programs can tunnel through a high level driver to access and control device specific features. The problem with using ioctls is that before the ioctl interface can be used, the sensor driver must be opened; and the open() function causes the driver to start performing these primitive actions, so before ioctls can manage the drivers as desired, ioctls must first be used to undo the generic actions caused by the open() function. Another major issue is that there is no consistency from sensor to sensor on ioctl definitions, not even for the most common sensor actions like writing a sensor control register or reading a sensor status register.</p><p>Purpose:</p><p>The purpose of the &quot;Common Sensor Register Interface&quot; is to implement a consistent and more useful definition of file_ops interface and to make the file_ops open() function more flexible in establishing the initial operational state of the sensor. Compatibility for user applications that implement the current open(), close(), read() interface will be maintained; and the much greater capabilities of modern sensors will become accessible through this interface.</p><p>Scope:</p><p>Applicable to I2C and SPI attached sensors, and some serial port attached sensors.</p><p>The file_ops interface definition:</p><p>open(): This function performs the below actions...</p><blockquote><ol><li><p>Reads the sensors ID register. If the sensor responds with an unexpected value, then... a) The driver&#39;s write() function is disabled.</p><p>b) The open function initializes the driver instance, so that read() and lseek() operations may be performed to enable problem diagnoses, but the sensor hardware is not initialized. (No write operations are performed to the sensor.)</p><p>c) The errno global variable is set to positive ENODEV (&quot;No such device&quot;).</p><p>d)</p><pre><code>The open() function returns successfully with a file\\_handle.

:   Note that the calling routine should clear errno before
    calling open(). (The file\\_ops rules prevent drivers from
    setting errno to zero.)
</code></pre></li><li><p>The other file_ops functions are enabled.</p></li><li><p>The driver&#39;s &quot;current reg address&quot; state variable is set to the sensor&#39;s first sensor data output register. (This will make calls to read() return live sensor data and maintain compatibility with existing user programs.)</p></li><li><p>If the driver supports a default worker task and an interrupt handler is specified by in the sensor configuration structure, then the default worker task is bound to the default worker task.</p></li><li><p>The sensor configuration structure (that was provided to the driver registration function) is examined to determine whether a custom sensor configuration is specified. (The custom configuration is basically an array of (device_reg_address, value) pairs that are written to the sensor via &quot;single register write&quot; operations. If a custom sensor configuration was specified, then that configuration is written to the sensor, otherwise the &quot;default sensor configuration&quot; is written to the sensor. (A side effect of writing this data may result in interrupts occurring and data being transferred to/from the worker task.)</p></li><li><p>The open() function returns successfully with a file_handle.</p></li></ol></blockquote><p><code>close()</code>: This function stops sensor activity and places it in a low</p><p>: power mode. The file_ops interface functions are disabled for this instance of the sensor driver. (Except for open())</p><p><code>read()</code>: The action of this function is dependent on whether a &quot;default</p><p>: worker task&quot; is running and the value of the driver&#39;s &quot;current reg address&quot; state variable.</p><pre><code>If a \\&quot;default worker task\\&quot; is running,

&gt; AND the driver\\&#39;s \\&quot;current reg address\\&quot; is equal to the value of
&gt;
&gt; :   the first sensor data output register,
&gt;
&gt; AND the number of bytes to be read is less than or equal to the
&gt;
&gt; :   number of bytes in a \\&quot;default worker task\\&quot; sample,

Then data is copied from the \\&quot;default worker task\\&#39;s\\&quot; sample
memory to the caller\\&#39;s provided buffer.

Otherwise, this function transfers data from sensor registers to the
data buffer provided by the caller. The first byte read is from the
sensor register address specified by the sensor\\&#39;s \\&quot;current reg
address\\&quot;. The addresses of subsequent bytes to be read are context
sensitive. If more than bus transfer is needed to complete the read,
then a \\&quot;multi-byte\\&quot; (sometimes called \\&quot;burst mode\\&quot;) data
transfer will be used to fill the buffer. See the sensor\\&#39;s
datasheet to determine the auto-increment behavior of a
\\&quot;multi-byte\\&quot; data transfers.

Note: That most sensors collect only a few bytes of data per sample.
Small data transfers occurring over a high speed bus (like SPI and
some high speed i2c and serial interfaces) are much more efficient
when collected directly from the sensor hardware than by using a
worker task as an intermediary.
</code></pre><p><code>write()</code>: This function transfers data from the data buffer provided by</p><p>: the caller to sensor registers. The first byte written is to the sensor register address specified by the sensor&#39;s &quot;current reg address&quot;. The addresses of subsequent bytes to be read are context sensitive. If more than bus transfer is needed to complete the write, then a &quot;multi-byte&quot; (sometimes called &quot;burst mode&quot;) data transfer will be used to transfer data from the buffer.</p><pre><code>See the sensor\\&#39;s datasheet to determine the auto-increment behavior
of a \\&quot;multi-byte\\&quot; data transfers.

Note: If write() function was disabled, then no writes will be
performed and the function will return 0 (characters transferred)
and errno is set to -EROFS (\\&quot;read-only file system\\&quot;).
</code></pre><p><code>lseek()</code>: This function sets the value of the sensor&#39;s &quot;current reg address&quot;</p><p>: (seek_address). The open() function initializes the &quot;current reg address&quot; to the first sensor data output register, so unless the user needs to change the sensor configuration, lseek() does not need to be called. Neither read() nor write() change the sensor&#39;s &quot;current reg address&quot;.</p><pre><code>The definition of lseek is\\...:

    off_t lseek(int fd, off_t offset, int whence);

For whence == SEEK\\_SET, the sensor\\&#39;s \\&quot;current reg address\\&quot; will
be set to offset.

For whence == SEEK\\_CUR, offset will be added to the sensor\\&#39;s
\\&quot;current reg address\\&quot;.

For whence == SEEK\\_END, offset is ignored and the sensor\\&#39;s
\\&quot;current reg address\\&quot; is set to the first sensor data output
register.

lseek() will return an error if the resulting \\&quot;current reg
address\\&quot; is invalid for the sensor.
</code></pre><p><code>ioctl()</code>: Ioctls() may still be used and this interface make no attempt to</p><p>: regulate them. But, it is expected that far fewer ioctls will be needed.</p><p>The above interface can be used to fully configure a sensor to the needs of an application, including the ability to load firmware into sensor state machines</p><h2 id="sensor-cluster-driver-interface" tabindex="-1">Sensor Cluster Driver Interface <a class="header-anchor" href="#sensor-cluster-driver-interface" aria-label="Permalink to &quot;Sensor Cluster Driver Interface&quot;">​</a></h2><p>Contributed by Bob Feretich</p><p>Background and problem statement:</p><p>Most microcontrollers can support SPI bus transfers at 8 MHz or greater. Most SPI attached sensors can support a 10 MHz SPI bus. Most tri-axis accelerometers, tri-axis gyroscopes, or tri-axis magnetometers use only 6 bytes per sample. Many sensors use less than 6 bytes per sample. On an 8 MHz SPI bus it takes about 8 microseconds to transfer a 6 byte sample. (This time includes a command byte, 6 data bytes, and chip select select setup and hold.) So, for the below discussion keep in mind that the sensor sample collection work we want to perform should ideally take 8 microseconds per sample.</p><p>The drivers in the drivers/sensors directory support only the user space file_ops interface (accessing drivers through the POSIX open/read/close functions using a file descriptor). Also these drivers typically start their own worker task to perform sensor data collection, even when their sensors only transfer a few bytes of data per sample and those transfers are being made over a high performance bus.</p><p>Using the current implementation...</p><ol><li>A sensor &quot;data ready&quot; or timer interrupt occurs.</li><li>Context is saved and and the driver&#39;s interrupt handler is scheduled to run.</li><li>The NuttX scheduler dispatches the driver&#39;s interrupt handler task.</li><li>The driver&#39;s interrupt handler task posts to a semaphore that the driver&#39;s worker task is waiting on.</li><li>NuttX restores the context for the driver&#39;s worker task and starts it running.</li><li>The driver&#39;s worker task starts the i/o to collect the sample.) (This is where the 8 microseconds of real work gets performed.) And waits on a SPI data transfer complete semaphore.</li><li>The NuttX saves the context of the driver&#39;s worker task, and the scheduler dispatches some other task to run while we are waiting. Note that this is a good thing. This task is probably performing some other real work. We want this to happen during the data transfer.</li><li>The completion of the data transfer causes an interrupt. NuttX saves the current context and restores the driver&#39;s worker task&#39;s context.</li><li>The driver&#39;s worker task goes to sleep waiting on the semaphore for the next sensor &quot;data ready&quot; or timer interrupt.</li><li>The NuttX saves the context of the driver&#39;s worker task, and the scheduler dispatches some other task to run while we are waiting.</li></ol><p>Independently with the above...</p><p>a) The sensor application program performs a file_ops read() to collect a sample. b) The NuttX high level driver receives control, performs a thin layer of housekeeping and calls the sensor driver&#39;s read function. c) The sensor driver&#39;s read function copies the most recent sample from the worker task&#39;s data area to the application&#39;s buffer and returns. d) The NuttX high level driver receives control, performs a thin layer of housekeeping and returns. e) The application processes the sample.</p><p>Using a 216 MHz STM32F7 with no other activity occurring, we have timed the above the elapsed time for the above to be on average 45 microseconds.</p><p>Most sensor applications process data from multiple sensors. (An 9-DoF IMU is typically represented as three sensors (accelerometer, gyroscope, and magnetometer). In this case there are three copies of 1-10 occurring in parallel.</p><p>In applications where live data is being used, the context switch thrashing and cache pollution of this approach cripples system performance. In applications where sensor FIFO data is being used and therefore a large amount of data is collected per iteration, the non &quot;zero copy&quot; nature of the data collection becomes a performance issue.</p><p>Purpose:</p><p>The &quot;Sensor Cluster Driver Interface&quot; provides a standard mechanism for an application to collect data from multiple sensor drivers in a much more efficient manner. It significantly reduces the number of running tasks and the context thrashing and cache pollution caused by them. It also permits &quot;zero copy&quot; collection of sensor data.</p><p>The Sensor Cluster Driver Interface uses a single &quot;worker task&quot; to be shared by an arbitrary number of drivers. This shared worker task is a kernel task that is registered like a driver, supports a driver interface to application programs, and collects data from multiple sensors (a cluster of sensors), we refer to it a &quot;Sensor Cluster Driver&quot;.</p><p>Its goal is to change the sequence of events detailed above to...</p><ol><li>A sensor &quot;data ready&quot; or timer interrupt occurs.</li><li>Context is saved and and the cluster driver&#39;s interrupt handler is scheduled to run.</li><li>The NuttX scheduler dispatches the cluster driver&#39;s interrupt handler task.</li><li>The cluster driver&#39;s interrupt handler task posts to a semaphore that the cluster driver&#39;s worker task is waiting on.</li><li>NuttX restores the context for the driver&#39;s worker task and starts it running.</li><li>The cluster driver&#39;s worker task starts the i/o to collect the sample. There are two choices here. Programmed I/O (PIO) or DMA. If PIO is fastest for a small sample size, but it will lock up the processor for the full duration of the transfer; it can only transfer from one sensor at a time; and the worker task should manually yield control occasionally to permit other tasks to run. DMA has higher start and completion overhead, but it is much faster for long transfers, can perform simultaneous transfers from sensors on different buses, and automatically releases the processor while the transfer is occurring. For this reason our drivers allows the worker task to choose between PIO (driver_read()) and DMA (driver_exchange()), a common extension to the sensor_cluster_operations_s structure. So either way after one or more transfers we yield control and move to the next step. Note that the data is being transferred directly into the buffer provided by the application program; so no copy needs to be performed.</li><li>The NuttX saves the context of the cluster driver&#39;s worker task, and the scheduler dispatches some other task to run while we are waiting. Again note that this is a good thing. This task is probably performing some other real work. We want this to happen during the data transfer.</li><li>The completion of the last of the previous data transfers causes an interrupt. NuttX saves the current context and restores the cluster driver&#39;s worker task&#39;s context. If there is more sensor data to collect, then goto Step 6. Otherwise it posts to a semaphore that will wake the application.</li><li>The driver&#39;s worker task goes to sleep waiting on the semaphore for the next sensor &quot;data ready&quot; or timer interrupt.</li><li>The NuttX saves the context of the driver&#39;s worker task, and the scheduler dispatches some other task to run while we are waiting.</li></ol><p>Independently with the above...</p><p>a) The sensor application program performs a file_ops read() to collect a sample. b) The NuttX high level driver receives control, performs a thin layer of housekeeping and calls the sensor driver&#39;s read function. c) The sensor driver&#39;s read function copies the most recent sample from the worker task&#39;s data area to the application&#39;s buffer and returns. d) The NuttX high level driver receives control, performs a thin layer of housekeeping and returns. e) The application processes the sample.</p><p>So when collecting data from three sensors, this mechanism saved...</p><ul><li>the handling of 2 sensor &quot;data ready&quot; or timer interrupts (Steps 1 - 4).</li><li>2 occurrences of waking and scheduling of a worker task (Step 5).</li><li>2 context switches to other tasks (Step 9 &amp; 10)</li><li>if the three sensors were on separate buses, then 2 occurrences of</li></ul><p>Steps 6 - 8 could have also been saved.</p><ul><li>An extra copy operation of the collected sensor data.</li><li>The cache pollution caused by 2 competing worker tasks.</li></ul><p>Definitions:</p><p>&quot;Leaf Driver&quot; - a kernel driver that implements the &quot;Sensor Cluster Driver</p><p>: Interface&quot; so that it can be called by Cluster drivers.</p><p>&quot;Cluster Driver&quot; - a kernel driver that uses the &quot;Sensor Cluster Driver</p><p>: Interface&quot; to call leaf drivers.</p><p>&quot;Entry-Point Vector&quot; - an array of function addresses to which a leaf driver</p><p>: will permit calls by a Cluster Driver.</p><p>&quot;Leaf Driver Instance Handle&quot; - a pointer to an opaque Leaf Driver structure</p><p>: that identifies an instance of the leaf driver. Leaf Drivers store this handle in its configuration structure during registration.</p><p>Sensor Cluster Interface description:</p><ul><li>The definition of an entry-point vector. This is similar to the entry-point vector that is provided to the file-ops high level driver. This entry-point vector must include the sensor_cluster_operations_s structure as its first member.</li><li>The the definition of an driver entry-point vector member in the leaf driver&#39;s configuration structure. The leaf driver registration function must store the address of its entry-point vector in this field.</li><li>The the definition of an instance handle member in the leaf drivers configuration structure. The leaf driver registration function must store a handle (opaque pointer) to the instance of the leaf driver being registered in this field. Note that this should be the same handle that the leaf driver supplies to NuttX to register itself. The cluster driver will include this handle as a parameter in calls made to the leaf driver.</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct sensor_cluster_operations_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  CODE int     (*driver_open)(FAR void *instance_handle, int32_t arg);</span></span>
<span class="line"><span>  CODE int     (*driver_close)(FAR void *instance_handle, int32_t arg);</span></span>
<span class="line"><span>  CODE ssize_t (*driver_read)(FAR void *instance_handle, FAR char *buffer,</span></span>
<span class="line"><span>                              size_t buflen);</span></span>
<span class="line"><span>  CODE ssize_t (*driver_write)(FAR void *instance_handle,</span></span>
<span class="line"><span>                               FAR const char *buffer, size_t buflen);</span></span>
<span class="line"><span>  CODE off_t   (*driver_seek)(FAR void *instance_handle, off_t offset,</span></span>
<span class="line"><span>                              int whence);</span></span>
<span class="line"><span>  CODE int     (*driver_ioctl)(FAR void *instance_handle, int cmd,</span></span>
<span class="line"><span>                               unsigned long arg);</span></span>
<span class="line"><span>  CODE int     (*driver_suspend)(FAR void *instance_handle, int32_t arg);</span></span>
<span class="line"><span>  CODE int     (*driver_resume)(FAR void *instance_handle, int32_t arg);</span></span>
<span class="line"><span>};</span></span></code></pre></div><p>Note that the sensor_cluster_operations_s strongly resembles the NuttX fs.h file_operations structures. This permits the current file_operations functions to become thin wrappers around these functions.</p><p><code>driver_open()</code> Same as the fs.h open() except that arg can be specify</p><p>: permitting more flexibility in sensor configuration and initial operation. when arg = 0 the function of driver_open() must be identical to open().</p><p><code>driver_close()</code> Same as the fs.h close() except that arg can be specify</p><p>: permitting more flexibility in selecting a sensor low power state. when arg = 0 the function of driver_close() must be identical to close().</p><p><code>driver_read()</code> Same as the fs.h read().</p><p><code>driver_write()</code> Same as the fs.h write(). Optional. Set to NULL if not</p><p>: supported.</p><p><code>driver_seek()</code> Same as the fs.h seek(). Optional. Set to NULL if not</p><p>: supported.</p><p><code>driver_ioctl()</code> Same as the fs.h ioctl(). Optional. Set to NULL if not</p><p>: supported.</p><p><code>driver_suspend()</code> and <code>driver_resume()</code> Optional. Set to NULL if not</p><p>: supported. It is common for sensor applications to conserve power and send their microcontroller into a low power sleep state. It seems appropriate to reserve these spots for future use. These driver entry points exist in Linux and Windows. Since microcontrollers and sensors get more capable every year, there should soon be a requirement for these entry points. Discussion on how to standardize their use and implementation should be taken up independently from this driver document.</p><p>Note that all drivers are encouraged to extend their entry-point vectors beyond this common segment. For example it may be beneficial for the worker task to select between programmed i/o and DMA data transfer routines. Unregulated extensions to the Entry-Point Vector should be encouraged to maximize the benefits of a sensor&#39;s features.</p><p>Operation:</p><p>Board logic (configs directory) will register the cluster driver. The cluster driver will register the leaf drivers that it will call. This means that the cluster driver has access to the leaf driver&#39;s configuration structures and can pass the Leaf Driver Instance Handle to the leaf driver as a parameter in calls made via the Entry-Point Vector.</p><p>Either board logic or an application program may open() the cluster driver. The cluster driver open() calls the open() function of the leaf drivers. The cluster driver open() or read() function can launch the shared worker task that collects the data.</p><p>The cluster driver close() function calls the close functions of the leaf drivers.</p><h2 id="implemented-drivers" tabindex="-1">Implemented Drivers <a class="header-anchor" href="#implemented-drivers" aria-label="Permalink to &quot;Implemented Drivers&quot;">​</a></h2><ul><li>adxl372 [[adxl372]{.title-ref}]([adxl372]{.title-ref}.md)</li><li class="title-ref">lsm330 [[l](\`l.md)sm330]</li></ul>`,86)]))}const f=t(n,[["render",a]]);export{u as __pageData,f as default};
