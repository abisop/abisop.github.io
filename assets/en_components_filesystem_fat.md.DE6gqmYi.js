import{_ as t,c as o,al as a,o as i}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"FAT","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/filesystem/fat.md","filePath":"en/components/filesystem/fat.md"}'),r={name:"en/components/filesystem/fat.md"};function n(s,e,l,c,d,h){return i(),o("div",null,e[0]||(e[0]=[a('<h1 id="fat" tabindex="-1">FAT <a class="header-anchor" href="#fat" aria-label="Permalink to &quot;FAT&quot;">​</a></h1><p>File Allocation Table (FAT) is a very simple file system designed by Microsoft and, as the name suggests, it uses a table to track clusters on a storage volume. There have been multiple versions of FAT, like <code>FAT12</code>, <code>FAT16</code>, and lastly <code>FAT32</code> to consider for growing data volumes. Even though FAT has been superseded by more recent file systems in most Windows computers, current Windows editions, macOS, Linux, Unix as well as Apache NuttX support FAT. It is still used for floppy disks, USB flash drives as well as for storage media in smaller, portable devices like digital cameras.</p><p>FAT uses a magic number <code>0x4D44</code>, and has been named as <code>vfat</code> in the codebase, due to the implementation being actually VFAT, which is an extension that allows for long file names. This page contains information about the FAT file system from the perspective of the implementation of FAT that exists in NuttX.</p><h2 id="fat-structure" tabindex="-1">FAT Structure <a class="header-anchor" href="#fat-structure" aria-label="Permalink to &quot;FAT Structure&quot;">​</a></h2><p>The number beside <code>FAT</code> (eg. <code>16</code> in <code>FAT16</code>) represents the number of bits used for each entry in the allocation table. A FAT volume has multiple sections:</p><ul><li><strong>Master Boot Record</strong>: Master Boot Record (MBR) or Boot Sector contains information needed by the file system to access the volume, including the volume&#39;s layout and file system structure, akin to a superblock in Linux file systems.</li><li><strong>Allocation Table Region</strong>: Stores the file allocation table, as well as its copy which acts as a backup. The file allocation table keeps a track of all the clusters in the volume, and thus has one entry for each cluster.</li><li><strong>Root Directory</strong>: It stores a directory table containing entries describing the files and directories stored on the volume. Each entry contains metadata about file system objects.</li></ul><p>Note</p><p>Root Directory exists as a separate section if the volume is for <code>FAT12</code> or <code>FAT16</code>, right after the Allocation Table Region and has a fixed upper limit to the number of entries. <code>FAT32</code> does not have a dedicated region for the Root Directory, but has it incorporated into the following Data Region, and thus <code>FAT32</code> does not have any hard coded upper limit to the number of entries.</p><ul><li><strong>Data Region</strong>: This region stores the actual data of the files as well as directory data. Data Region is divided into multiple clusters, which are numbered sequentially and have corresponding entries in the allocation table. Cluster sizes can vary depending on the volume size as well as on the type of the FAT file system.</li></ul><p>The first entry in the Allocation Table is for the volume&#39;s FAT ID while the second entry indicates that the cluster is reserved. Given that <code>FAT32</code> does not have a dedicated Root Directory section, in <code>FAT32</code> volume, the third entry points to the root directory.</p><p>File names can be either <a href="https://en.wikipedia.org/wiki/8.3_filename" target="_blank" rel="noreferrer">short</a> (also known as 8.3 filename or SFN), or long (LFN), till a maximum length limit.</p><h2 id="master-boot-record-mbr" tabindex="-1">Master Boot Record (MBR) <a class="header-anchor" href="#master-boot-record-mbr" aria-label="Permalink to &quot;Master Boot Record (MBR)&quot;">​</a></h2><p>The Boot Record may be one of two types. One is a much older type which does not contain partitions, and one more recent with them. One distinguishing feature of FAT is that all MBRs contain <code>0x55AA</code> at an offset of 510 from the start, which can be used to determine the type of FAT being used in the block device.</p><p>For the older type, the MBR exists at the start of the drive. It does not contain any partitions.</p><p>The newer type has a partition table at an offset of 446 from the start of the drive. It allows for 4 primary partitions. It has FAT Boot Records (FBRs) at the start of every partition, which, for most parts, are identical in structure to the older MBRs.</p><h2 id="partition-table-entries" tabindex="-1">Partition Table Entries <a class="header-anchor" href="#partition-table-entries" aria-label="Permalink to &quot;Partition Table Entries&quot;">​</a></h2><p>The partition table contains information for 4 primary partitions, each partition having entries in the table of 16 bytes each. These have various information about the partition including, but not limited to, type of the partition, starting sector, and partition size.</p><h2 id="allocation-table" tabindex="-1">Allocation Table <a class="header-anchor" href="#allocation-table" aria-label="Permalink to &quot;Allocation Table&quot;">​</a></h2><p>The allocation table follows the boot record, and has an entry for each cluster available in the data region. Each entry has a size defined by the file system type. <code>FAT12</code> has 12 byte long entries, <code>FAT16</code> has 16 byte entries and <code>FAT32</code> has 32 byte entries.</p><p>File data is made up of a linked list (or chain) of clusters. Entries in the allocation table, which correspond to actual clusters, contain the cluster number of the next cluster that appears in the file. The last cluster of a file has a value in their allocation table entry such that all of its bits are set (<code>0xFFF</code> for FAT12, <code>0xFFFF</code> for FAT16, <code>0xFFFFFFFF</code> for FAT32).</p><p>The starting cluster (head of the file chain) is pointed to by the directory entry of that file.</p><h2 id="directory-entries" tabindex="-1">Directory Entries <a class="header-anchor" href="#directory-entries" aria-label="Permalink to &quot;Directory Entries&quot;">​</a></h2><p>A directory is basically a file which has a table that contains directory entries that contain the metadata about the files and subdirectories in it. Each directory entry describes a file or a subdirectory inside the directory.</p><p>Root directory in FAT12/16 have a dedicated region, separate from the data area. In FAT32, root directory is just like a regular directory in the data region (ie. without any dedicated region) except for:</p><ul><li>Its starting cluster is denoted in the boot record.</li><li>It is not pointed to by any other directory.</li><li>It has no entries corresponding to <code>.</code> and <code>..</code> (all non-root directories have both of these entries).</li></ul><p>Directory entries are 32 bytes long, and start with an 11 bytes long SFN. The rest of the directory entry contain information like the file attributes, timestamps of creation as well as access and write, cluster number and file size, to name a few.</p><h3 id="_8-3-filename" tabindex="-1">8.3 filename <a class="header-anchor" href="#_8-3-filename" aria-label="Permalink to &quot;8.3 filename&quot;">​</a></h3><p>The first byte of a directory&#39;s 8.3 filename (and hence first byte of the entire directory entry) has a special meaning. It has 3 possible values:</p><ul><li><code>0xe5</code> : Denotes that the current directory entry is empty.</li><li><code>0x00</code> : Denotes that this entry, as well as all following entries, are empty.</li><li><code>0x05</code> : Actual value is <code>0xe5</code>.</li></ul><p>The rest of the 7 + 3 byte of the directory entry are for the name (with extension).</p><h2 id="files" tabindex="-1">Files <a class="header-anchor" href="#files" aria-label="Permalink to &quot;Files&quot;">​</a></h2><p>The starting cluster of data in a file is pointed by the directory entry of the file.</p><p>File allocation is very primitive in FAT, and the first available location in the volume is given to a file.</p><h3 id="file-attributes" tabindex="-1">File attributes <a class="header-anchor" href="#file-attributes" aria-label="Permalink to &quot;File attributes&quot;">​</a></h3><p>File attributes are denoted by a bit flag of the size of a single byte. The file flags in FAT, with their bit representation, are as follows:</p><p>Attribute Macro Bit representation Hex value</p><hr><p><code>FATATTR_READONLY</code> <code>00000001</code> 0x1 <code>FATATTR_HIDDEN</code> <code>00000010</code> 0x2 <code>FATATTR_SYSTEM</code> <code>00000100</code> 0x4 <code>FATATTR_VOLUMEID</code> <code>00001000</code> 0x8 <code>FATATTR_DIRECTORY</code> <code>00010000</code> 0x10 <code>FATATTR_ARCHIVE</code> <code>00100000</code> 0x20</p><p>: File Attributes</p><p>Out of these, FAT exposes a user to <code>FATATTR_READONLY</code>, <code>FATATTR_HIDDEN</code>, <code>FATATTR_SYSTEM</code> and <code>FATATTR_ARCHIVE</code> to the user.</p><h2 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to &quot;Implementation&quot;">​</a></h2><p>The Apache NuttX implementation of VFAT can be found in:</p><ul><li><code>fs/fat</code> directory.</li><li><code>include/nuttx/fs/fat.h</code> header file.</li></ul>',43)]))}const p=t(r,[["render",n]]);export{u as __pageData,p as default};
