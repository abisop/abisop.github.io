import{_ as r,c as o,al as a,j as e,a as i,o as l}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"NXP i.MX RT","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/imxrt/index.md","filePath":"en/platforms/arm/imxrt/index.md"}'),n={name:"en/platforms/arm/imxrt/index.md"};function s(d,t,c,h,u,p){return l(),o("div",null,t[0]||(t[0]=[a("",11),e("p",null,[i("Only tickless via an alarm is currently supported for i.MX RT MCU, which can be selected by CONFIG_SCHED_TICKLESS_ALARM option. CONFIG_USEC_PER_TICK option determines the resolution of time reported by :c"),e("code",{class:"interpreted-text",role:"func"},"clock_systime_ticks()"),i(" and the resolution of times that can be set for certain delays including watchdog timers and delayed work. It is important that value set in CONFIG_USEC_PER_TICK represents the frequency of GPT timer that runs the tickless mode. Clock source of the timer is 16.6 MHz, which is then divided by the prescaler value from 1 to 4096. Possible values for CONFIG_USEC_PER_TICK are 10 or 100 for example.")],-1),a("",8),e("p",null,[i("ADC driver with the successive approximation analog/digital converter. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_adcinitialize"),i(".")],-1),e("p",null,"ADC module can use either continuous trigger (next conversion is started as soon as the previous is finished) or hardware trigger. This option is selected by IMXRT_ADCx_ETC (x = 1, 2) config option. If IMXRT_ADCx_ETC = -1 then continuous trigger is used. If corresponding XBAR number is put in IMXRT_ADCx_ETC then that signal is used to trigger the ADC conversion (for example PWM signal can be used as a source). For PWM XBAR options please refer to PWM chapter of this documentation.",-1),e("p",null,"Hardware triggering is currently limited to maximum of 8 channels. HW trigger is automatically disabled if there are more than 8 channels.",-1),e("p",null,"DMA is currently not supported for ADC modules.",-1),e("h3",{id:"can",tabindex:"-1"},[i("CAN "),e("a",{class:"header-anchor",href:"#can","aria-label":'Permalink to "CAN"'},"​")],-1),e("p",null,[i("FlexCAN driver is supported in MCUs i.MX RT1020 and higher. i.MX RT106x have both classical CAN and also one CAN FD while i.MX RT1170 have 3 CAN FD peripherals. FlexCAN driver in imxrt works beyond SocketCAN driver layout. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_cannitialize()"),i(".")],-1),e("p",null,[i("There is an booting option that automatically provides initialization of network interface in the early stages of booting and therefore calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_cannitialize()"),i(" via board specific logic is not necessary. This however works only when there is only one interface in the chip. For running more interfaces (like CAN and Ethernet), network late initialization must be turn on by CONFIG_NETDEV_LATEINIT and board specific logic must call lower-half part of drivers.")],-1),a("",7),e("p",null,[i("The enhanced quadrature encoder/decoder module supported in i.MX RT1015 and higher. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_qeinitialize"),i(".")],-1),e("h3",{id:"enet",tabindex:"-1"},[i("ENET "),e("a",{class:"header-anchor",href:"#enet","aria-label":'Permalink to "ENET"'},"​")],-1),e("p",null,[i("Ethernet driver supported in i.MX RT1020 and higher. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_netnitialize"),i(".")],-1),e("p",null,[i("There is an booting option that automatically provides initialization of network interface in the early stages of booting and therefore calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_cannitialize()"),i(" via board specific logic is not necessary. This however works only when there is only one interface in the chip. For running more interfaces (like CAN and Ethernet), network late initialization must be turn on by CONFIG_NETDEV_LATEINIT and board specific logic must call lower-half part of drivers.")],-1),e("h3",{id:"flexio",tabindex:"-1"},[i("FlexIO "),e("a",{class:"header-anchor",href:"#flexio","aria-label":'Permalink to "FlexIO"'},"​")],-1),e("p",null,"A configurable module providing a range of functionality like emulation of a variety of serial/parallel communication protocols, flexible 16-bit timers or programmable logic blocks. This module is supported in i.MX RT1010 and higher.",-1),e("h3",{id:"gpio",tabindex:"-1"},[i("GPIO "),e("a",{class:"header-anchor",href:"#gpio","aria-label":'Permalink to "GPIO"'},"​")],-1),e("p",null,[i("Pins can be configured using :c"),e("code",null,"imxrt_config_gpio"),i('{.interpreted-text role="func"} function. Writing to pins is done by :c'),e("code",{class:"interpreted-text",role:"func"},"imxrt_gpio_write"),i(" function and reading is done by :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_gpio_read"),i(".")],-1),e("p",null,"MCUs i.MX RT1060 and higher includes both standard speed GPIOs (1-5) and high speed GPIOS (6-9). Regular and high speed GPIO share the same pins (GPIO1 is with GPIO6 etc), therefore IOMUXC_GPR_GPR26-29 registers are used to determine what module is used for the GPIO pins.",-1),e("h3",{id:"i2c",tabindex:"-1"},[i("I2C "),e("a",{class:"header-anchor",href:"#i2c","aria-label":'Permalink to "I2C"'},"​")],-1),e("p",null,[i("Inter-Integrated Circout module supporting an interface to an I2C bus as master and/or as a slave. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"imxrt_i2cbus_initialize"),i(".")],-1),a("",19)]))}const m=r(n,[["render",s]]);export{f as __pageData,m as default};
