import{_ as t,c as a,al as n,o}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"README","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/tiva/boards/launchxl-cc1312r1/README.md","filePath":"en/platforms/arm/tiva/boards/launchxl-cc1312r1/README.md"}'),r={name:"en/platforms/arm/tiva/boards/launchxl-cc1312r1/README.md"};function s(i,e,d,h,l,u){return o(),a("div",null,e[0]||(e[0]=[n(`<h1 id="readme" tabindex="-1">README <a class="header-anchor" href="#readme" aria-label="Permalink to &quot;README&quot;">​</a></h1><p>This directory holds NuttX board support for the TI LaunchXL-CC1312R1.</p><h1 id="contents" tabindex="-1">Contents <a class="header-anchor" href="#contents" aria-label="Permalink to &quot;Contents&quot;">​</a></h1><p>o Status o Serial Console o LEDs and Buttons o Version 1 or 2? o Running from SRAM o Using J-Link</p><h1 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h1><p>2018-12-03: Fragmentary board support in place. The initial intent of this board support is simply to assist in the CC13xx architecture development. Serious board development will occur later. Board support is missing LED and button support. 2019-02-10: Figured out how to connect J-Link and began debug. 2019-02-12: A little progress. I do make it all the way into NSH, but with no console input. 2019-02-13: NSH is now fully functional. 2019-02-17: My plan was to include develop an IEEE 802.15.4 driver using the interface code for the Cortex-M0 co-processor. Unfortunately, that interface code is a part of the TI153STACK. The source for that stack is included in the SDK. However, it looks like the licensing on that code will prevent that (it is not BSD compatible). That is a shame; I only want the Cortex-M0 interface, not TI&#39;s stack (NuttX has its own IEEE 802.15.4 stack).</p><pre><code>NOTE:  This does not prevent you as an end-user from using the TI154STACK;
it only prevents me from re-distributing any part of it.
</code></pre><h1 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h1><p>The on-board XDS110 Debugger provide a USB virtual serial console using UART0 (DIO2_RXD and DIO3_TXD).</p><p>A J-Link debugger is used (see below), then the RXD/TXD jumper pins can be used to support a serial console through these same pins via an appropriate TTL level adapter (RS-232 or USB serial).</p><h1 id="leds-and-buttons" tabindex="-1">LEDs and Buttons <a class="header-anchor" href="#leds-and-buttons" aria-label="Permalink to &quot;LEDs and Buttons&quot;">​</a></h1><h2 id="leds" tabindex="-1">LEDs <a class="header-anchor" href="#leds" aria-label="Permalink to &quot;LEDs&quot;">​</a></h2><p>The LaunchXL-cc1312R1 has two LEDs controlled by software: DIO7_GLED (CR1) and DIO6_RLED (CR2). A high output value illuminates an LED.</p><pre><code>DIO7_GLED  CR1  High output illuminuates
DIO6_RLED  CR2  High output illuminuates
</code></pre><p>If CONFIG_ARCH_LEDS is not defined, then the user can control the LEDs in any way. The definitions provided in the board.h header file can be used to access individual LEDs.</p><p>These LEDs are not used by the board port unless CONFIG_ARCH_LEDS is defined. In that case, the usage by the board port is defined in include/board.h and src/cc1312_autoleds.c. The LEDs are used to encode OS-related events as follows:</p><pre><code>SYMBOL              Meaning                  LED state
                                            GLED   RLED
------------------ ------------------------ ------ ------
LED_STARTED        NuttX has been started   OFF    OFF
LED_HEAPALLOCATE   Heap has been allocated  OFF    ON
LED_IRQSENABLED    Interrupts enabled       OFF    ON
LED_STACKCREATED   Idle stack created       ON     OFF
LED_INIRQ          In an interrupt          N/C    GLOW
LED_SIGNAL         In a signal handler      N/C    GLOW
LED_ASSERTION      An assertion failed      N/C    GLOW
LED_PANIC          The system has crashed   OFF    Blinking
LED_IDLE           MCU is is sleep mode      Not used
</code></pre><p>Thus iF GLED is statically on, NuttX has successfully booted and is, apparently, running normally. A soft glow of the RLED means that the board is taking interrupts. If GLED is off and GLED is flashing at approximately 2Hz, then a fatal error has been detected and the system has halted.</p><h2 id="buttons" tabindex="-1">Buttons <a class="header-anchor" href="#buttons" aria-label="Permalink to &quot;Buttons&quot;">​</a></h2><p>The LaunchXL-CC1312R1 has two push-puttons:</p><p>DIO13_BTN1 SW1 Low input sensed when depressed DIO14_BTN2 SW2 Low input sensed when depressed</p><h1 id="version-1-or-2" tabindex="-1">Version 1 or 2? <a class="header-anchor" href="#version-1-or-2" aria-label="Permalink to &quot;Version 1 or 2?&quot;">​</a></h1><p>Two versions of the CC1312R1 are supported selected by CONFIG_ARCH_CHIP_CC13XX_V1 or CONFIG_ARCH_CHIP_CC13XX_V2. How can you tell which one you have? Perhaps you can tell by the markings on the chip, but I do not have the secret decoder ring necessary to do that.</p><p>What you can do is enable CONFIG_DEBUG_ASSERTIONS. The firmware can determine which version you have by looking at register contents. The firmware will assert if you select the wrong version. If that occurs, switch to the other version and the assertion should go away.</p><h1 id="running-from-sram" tabindex="-1">Running from SRAM <a class="header-anchor" href="#running-from-sram" aria-label="Permalink to &quot;Running from SRAM&quot;">​</a></h1><p>The LaunchXL-CC1312R1 port supports execution from RAM. Execution from SRAM as a &quot;safe&quot; way to bring up a new board port without concern about borking the board because of a bad FLASH image.</p><p>if CONFIG_BOOT_RUNFROMFLASH=y is set in the configuration, then the code will build to run from FLASH. Otherwise (presumably CONFIG_BOOT_RUNFROMSRAM=y) the code will build to run from SRAM. This is determined by the Make.defs file in the scripts/ sub-directory. Based on those configuration settings, either scripts/flash.ld or sram.ld will be selected as the linker script file to be used.</p><h1 id="using-j-link" tabindex="-1">Using J-Link <a class="header-anchor" href="#using-j-link" aria-label="Permalink to &quot;Using J-Link&quot;">​</a></h1><p>Reference <a href="https://wiki.segger.com/CC1310%5C_LaunchPad" target="_blank" rel="noreferrer">https://wiki.segger.com/CC1310\\_LaunchPad</a> (for the CC1310 but also applies to the CC1312R1):</p><p>When shipped, the TI CC1312R1 LaunchPad evaluation board is configured to be used with the on-board debug probe. In order to use it with J-Link, the on-board debug probe needs to be isolated to make sure that it does not drive the debug signals. This can be done by removing some jumpers next to the XDS110 Out / CC1310 In connector [RXD, TXD, RST, TMS, TCK, TDO, TDI, SWO]. After isolating the on-board probe, the CC1312R1 device can be debugged using J-Link. The J-Link needs to be connected to the board using the micro JTAG connector marked &quot;Target In&quot;.</p><p>I use the Olimex ARM-JTAG-20-10 to interface with the board: <a href="https://www.olimex.com/Products/ARM/JTAG/ARM-JTAG-20-10/" target="_blank" rel="noreferrer">https://www.olimex.com/Products/ARM/JTAG/ARM-JTAG-20-10/</a></p><p>NOTE: When connecting the J-Link GDB server, the interface must be set to JTAG, not SWD as you might expect.</p><p>The RXD/TXD pins, DIO2_RXD and DIO3_TXD, can then support a Serial console using the appropriate TTL adapter (TTL to RS-232 or TTL to USB serial).</p><p>One odd behavior that I have found is after a reset from the J-Link, the SP and PC registers are not automatically set and I had to manually set them as shown below:</p><pre><code>(gdb) target remote localhost:2331
(gdb) mon reset
(gdb) mon halt
(gdb) file nuttx
(gdb) mon memu32 0
Reading from address 0x00000000 (Data = 0x20001950)
(gdb) mon memu32 4
Reading from address 0x00000004 (Data = 0x00000139)
(gdb) mon reg sp 0x20001950
Writing register (SP = 0x20001950)
(gdb) mon reg pc 0x00000139
Writing register (PC = 0x00000139)
(gdb) n
232       cc13xx_trim_device();
</code></pre>`,35)]))}const b=t(r,[["render",s]]);export{p as __pageData,b as default};
