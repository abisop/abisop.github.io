import{_ as t,c as n,al as i,o}from"./chunks/framework.NFAqBSgQ.js";const _=JSON.parse('{"title":"SocketCAN Device Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/net/socketcan.md","filePath":"en/components/net/socketcan.md"}'),c={name:"en/components/net/socketcan.md"};function r(a,e,s,l,d,u){return o(),n("div",null,e[0]||(e[0]=[i(`<h1 id="socketcan-device-drivers" tabindex="-1">SocketCAN Device Drivers <a class="header-anchor" href="#socketcan-device-drivers" aria-label="Permalink to &quot;SocketCAN Device Drivers&quot;">​</a></h1><ul><li><p><code>include/nuttx/net/netdev.h</code>. All structures and APIs needed to work with drivers are provided in this header file. The structure struct net_driver_s defines the interface and is passed to the network via <code>netdev_register()</code>.</p></li><li><p><code>include/nuttx/can.h</code>. CAN &amp; CAN FD frame data structures.</p></li><li><p><code>int netdev_register(FAR struct net_driver_s *dev, enum net_lltype_e lltype)&#39;</code>. Each driver registers itself by calling <code>netdev_register()</code>.</p></li><li><p><code>Include/nuttx/net/can.h</code>. contains lookup tables for CAN dlc to CAN FD len sizes named</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>extern const uint8_t g_can_dlc_to_len[16];</span></span>
<span class="line"><span>extern const uint8_t g_len_to_can_dlc[65];</span></span></code></pre></div></li><li><p><strong>Initialization sequence is as follows</strong>.</p><ol><li><code>xxx_netinitialize(void)</code> is called on startup of NuttX in this function you call your own init function to initialize your CAN driver</li><li>In your own init function you create the net_driver_s structure set required init values and register the required callbacks for SocketCAN</li><li>Then you ensure that the CAN interface is in down mode (usually done by calling the d_ifdown function)</li><li>Register the net_driver_s using netdev_register</li></ol></li><li><p><strong>Receive sequence is as follows</strong>.</p><ol><li>Device generates interrupt</li><li>Process this interrupt in your interrupt handler</li><li>When a new CAN frame has been received you process this frame</li><li>When the CAN frame is a normal CAN frame you allocate the can_frame struct, when it&#39;s a CAN FD frame you allocate a canfd_frame struct (note you can of course preallocate and just use the pointer).</li><li>Copy the frame from the driver to the struct you&#39;ve allocated in the previous step.</li><li>Point the net_driver_s d_buf pointer to the allocated can_frame</li><li>Call the <code>can_input(FAR struct net_driver_s *dev)</code> function <code>include/nuttx/net/can.h</code></li></ol></li><li><p><strong>Transmit sequence is as follows</strong>.</p><ol><li>Socket layer executes d_txavail callback</li><li>An example of the txavail function can be found in <code>arch/arm/src/s32k1xx/s32k1xx_flexcan.c</code></li><li>An example of the txpoll function can be found in <code>arch/arm/src/s32k1xx/s32k1xx_flexcan.c</code></li><li>In your <code>transmit(struct driver_s *priv)</code> function you check the length of <code>net_driver_s.d_len</code> whether it matches the size of a <code>struct can_frame</code> or <code>struct canfd_frame</code> then you cast the content of the <code>net_driver_s.d_buf</code> pointer to the correct CAN frame struct</li></ol></li></ul>`,2)]))}const h=t(c,[["render",r]]);export{_ as __pageData,h as default};
