import{_ as r,c as t,al as i,o as c}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Character Device Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/character/index.md","filePath":"en/components/drivers/character/index.md"}'),o={name:"en/components/drivers/character/index.md"};function s(a,e,d,n,l,p){return c(),t("div",null,e[0]||(e[0]=[i('<h1 id="character-device-drivers" tabindex="-1">Character Device Drivers <a class="header-anchor" href="#character-device-drivers" aria-label="Permalink to &quot;Character Device Drivers&quot;">â€‹</a></h1><p>Character device drivers have these properties:</p><ul><li><p><code>include/nuttx/fs/fs.h</code>. All structures and APIs needed to work with character drivers are provided in this header file.</p></li><li><p><code>struct file_operations</code>. Each character device driver must implement an instance of <code>struct file_operations</code>. That structure defines a call table with the following methods:</p></li><li><p><code>int register_driver(const char *path, const struct file_operations *fops, mode_t mode, void *priv);</code>. Each character driver registers itself by calling <code>register_driver()</code>, passing it the <code>path</code> where it will appear in the <code>pseudo file system &lt;file_system_overview&gt;</code>{.interpreted-text role=&quot;ref&quot;} and it&#39;s initialized instance of <code>struct file_operations</code>.</p></li><li><p><strong>User Access</strong>. After it has been registered, the character driver can be accessed by user code using the standard driver operations including <code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, etc.</p></li><li><p><strong>Specialized Character Drivers</strong>. Within the common character driver framework, there are different specific varieties of <em>specialized</em> character drivers. The unique requirements of the underlying device hardware often mandates some customization of the character driver. These customizations tend to take the form of:</p><ul><li>Device-specific <code>ioctl()</code> commands used to performed specialized operations on the device. These <code>ioctl()</code> will be documented in header files under <code>include/nuttx</code> that detail the specific device interface.</li><li>Specialized I/O formats. Some devices will require that <code>read()</code> and/or <code>write()</code> operations use data conforming to a specific format, rather than a plain stream of bytes. These specialized I/O formats will be documented in header files under <code>include/nuttx</code> that detail the specific device interface. The typical representation of the I/O format will be a C structure definition.</li></ul><p>The specialized character drivers support by NuttX are documented in the following paragraphs.</p></li><li><p><strong>Examples</strong>: <code>drivers/dev_null.c</code>, <code>drivers/fifo.c</code>, <code>drivers/serial.c</code>, etc.</p></li></ul><blockquote><p>1wire.rst analog/index.rst bch.rst can.rst contactless.rst crypto/index.rst efuse.rst i2s.rst input/index.rst ipcc.rst leds/index.rst loop.rst math.rst modem.rst motor/index.rst note.rst nullzero.rst quadrature.rst rc.rst rf.rst serial.rst timers/index.rst touchscreen.rst wireless/index.rst</p></blockquote>',4)]))}const f=r(o,[["render",s]]);export{u as __pageData,f as default};
