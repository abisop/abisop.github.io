import{_ as a,c as n,al as t,o as s}from"./chunks/framework.NFAqBSgQ.js";const o="/assets/ESP32-C3-DevKitC-02-v1.1.DqUUwuPA.png",i="/assets/ESP32-C3-DevKitM-1-v1.0.DDeUOQlK.png",r="data:image/png;base64,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",g=JSON.parse('{"title":"ESP32-C3 DevKit","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/risc-v/esp32c3/boards/esp32c3-generic/index.md","filePath":"en/platforms/risc-v/esp32c3/boards/esp32c3-generic/index.md"}'),p={name:"en/platforms/risc-v/esp32c3/boards/esp32c3-generic/index.md"};function c(d,e,h,A,l,u){return s(),n("div",null,e[0]||(e[0]=[t('<h1 id="esp32-c3-devkit" tabindex="-1">ESP32-C3 DevKit <a class="header-anchor" href="#esp32-c3-devkit" aria-label="Permalink to &quot;ESP32-C3 DevKit&quot;">​</a></h1><p>The ESP32-C3 DevKit is an entry-level development board equipped with either an ESP32-C3-WROOM-02 or an ESP32-C3-MINI-1. ESP32-C3-WROOM-02 and ESP32-C3-MINI-1 are SoMs based on the RISC-V ESP32-C3 CPU.</p><p>Most of the I/O pins are broken out to the pin headers on both sides for easy interfacing. Developers can either connect peripherals with jumper wires or mount ESP32-C3 DevKit on a breadboard.</p><hr><p><img src="'+o+'" alt="ESP32-C3-DevKitC-02" class="align-center"> <img src="'+i+`" alt="ESP32-C3-DevKitM-1" class="align-center"></p><hr><h2 id="buttons-and-leds" tabindex="-1">Buttons and LEDs <a class="header-anchor" href="#buttons-and-leds" aria-label="Permalink to &quot;Buttons and LEDs&quot;">​</a></h2><h3 id="board-buttons" tabindex="-1">Board Buttons <a class="header-anchor" href="#board-buttons" aria-label="Permalink to &quot;Board Buttons&quot;">​</a></h3><p>There are two buttons labeled Boot and RST. The RST button is not available to software. It pulls the chip enable line that doubles as a reset line.</p><p>The BOOT button is connected to IO9. On reset it is used as a strapping pin to determine whether the chip boots normally or into the serial bootloader. After reset, however, the BOOT button can be used for software input.</p><h3 id="board-leds" tabindex="-1">Board LEDs <a class="header-anchor" href="#board-leds" aria-label="Permalink to &quot;Board LEDs&quot;">​</a></h3><p>There is one on-board LED that indicates the presence of power. Another WS2812 LED is connected to GPIO8 and is available for software.</p><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><p>All of the configurations presented below can be tested by running the following commands:</p><pre><code> ./tools/configure.sh esp32c3-generic:&lt;config_name&gt;
 make flash ESPTOOL_PORT=/dev/ttyUSB0 -j
</code></pre><p>Where &lt;config_name&gt; is the name of board configuration you want to use, i.e.: nsh, buttons, wifi... Then use a serial console terminal like <code>picocom</code> configured to 115200 8N1.</p><h3 id="adc" tabindex="-1">adc <a class="header-anchor" href="#adc" aria-label="Permalink to &quot;adc&quot;">​</a></h3><p>The <code>adc</code> configuration enables the ADC driver and the ADC example application. ADC Unit 1 is registered to <code>/dev/adc0</code> with channels 0, 1, 2 and 3 enabled by default. Currently, the ADC operates in oneshot mode.</p><p>More ADC channels can be enabled or disabled in <code>ADC Configuration</code> menu.</p><p>This example shows channels 0 and 1 connected to 3.3 V and channels 2 and 3 to GND (all readings show in units of mV):</p><pre><code>nsh&gt; adc -n 1
adc_main: g_adcstate.count: 1
adc_main: Hardware initialized. Opening the ADC device: /dev/adc0
Sample:
1: channel: 0 value: 2900
2: channel: 1 value: 2900
3: channel: 2 value: 0
4: channel: 3 value: 0
</code></pre><h3 id="ble" tabindex="-1">ble <a class="header-anchor" href="#ble" aria-label="Permalink to &quot;ble&quot;">​</a></h3><p>This configuration is used to enable the Bluetooth Low Energy (BLE) of ESP32-C3 chip.</p><p>To test it, just run the following commands below.</p><p>Confirm that bnep interface exist:</p><pre><code>nsh&gt; ifconfig
bnep0   Link encap:UNSPEC at DOWN
    inet addr:0.0.0.0 DRaddr:0.0.0.0 Mask:0.0.0.0
</code></pre><p>Get basic information from it:</p><pre><code>nsh&gt; bt bnep0 info
Device: bnep0
BDAddr: 86:f7:03:09:41:4d
Flags:  0000
Free:   20
  ACL:  20
  SCO:  0
Max:
  ACL:  24
  SCO:  0
MTU:
  ACL:  70
  SCO:  70
Policy: 0
Type:   0
</code></pre><p>Start the scanning process:</p><pre><code>nsh&gt; bt bnep0 scan start
</code></pre><p>Wait a little bit before stopping it.</p><p>Then after some minutes stop it:</p><pre><code>nsh&gt; bt bnep0 scan stop
</code></pre><p>Get the list of BLE devices found around you:</p><pre><code>nsh&gt; bt bnep0 scan get
Scan result:
1.     addr:           d7:c4:e6:xx:xx:xx type: 0
       rssi:            -62
       response type:   4
       advertiser data: 10 09 4d 69 20 XX XX XX XX XX XX XX XX XX XX 20                      e
2.     addr:           cb:23:18:xx:xx:xx type: 0
       rssi:            -60
       response type:   0
       advertiser data: 02 01 06 1b ff XX XX XX ff ff ff ff ff ff ff ff                      8
3.     addr:           cb:23:18:xx:xx:xx type: 0
       rssi:            -60
       response type:   4
       advertiser data: 10 09 4d 69 20 XX XX XX XX XX XX XX XX XX XX 20                      e
4.     addr:           d7:c4:e6:xx:xx:xx type: 0
       rssi:            -62
       response type:   0
       advertiser data: 02 01 06 1b ff XX XX XX ff ff ff ff ff ff ff ff                      e
5.     addr:           d7:c4:e6:xx:xx:xx type: 0
       rssi:            -62
       response type:   4
       advertiser data: 10 09 4d 69 20 XX XX XX XX XX XX XX XX XX XX 20                      e
nsh&gt;
</code></pre><h3 id="bmp180" tabindex="-1">bmp180 <a class="header-anchor" href="#bmp180" aria-label="Permalink to &quot;bmp180&quot;">​</a></h3><p>This configuration enables the use of the BMP180 pressure sensor over I2C. You can check that the sensor is working by using the <code>bmp180</code> application:</p><pre><code>nsh&gt; bmp180
Pressure value = 91531
Pressure value = 91526
Pressure value = 91525
</code></pre><h3 id="coremark" tabindex="-1">coremark <a class="header-anchor" href="#coremark" aria-label="Permalink to &quot;coremark&quot;">​</a></h3><p>This configuration sets the CoreMark benchmark up for running on the maximum number of cores for this system. It also enables some optimization flags and disables the NuttShell to get the best possible score.</p><p>Note</p><p>As the NSH is disabled, the application will start as soon as the system is turned on.</p><h3 id="efuse" tabindex="-1">efuse <a class="header-anchor" href="#efuse" aria-label="Permalink to &quot;efuse&quot;">​</a></h3><p>This configuration demonstrates the use of the eFuse driver. It can be accessed through the <code>/dev/efuse</code> device file. Virtual eFuse mode can be used by enabling [CONFIG_ESPRESSIF_EFUSE_VIRTUAL]{.title-ref} option to prevent possible damages on chip.</p><p>The following snippet demonstrates how to read MAC address:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int fd;</span></span>
<span class="line"><span>int ret;</span></span>
<span class="line"><span>uint8_t mac[6];</span></span>
<span class="line"><span>struct efuse_param_s param;</span></span>
<span class="line"><span>struct efuse_desc_s mac_addr =</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  .bit_offset = 1,</span></span>
<span class="line"><span>  .bit_count = 48</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const efuse_desc_t* desc[] =</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    &amp;mac_addr,</span></span>
<span class="line"><span>    NULL</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>param.field = desc;</span></span>
<span class="line"><span>param.size = 48;</span></span>
<span class="line"><span>param.data = mac;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fd = open(&quot;/dev/efuse&quot;, O_RDONLY);</span></span>
<span class="line"><span>ret = ioctl(fd, EFUSEIOC_READ_FIELD, &amp;param);</span></span></code></pre></div><p>To find offset and count variables for related eFuse, please refer to Espressif&#39;s Technical Reference Manuals.</p><h3 id="gpio" tabindex="-1">gpio <a class="header-anchor" href="#gpio" aria-label="Permalink to &quot;gpio&quot;">​</a></h3><p>This is a test for the GPIO driver. It uses GPIO1 and GPIO2 as outputs and GPIO9 as an interrupt pin.</p><p>At the nsh, we can turn the outputs on and off with the following:</p><pre><code>nsh&gt; gpio -o 1 /dev/gpio0
nsh&gt; gpio -o 1 /dev/gpio1

nsh&gt; gpio -o 0 /dev/gpio0
nsh&gt; gpio -o 0 /dev/gpio1
</code></pre><p>We can use the interrupt pin to send a signal when the interrupt fires:</p><pre><code>nsh&gt; gpio -w 14 /dev/gpio2
</code></pre><p>The pin is configured as a rising edge interrupt, so after issuing the above command, connect it to 3.3V.</p><h3 id="i2c" tabindex="-1">i2c <a class="header-anchor" href="#i2c" aria-label="Permalink to &quot;i2c&quot;">​</a></h3><p>This configuration can be used to scan and manipulate I2C devices. You can scan for all I2C devices using the following command:</p><pre><code>nsh&gt; i2c dev 0x00 0x7f
</code></pre><p>To use slave mode, you can enable [ESPRESSIF_I2C0_SLAVE_MODE]{.title-ref} option. To use slave mode driver following snippet demonstrates how write to i2c bus using slave driver:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#define ESP_I2C_SLAVE_PATH  &quot;/dev/i2cslv0&quot;</span></span>
<span class="line"><span>int main(int argc, char *argv[])</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    int i2c_slave_fd;</span></span>
<span class="line"><span>    int ret;</span></span>
<span class="line"><span>    uint8_t buffer[5] = {0xAA};</span></span>
<span class="line"><span>    i2c_slave_fd = open(ESP_I2C_SLAVE_PATH, O_RDWR);</span></span>
<span class="line"><span>    ret = write(i2c_slave_fd, buffer, 5);</span></span>
<span class="line"><span>    close(i2c_slave_fd);</span></span>
<span class="line"><span> }</span></span></code></pre></div><h3 id="i2schar" tabindex="-1">i2schar <a class="header-anchor" href="#i2schar" aria-label="Permalink to &quot;i2schar&quot;">​</a></h3><p>This configuration enables the I2S character device and the i2schar example app, which provides an easy-to-use way of testing the I2S peripheral, enabling both the TX and the RX for those peripherals.</p><p><strong>I2S pinout</strong></p><p>ESP32-C3 Pin Signal Pin Description</p><hr><p>0 MCLK Master Clock 4 SCLK Bit Clock (SCLK) 5 LRCK Word Select (LRCLK) 18 DOUT Data Out 19 DIN Data In</p><p>After successfully built and flashed, run on the boards&#39;s terminal:</p><pre><code>nsh&gt; i2schar
</code></pre><h3 id="nimble" tabindex="-1">nimble <a class="header-anchor" href="#nimble" aria-label="Permalink to &quot;nimble&quot;">​</a></h3><p>This configuration can be used to test ble using the nimble library. The <code>nimble</code> example starts advertising and can be connected to or disconnected from. Before starting the <code>nimble</code> example make sure the bnep0 interface is up by issuing:</p><pre><code>nsh&gt; ifup bnep0
ifup bnep0...OK
nsh&gt; nimble &amp;
</code></pre><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>Basic configuration to run the NuttShell (nsh).</p><h3 id="ostest" tabindex="-1">ostest <a class="header-anchor" href="#ostest" aria-label="Permalink to &quot;ostest&quot;">​</a></h3><p>This is the NuttX test at <code>apps/testing/ostest</code> that is run against all new architecture ports to assure a correct implementation of the OS.</p><h3 id="pwm" tabindex="-1">pwm <a class="header-anchor" href="#pwm" aria-label="Permalink to &quot;pwm&quot;">​</a></h3><p>This configuration demonstrates the use of PWM through a LED connected to GPIO2. To test it, just execute the <code>pwm</code> application:</p><pre><code>nsh&gt; pwm
pwm_main: starting output with frequency: 10000 duty: 00008000
pwm_main: stopping output
</code></pre><h3 id="rmt" tabindex="-1">rmt <a class="header-anchor" href="#rmt" aria-label="Permalink to &quot;rmt&quot;">​</a></h3><p>This configuration configures the transmitter and the receiver of the Remote Control Transceiver (RMT) peripheral on the ESP32-C3 using GPIOs 8 and 2, respectively. The RMT peripheral is better explained <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-reference/peripherals/rmt.html" target="_blank" rel="noreferrer">here</a>, in the ESP-IDF documentation. The minimal data unit in the frame is called the RMT symbol, which is represented by <code>rmt_item32_t</code> in the driver:</p><p><img src="`+r+`" alt="" class="align-center"></p><p>The example <code>rmtchar</code> can be used to test the RMT peripheral. Connecting these pins externally to each other will make the transmitter send RMT items and demonstrates the usage of the RMT peripheral:</p><pre><code>nsh&gt; rmtchar
</code></pre><p><strong>WS2812 addressable RGB LEDs</strong></p><p>This same configuration enables the usage of the RMT peripheral and the example <code>ws2812</code> to drive addressable RGB LEDs:</p><pre><code>nsh&gt; ws2812
</code></pre><p>Please note that this board contains an on-board WS2812 LED connected to GPIO8 and, by default, this config configures the RMT transmitter in the same pin.</p><h3 id="rtc" tabindex="-1">rtc <a class="header-anchor" href="#rtc" aria-label="Permalink to &quot;rtc&quot;">​</a></h3><p>This configuration demonstrates the use of the RTC driver through alarms. You can set an alarm, check its progress and receive a notification after it expires:</p><pre><code>nsh&gt; alarm 10
alarm_daemon started
alarm_daemon: Running
Opening /dev/rtc0
Alarm 0 set in 10 seconds
nsh&gt; alarm -r
Opening /dev/rtc0
Alarm 0 is active with 10 seconds to expiration
nsh&gt; alarm_daemon: alarm 0 received
</code></pre><h3 id="spi" tabindex="-1">spi <a class="header-anchor" href="#spi" aria-label="Permalink to &quot;spi&quot;">​</a></h3><p>This configuration enables the support for the SPI driver. You can test it by connecting MOSI and MISO pins which are GPIO7 and GPIO2 by default to each other and running the <code>spi</code> example:</p><pre><code>nsh&gt; spi exch -b 2 &quot;AB&quot;
Sending:    AB
Received:   AB
</code></pre><p>If SPI peripherals are already in use you can also use bitbang driver which is a software implemented SPI peripheral by enabling [CONFIG_ESPRESSIF_SPI_BITBANG]{.title-ref} option.</p><h3 id="spiflash" tabindex="-1">spiflash <a class="header-anchor" href="#spiflash" aria-label="Permalink to &quot;spiflash&quot;">​</a></h3><p>This config tests the external SPI that comes with the ESP32-C3 module connected through SPI1.</p><p>By default a SmartFS file system is selected. Once booted you can use the following commands to mount the file system:</p><pre><code>nsh&gt; mksmartfs /dev/smart0
nsh&gt; mount -t smartfs /dev/smart0 /mnt
</code></pre><h3 id="sta-softap" tabindex="-1">sta_softap <a class="header-anchor" href="#sta-softap" aria-label="Permalink to &quot;sta\\_softap&quot;">​</a></h3><p>With this configuration you can run these commands to be able to connect your smartphone or laptop to your board:</p><pre><code>nsh&gt; ifup wlan1
nsh&gt; dhcpd_start wlan1
nsh&gt; wapi psk wlan1 mypasswd 3
nsh&gt; wapi essid wlan1 nuttxap 1
</code></pre><p>In this case, you are creating the access point <code>nuttxapp</code> in your board and to connect to it on your smartphone you will be required to type the password <code>mypasswd</code> using WPA2.</p><p>Tip</p><p>Please refer to <code>ESP32 Wi-Fi SoftAP Mode &lt;esp32_wi-fi_softap&gt;</code>{.interpreted-text role=&quot;ref&quot;} for more information.</p><p>The <code>dhcpd_start</code> is necessary to let your board to associate an IP to your smartphone.</p><h3 id="timer" tabindex="-1">timer <a class="header-anchor" href="#timer" aria-label="Permalink to &quot;timer&quot;">​</a></h3><p>This config test the general use purpose timers. It includes the 4 timers, adds driver support, registers the timers as devices and includes the timer example.</p><p>To test it, just run the following:</p><pre><code>nsh&gt; timer -d /dev/timerx
</code></pre><p>Where x in the timer instance.</p><h3 id="twai" tabindex="-1">twai <a class="header-anchor" href="#twai" aria-label="Permalink to &quot;twai&quot;">​</a></h3><p>This configuration enables the support for the TWAI (Two-Wire Automotive Interface) driver. You can test it by connecting TWAI RX and TWAI TX pins which are GPIO0 and GPIO2 by default to an external transceiver or connecting TWAI RX to TWAI TX pin by enabling the [CONFIG_CAN_LOOPBACK]{.title-ref} option (<code>Device Drivers -&gt; CAN Driver Support -&gt; CAN loopback mode</code>) and running the <code>can</code> example:</p><pre><code>nsh&gt; can
nmsgs: 0
min ID: 1 max ID: 2047
Bit timing:
  Baud: 1000000
  TSEG1: 15
  TSEG2: 4
    SJW: 3
  ID:    1 DLC: 1
</code></pre><h3 id="usbconsole" tabindex="-1">usbconsole <a class="header-anchor" href="#usbconsole" aria-label="Permalink to &quot;usbconsole&quot;">​</a></h3><p>This configuration tests the built-in USB-to-serial converter found in ESP32-C3 (revision 3). <code>esptool</code> can be used to check the version of the chip and if this feature is supported. Running <code>esptool.py -p &lt;port&gt; chip_id</code> should have <code>Chip is ESP32-C3 (revision 3)</code> in its output. When connecting the board a new device should appear, a <code>/dev/ttyACMX</code> on Linux or a <code>/dev/cu.usbmodemXXX</code> om macOS. This can be used to flash and monitor the device with the usual commands:</p><pre><code>make download ESPTOOL_PORT=/dev/ttyACM0
minicom -D /dev/ttyACM0
</code></pre><h3 id="watchdog" tabindex="-1">watchdog <a class="header-anchor" href="#watchdog" aria-label="Permalink to &quot;watchdog&quot;">​</a></h3><p>This configuration tests the watchdog timers. It includes the 2 MWDTS, adds driver support, registers the WDTs as devices and includes the watchdog example application.</p><p>To test it, just run the following command:</p><pre><code>nsh&gt; wdog -i /dev/watchdogX
</code></pre><p>Where X is the watchdog instance.</p><p>To test the XTWDT(/dev/watchdog3) an interrupt handler needs to be implemented because XTWDT does not have system reset feature. To implement an interrupt handler [WDIOC_CAPTURE]{.title-ref} command can be used. When interrupt rises, XTAL32K clock can be restored with [WDIOC_RSTCLK]{.title-ref} command.</p><h3 id="wifi" tabindex="-1">wifi <a class="header-anchor" href="#wifi" aria-label="Permalink to &quot;wifi&quot;">​</a></h3><p>Enables Wi-Fi support. You can define your credentials this way:</p><pre><code> make menuconfig
-&gt; Application Configuration
    -&gt; Network Utilities
        -&gt; Network initialization (NETUTILS_NETINIT [=y])
            -&gt; WAPI Configuration
</code></pre><p>Or if you don&#39;t want to keep it saved in the firmware you can do it at runtime:</p><pre><code>nsh&gt; wapi psk wlan0 mypasswd 3
nsh&gt; wapi essid wlan0 myssid 1
nsh&gt; renew wlan0
</code></pre><p>Tip</p><p>Please refer to <code>ESP32 Wi-Fi Station Mode &lt;esp32_wi-fi_sta&gt;</code>{.interpreted-text role=&quot;ref&quot;} for more information.</p>`,128)]))}const m=a(p,[["render",c]]);export{g as __pageData,m as default};
