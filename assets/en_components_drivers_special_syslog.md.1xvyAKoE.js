import{_ as i,c as n,al as o,j as e,a as t,o as s}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"SYSLOG","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/special/syslog.md","filePath":"en/components/drivers/special/syslog.md"}'),l={name:"en/components/drivers/special/syslog.md"};function r(c,a,d,h,u,p){return s(),n("div",null,a[0]||(a[0]=[o('<h1 id="syslog" tabindex="-1">SYSLOG <a class="header-anchor" href="#syslog" aria-label="Permalink to &quot;SYSLOG&quot;">​</a></h1><h2 id="syslog-interfaces" tabindex="-1">SYSLOG Interfaces <a class="header-anchor" href="#syslog-interfaces" aria-label="Permalink to &quot;SYSLOG Interfaces&quot;">​</a></h2><h3 id="standard-syslog-interfaces" tabindex="-1">Standard SYSLOG Interfaces <a class="header-anchor" href="#standard-syslog-interfaces" aria-label="Permalink to &quot;Standard SYSLOG Interfaces&quot;">​</a></h3><p>The NuttX SYSLOG is an architecture for getting debug and status information from the system. The syslogging interfaces are defined in the header file <code>include/syslog.h</code>. The primary interface to SYSLOG sub-system is the function <code>syslog()</code> and, to a lesser extent, its companion <code>vsyslog()</code>:</p><p>function:: int syslog(int priority, FAR const IPTR char *format, ...);</p><p>Generates a log message. The priority argument is formed by ORing the facility and the level values (see <code>include/syslog.h</code>). The remaining arguments are a format, as in <code>printf()</code> and any arguments to the format.</p><p>The NuttX implementation does not support any special formatting characters beyond those supported by <code>printf()</code>.</p><p>function:: void vsyslog(int priority, FAR const IPTR char *src, va_list ap);</p>',8),e("p",null,[t("Performs the same task as :c"),e("code",{class:"interpreted-text",role:"func"},"syslog"),t(" with the difference that it takes a set of arguments which have been obtained using the "),e("code",null,"stdarg"),t(" variable argument list macros.")],-1),o(`<p>function:: int setlogmask(int mask);</p><p>The additional setlogmask() interface can use use to filter SYSLOG output. This function sets the logmask and returns the previous mask. If the mask argument is zero, the current logmask is not modified.</p><p>The SYSLOG priorities are: <code>LOG_EMERG</code>, <code>LOG_ALERT</code>, <code>LOG_CRIT</code>, <code>LOG_ERR</code>, <code>LOG_WARNING</code>, <code>LOG_NOTICE</code>, <code>LOG_INFO</code>, and <code>LOG_DEBUG</code>. The bit corresponding to a priority <code>p</code> is <code>LOG_MASK(p)</code>; <code>LOG_UPTO(p)</code> provides the mask of all priorities in the above list up to and including <code>p</code>.</p><p>Per <em>OpenGroup.org</em> &quot;If the <code>maskpri</code> argument is 0, the current log mask is not modified.&quot; In this implementation, the value zero is permitted in order to disable all SYSLOG levels.</p><p>Note</p><p>REVISIT: Per POSIX the SYSLOG mask should be a per-process value but in NuttX, the scope of the mask is dependent on the nature of the build:</p><ul><li><em>Flat Build</em>: There is one, global SYSLOG mask that controls all output.</li><li><em>Protected Build</em>: There are two SYSLOG masks. One within the kernel that controls only kernel output. And one in user-space that controls only user SYSLOG output.</li><li><em>Kernel Build</em>: The kernel build is compliant with the POSIX requirement: There will be one mask for for each user process, controlling the SYSLOG output only form that process. There will be a separate mask accessible only in the kernel code to control kernel SYSLOG output.</li></ul><p>The above are all standard interfaces as defined at <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/closelog.html" target="_blank" rel="noreferrer">OpenGroup.org</a>. Those interfaces are available for use by application software. The remaining interfaces discussed in this section are non-standard, OS-internal interfaces.</p><h3 id="debug-interfaces" tabindex="-1">Debug Interfaces <a class="header-anchor" href="#debug-interfaces" aria-label="Permalink to &quot;Debug Interfaces&quot;">​</a></h3><p>In NuttX, syslog output is really synonymous to debug output and, therefore, the debugging interface macros defined in the header file <code>include/debug.h</code> are also syslogging interfaces. Those macros are simply wrappers around <code>syslog()</code>. The debugging interfaces differ from the syslog interfaces in that:</p><blockquote><ul><li>They do not take a priority parameter; the priority is inherent in the debug macro name.</li><li>They decorate the output stream with information such as the file name</li><li>They can each be disabled via configuration options.</li></ul></blockquote><p>Each debug macro has a base name that represents the priority and a prefix that represents the sub-system. Each macro is individually initialized by both priority and sub-system. For example, <code>uerr()</code> is the macro used for error level messages from the USB subsystem and is enabled with <code>CONFIG_DEBUG_USB_ERROR</code>.</p><p>The base debug macro names, their priority, and configuration variable are summarized below:</p><ul><li><code>info()</code>. The <code>info()</code> macro is the lowest priority (<code>LOG_INFO</code>) and is intended to provide general information about the flow of program execution so that you can get an overview of the behavior of the program. <code>info()</code> is often very chatty and voluminous and usually more information than you may want to see. The <code>info()</code> macro is controlled via CONFIG_DEBUG_subsystem_INFO</li><li><code>warn()</code>. The <code>warn()</code> macro has medium priority (<code>LOG_WARN</code>) and is controlled by <code>CONFIG_DEBUG_subsystem_WARN</code>. The <code>warn()</code> is intended to note exceptional or unexpected conditions that might be potential errors or, perhaps, minor errors that easily recovered.</li><li><code>err()</code>. This is a high priority debug macro (<code>LOG_ERROR</code>) and controlled by <code>CONFIG_DEBUG_subsystem_ERROR</code>. The <code>err()</code> is reserved to indicate important error conditions.</li><li><code>alert()</code>. The highest priority debug macro (<code>LOG_EMERG</code>) and is controlled by <code>CONFIG_DEBUG_ALERT</code>. The <code>alert()</code> macro is reserved for use solely by assertion and crash handling logic. It also differs from the other macros in that it cannot be enabled or disabled per subsystem.</li></ul><h2 id="syslog-channels" tabindex="-1">SYSLOG Channels <a class="header-anchor" href="#syslog-channels" aria-label="Permalink to &quot;SYSLOG Channels&quot;">​</a></h2><h3 id="syslog-channel-interfaces" tabindex="-1">SYSLOG Channel Interfaces <a class="header-anchor" href="#syslog-channel-interfaces" aria-label="Permalink to &quot;SYSLOG Channel Interfaces&quot;">​</a></h3><p>In the NuttX SYSLOG implementation, the underlying device logic the supports the SYSLOG output is referred to as a SYSLOG <em>channel</em>. Each SYSLOG channel is represented by an interface defined in <code>include/nuttx/syslog/syslog.h</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* This structure provides the interface to a SYSLOG device */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>typedef CODE int (*syslog_putc_t)(int ch);</span></span>
<span class="line"><span>typedef CODE int (*syslog_flush_t)(void);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct syslog_channel_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  /* I/O redirection methods */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  syslog_putc_t sc_putc;    /* Normal buffered output */</span></span>
<span class="line"><span>  syslog_putc_t sc_force;   /* Low-level output for interrupt handlers */</span></span>
<span class="line"><span>  syslog_flush_t sc_flush;  /* Flush buffered output (on crash) */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Implementation specific logic may follow */</span></span>
<span class="line"><span>};</span></span></code></pre></div>`,18),e("p",null,[t("The channel interface is instantiated by calling :c"),e("code",{class:"interpreted-text",role:"func"},"syslog_channel_register()"),t(".")],-1),o('<h3 id="syslog-channel-initialization" tabindex="-1">SYSLOG Channel Initialization <a class="header-anchor" href="#syslog-channel-initialization" aria-label="Permalink to &quot;SYSLOG Channel Initialization&quot;">​</a></h3><p>The initial, default SYSLOG channel is established with statically initialized global variables so that some level of SYSLOG output may be available immediately upon reset. This initialized data is in the file <code>drivers/syslog/syslog_channel.c</code>. The initial SYSLOG capability is determined by the selected SYSLOG channel:</p><ul><li><em>In-Memory Buffer (RAMLOG)</em>. Full SYSLOG capability as available at reset.</li><li><em>Serial Console</em>. If the serial implementation provides the low-level character output function <code>up_putc()</code>, then that low level serial output is available as soon as the serial device has been configured.</li><li>For all other SYSLOG channels, all SYSLOG output goes to the bit- bucket until the SYSLOG channel device has been initialized.</li></ul>',3),e("p",null,[t("The syslog channel device is initialized when the bring-up logic calls :c"),e("code",{class:"interpreted-text",role:"func"},"syslog_initialize()"),t(".")],-1),o('<p>Different types of SYSLOG devices have different OS initialization requirements. Some are available immediately at reset, some are available after some basic OS initialization, and some only after OS is fully initialized.</p><p>There are other types of SYSLOG channel devices that may require even further initialization. For example, the file SYSLOG channel (described below) cannot be initialized until the necessary file systems have been mounted.</p><h3 id="syslog-channel-filtering" tabindex="-1">SYSLOG Channel Filtering <a class="header-anchor" href="#syslog-channel-filtering" aria-label="Permalink to &quot;SYSLOG Channel Filtering&quot;">​</a></h3><p>If you enable the CONFIG_SYSLOG_IOCTL configuration, you can enable syslog to open or close the specified channel at runtime.</p><p>You can control SYSLOG channels by using the ioctl command in NuttX with either the SYSLOGIOC_GETCHANNELS or SYSLOGIOC_SETFILTER.</p><ul><li><code>SYSLOGIOC_GETCHANNELS</code>. This command can get a list of all channels</li><li><code>SYSLOGIOC_SETFILTER</code>. This command enables/disables the specified channel.</li></ul><p>In nsh, you can view/set the syslog channel status through the setlogmask command.</p><ul><li><code>setlogmask list</code>. Print all channel status</li><li><code>setlogmask &lt;enable/disable&gt; &lt;channel&gt;</code>. Enable or disable the specified channel.</li></ul><h3 id="interrupt-level-syslog-output" tabindex="-1">Interrupt Level SYSLOG Output <a class="header-anchor" href="#interrupt-level-syslog-output" aria-label="Permalink to &quot;Interrupt Level SYSLOG Output&quot;">​</a></h3><p>As a general statement, SYSLOG output only supports <em>normal</em> output from NuttX tasks. However, for debugging purposes, it is also useful to get SYSLOG output from interrupt level logic. In an embedded system, that is often where the most critical operations are performed.</p><p>There are three conditions under which SYSLOG output generated from interrupt level processing can a included the SYSLOG output stream:</p><blockquote><ol><li><p><strong>Low-Level Serial Output</strong>. If you are using the &quot;default&quot; SYSLOG channel (<code>CONFIG_SYSLOG_DEFAULT</code>) and if the underlying architecture supports the low-level <code>up_putc()</code> interface(<code>CONFIG_ARCH_LOWPUTC</code>), then the SYSLOG logic will direct the output to <code>up_putc()</code> which is capable of generating the serial output within the context of an interrupt handler.</p><p>There are a few issues in doing this however:</p><ul><li><code>up_putc()</code> is able to generate debug output in any context because it disables serial interrupts and polls the hardware directly. These polls may take many milliseconds and during that time, all interrupts are disable within the interrupt handler. This, of course, interferes with the real-time behavior of the RTOS.</li><li>The output generated by <code>up_putc()</code> is immediate and in real-time. The normal SYSLOG output, on the other hand, is buffered in the serial driver and may be delayed with respect to the immediate output by many lines. Therefore, the interrupt level SYSLOG output provided through <code>up_putc()</code> is grossly out of synchronization with other debug output</li></ul></li><li><p><strong>In-Memory Buffering</strong>. If the RAMLOG SYSLOG channel is supported, then all SYSLOG output is buffered in memory. Interrupt level SYSLOG output is no different than normal SYSLOG output in this case.</p></li><li><p><strong>Serialization Buffer</strong>. A final option is the use of an <em>interrupt buffer</em> to buffer the interrupt level SYSLOG output. In this case:</p><ul><li>SYSLOG output generated from interrupt level process in not sent to the SYSLOG channel immediately. Rather, it is buffered in the interrupt serialization buffer.</li><li>Later, when the next normal syslog output is generated, it will first empty the content of the interrupt buffer to the SYSLOG device in the proper context. It will then be followed by the normal syslog output. In this case, the interrupt level SYSLOG output will interrupt the normal output stream and the interrupt level SYSLOG output will be inserted into the correct position in the SYSLOG output when the next normal SYSLOG output is generated.</li></ul></li></ol></blockquote><p>The SYSLOG interrupt buffer is enabled with <code>CONFIG_SYSLOG_INTBUFFER</code>. When the interrupt buffer is enabled, you must also provide the size of the interrupt buffer with <code>CONFIG_SYSLOG_INTBUFSIZE</code>.</p><h2 id="syslog-channel-options" tabindex="-1">SYSLOG Channel Options <a class="header-anchor" href="#syslog-channel-options" aria-label="Permalink to &quot;SYSLOG Channel Options&quot;">​</a></h2><h3 id="syslog-console-device" tabindex="-1">SYSLOG Console Device <a class="header-anchor" href="#syslog-console-device" aria-label="Permalink to &quot;SYSLOG Console Device&quot;">​</a></h3><p>The typical SYSLOG device is the system console. If you are using a serial console, for example, then the SYSLOG output will appear on that serial port.</p><p>This SYSLOG channel is automatically selected by <code>syslog_initialize()</code> in the LATE initialization phase based on configuration options. The configuration options that affect this channel selection include:</p><blockquote><ul><li><code>CONFIG_DEV_CONSOLE</code>. This setting indicates that the system supports a console device, i.e., that the character device <code>/dev/console</code> exists.</li><li><code>CONFIG_SERIAL_CONSOLE</code>. This configuration option is automatically selected when a UART or USART is configured as the system console. There is no user selection.</li><li><code>CONFIG_SYSLOG_CONSOLE</code>. This configuration option is manually selected from the SYSLOG menu. This is the option that actually enables the SYSLOG console device. It depends on <code>CONFIG_DEV_CONSOLE</code>.</li><li><code>CONFIG_ARCH_LOWPUTC</code>. This is an indication from the architecture configuration that the platform supports the <code>up_putc()</code> interface. <code>up_putc()</code> is a very low level UART interface that can even be used from interrupt handling.</li></ul></blockquote><p>Interrupt level SYSLOG output will be lost unless: (1) the interrupt buffer is enabled to support serialization, or (2) a serial console is used and <code>up_putc()</code> is supported.</p><p>Note</p><p>The console channel uses the fixed character device at <code>/dev/console</code>. The console channel is not synonymous with <code>stdout</code> (or file descriptor 1). <code>stdout</code> is the current output from a task when, say, <code>printf()</code> if used. Initially, <code>stdout</code> does, indeed, use the <code>/dev/console</code> device. However, <code>stdout</code> may subsequently be redirected to some other device or file. This is always the case, for example, when a transient device is used for a console -- such as a USB console or a Telnet console. The SYSLOG channel is not redirected as <code>stdout</code> is; the SYSLOG channel will stayed fixed (unless it is explicitly changed via <code>syslog_channel_register()</code>).</p><p>References: <code>drivers/syslog/syslog_consolechannel.c</code> and <code>drivers/syslog/syslog_device.c</code></p><h3 id="syslog-character-device" tabindex="-1">SYSLOG Character Device <a class="header-anchor" href="#syslog-character-device" aria-label="Permalink to &quot;SYSLOG Character Device&quot;">​</a></h3><p>The system console device, <code>/dev/console</code>, is a character driver with some special properties. However, any character driver may be used as the SYSLOG output channel. For example, suppose you have a serial console on <code>/dev/ttyS0</code> and you want SYSLOG output on <code>/dev/ttyS1</code>. Or suppose you support only a Telnet console but want to capture debug output <code>/dev/ttyS0</code>.</p><p>This SYSLOG device channel is selected with <code>CONFIG_SYSLOG_CHAR</code> and has no other dependencies. Differences from the SYSLOG console channel include:</p><blockquote><ul><li><code>CONFIG_SYSLOG_DEVPATH</code>. This configuration option string must be set provide the full path to the character device to be used.</li><li>The forced SYSLOG output always goes to the bit-bucket. This means that interrupt level SYSLOG output will be lost unless the interrupt buffer is enabled to support serialization.</li></ul></blockquote><p>References: <code>drivers/syslog/syslog_devchannel.c</code> and <code>drivers/syslog/syslog_device.c</code></p><h3 id="syslog-file-device" tabindex="-1">SYSLOG File Device <a class="header-anchor" href="#syslog-file-device" aria-label="Permalink to &quot;SYSLOG File Device&quot;">​</a></h3><p>Files can also be used as the sink for SYSLOG output. There is, however, a very fundamental difference in using a file as opposed the system console, a RAM buffer, or character device: You must first mount the file system that supports the SYSLOG file. That difference means that the file SYSLOG channel cannot be supported during the boot-up phase but can be instantiated later when board level logic configures the application environment, including mounting of the file systems.</p><p>The interface <code>syslog_file_channel()</code> is used to configure the SYSLOG file channel:</p><h3 id="syslog-ramlog-device" tabindex="-1">SYSLOG RAMLOG Device <a class="header-anchor" href="#syslog-ramlog-device" aria-label="Permalink to &quot;SYSLOG RAMLOG Device&quot;">​</a></h3><p>The RAMLOG is a standalone feature that can be used to buffer any character data in memory. There are, however, special configurations that can be used to configure the RAMLOG as a SYSLOG channel. The RAMLOG functionality is described in a more general way in the following paragraphs.</p><h2 id="ram-logging-device" tabindex="-1">RAM Logging Device <a class="header-anchor" href="#ram-logging-device" aria-label="Permalink to &quot;RAM Logging Device&quot;">​</a></h2><p>The RAM logging driver is a driver that was intended to support debugging output (SYSLOG) when the normal serial output is not available. For example, if you are using a Telnet or USB serial console, the debug output will get lost -- or worse. For example, what if you want to debug the network over Telnet? The RAM logging driver can also accept debug output data from interrupt handler with no special serialization buffering. As an added benefit, the RAM logging driver is much less invasive. Since no actual I/O is performed with the debug output is generated, the RAM logger tends to be much faster and will interfere much less when used with time critical drivers.</p><p>The RAM logging driver is similar to a pipe in that it saves the debugging output in a circular buffer in RAM. It differs from a pipe in numerous details as needed to support logging.</p><p>This driver is built when <code>CONFIG_RAMLOG</code> is defined in the NuttX configuration.</p><h3 id="dmesg-command" tabindex="-1"><code>dmesg</code> command <a class="header-anchor" href="#dmesg-command" aria-label="Permalink to &quot;`dmesg` command&quot;">​</a></h3><p>When the RAMLOG (with SYSLOG) is enabled, a new NuttShell (NSH) command will appear: <code>dmesg</code>. The <code>dmesg</code> command will dump the contents of the circular buffer to the console (and also clear the circular buffer).</p><h3 id="ramlog-configuration-options" tabindex="-1">RAMLOG Configuration options <a class="header-anchor" href="#ramlog-configuration-options" aria-label="Permalink to &quot;RAMLOG Configuration options&quot;">​</a></h3><ul><li><code>CONFIG_RAMLOG</code>: Enables the RAM logging feature</li><li><code>CONFIG_RAMLOG_SYSLOG</code>: Use the RAM logging device for the SYSLOG interface. If this feature is enabled, then all debug output will be re-directed to the circular buffer in RAM. This RAM log can be viewed from NSH using the <code>dmesg</code> command. NOTE: Unlike the limited, generic character driver SYSLOG device, the RAMLOG <em>can</em> be used to capture debug output from interrupt level handlers.</li><li><code>CONFIG_RAMLOG_NPOLLWAITERS</code>: The number of threads than can be waiting for this driver on <code>poll()</code>. Default: 4</li><li><code>CONFIG_RAMLOG_BUFSIZE</code>: The size of the circular buffer to use. Default: 1024 bytes.</li></ul><p>Other miscellaneous settings</p><ul><li><code>CONFIG_RAMLOG_CRLF</code>: Prepend a carriage return before every linefeed that goes into the RAM log.</li><li><code>CONFIG_RAMLOG_NONBLOCKING</code>: Reading from the RAMLOG will never block if the RAMLOG is empty. If the RAMLOG is empty, then zero is returned (usually interpreted as end-of-file). If you do not define this, the NSH <code>dmesg</code> command will lock up when called! So you probably do want this!</li><li><code>CONFIG_RAMLOG_NPOLLWAITERS</code>: The maximum number of threads that may be waiting on the poll method.</li></ul>',42)]))}const g=i(l,[["render",r]]);export{m as __pageData,g as default};
