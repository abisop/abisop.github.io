import{_ as t,c as a,al as o,o as n}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Delayed ACK and TCP Performance","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/net/delay_act_and_tcp_perf.md","filePath":"en/components/net/delay_act_and_tcp_perf.md"}'),i={name:"en/components/net/delay_act_and_tcp_perf.md"};function r(s,e,c,l,d,h){return n(),a("div",null,e[0]||(e[0]=[o('<h1 id="delayed-ack-and-tcp-performance" tabindex="-1">Delayed ACK and TCP Performance <a class="header-anchor" href="#delayed-ack-and-tcp-performance" aria-label="Permalink to &quot;Delayed ACK and TCP Performance&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Delayed+ACK+and+TCP+Performance" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Delayed+ACK+and+TCP+Performance</a></p><h2 id="uip-and-nuttx" tabindex="-1">uIP and NuttX <a class="header-anchor" href="#uip-and-nuttx" aria-label="Permalink to &quot;uIP and NuttX&quot;">​</a></h2><p>The heart of the NuttX IP stack derived from Adam Dunkel&#39;s tiny <a href="http://sourceforge.net/projects/uip-stack/" target="_blank" rel="noreferrer">uIP stack</a> back at version 1.0. The NuttX TCP/IP stack contains the uIP TCP state machine and some uIP &quot;ways of doing things,&quot; but otherwise, there is now little in common between these two designs.</p><p><strong>NOTE</strong>: uIP is also built into Adam Dunkel&#39;s <a href="http://contiki.sourceforge.net/docs/2.6/a01793.html" target="_blank" rel="noreferrer">Contiki</a> operating system.</p><h2 id="uip-delayed-acks-and-split-packets" tabindex="-1">uIP, Delayed ACKs, and Split Packets <a class="header-anchor" href="#uip-delayed-acks-and-split-packets" aria-label="Permalink to &quot;uIP, Delayed ACKs, and Split Packets&quot;">​</a></h2><p>In uIP, TCP packets are sent and ACK&#39;ed one at a time. That is, after one TCP packet is sent, the next packet cannot be sent until the previous packet has been ACKed by the receiving side. The TCP protocol, of course, supports sending multiple packets which can be ACKed be the receiving time asynchronously. This one-packet-at-a-time logic is a simplification in the uIP design; because of this, uIP needs only a single packet buffer any you can use uIP in even the tiniest environments. This is a good thing for the objectives of uIP.</p><p>Improvements in packet buffering is the essential improvement that you get if upgrade from Adam Dunkel&#39;s uIP to his <a href="http://savannah.nongnu.org/projects/lwip/" target="_blank" rel="noreferrer">lwIP</a> stack. The price that you pay is in memory usage.</p><p>This one-at-a-time packet transfer does create a performance problem for uIP: RFC 1122 states that a host may delay ACKing a packet for up to 500ms but must respond with an ACK to every second segment. In the baseline uIP, the effectively adds a one half second delay between the transfer of every packet to a recipient that employs this delayed ACK policy!</p><p>uIP has an option to work around this: It has logic that can be enable to split each packet into half, sending half as much data in each packet. Sending more, smaller packets does not sound like a performance improvement. This tricks the recipient that follows RFC 1122 into receiving the two, smaller back-to-back packets and ACKing the second immediately. References: <a href="http://contiki.sourceforge.net/docs/2.6/a00427_source.html" target="_blank" rel="noreferrer">uip-split.c</a> and <a href="http://contiki.sourceforge.net/docs/2.6/a00428.html" target="_blank" rel="noreferrer">uip-split.h</a>.</p><h2 id="the-nuttx-tcp-ip-stack-and-delay-acks" tabindex="-1">The NuttX TCP/IP Stack and Delay ACKs <a class="header-anchor" href="#the-nuttx-tcp-ip-stack-and-delay-acks" aria-label="Permalink to &quot;The NuttX TCP/IP Stack and Delay ACKs&quot;">​</a></h2><p>The NuttX, low-level TCP/IP stack does not have the limitations of the uIP TCP/IP stack. It can send numerous TCP/IP packets regardless of whether they have been ACKed or not. That is because in NuttX, the accounting for which packets have been ACKed and which have not has been moved to a higher level in the architecture.</p><p>NuttX includes a standard, BSD socket interface on top of the low-level TCP/IP stack. It is in this higer-level, socket layer where the ACK accounting is done, specifically in the function <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/send.html" target="_blank" rel="noreferrer">send()</a>. If you send a large, multi-packet buffer via <code>send()</code>, it will be broken up into individual packets and each packet will be sent as quickly as possible, with no concern for whether the previous packet has been ACKed or not.</p><p>However, the NuttX <code>send()</code> function will not return to the caller until the final packet has been ACKed. It does this to assure that the callers data was sent successfully (or not). This behavior means that if an odd number of packets were sent, there could still be a delay after the final packet before <code>send()</code> receives the ACK and returns.</p><p>So the NuttX approach is similar to the uIP way of doing things, but does add one more buffer, the user provided buffer to <code>send()</code>, that can be used to improve TCP/IP performance (of course, this user provided buffer is also required by in order to be compliant with <code>send()</code>&quot;&quot; <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/send.html" target="_blank" rel="noreferrer">specification</a>.</p><h2 id="the-nuttx-split-packet-configuration" tabindex="-1">The NuttX Split Packet Configuration <a class="header-anchor" href="#the-nuttx-split-packet-configuration" aria-label="Permalink to &quot;The NuttX Split Packet Configuration&quot;">​</a></h2><p>But what happens if all of the user buffer is smaller than the MSS of one TCP packet? Suppose the MTU is 1500 and the user I/O buffer is only 512 bytes? In this case, <code>send()</code> performance degenerates to the same behavior as uIP: An ACK is required for each packet before <code>send()</code> can return and before <code>send()</code> can be called again to send the next packet.</p><p>And the fix? A fix has recently been contributed by Yan T that works in a similar way to uIP split packet logic: In <code>send()</code>, the logic normally tries to send a full packet of data each time it has the opportunity to do so. However, if the configuration option <code>CONFIG_NET_TCP_SPLIT=y</code> is defined, the behavior of <code>send()</code> will change in the following way:</p><ul><li><code>send()</code> will keep track of [even]{.title-ref} and [odd]{.title-ref} packets; [even]{.title-ref} packets being those that we do not expect to be ACKed and [odd]{.title-ref} packets being the those that we do expect to be ACKed.</li><li><code>send()</code> will then reduce the size of even packets as necessary to assure that an even number of packets is always sent. Every call to send will result in an even number of packets being sent.</li></ul><p>This clever solution tricks the RFC 1122 recipient in the same way that uIP split logic does. So if you are working with hosts the following the RFC 1122 ACKing behavior and you have MSS sizes that are larger that the average size of the user buffers, then your throughput can probably be greatly improved by enabling <code>CONFIG_NET_TCP_SPLIT=y</code></p><p>NOTE: NuttX is [not]{.title-ref} an RFC 1122 recipient; NuttX will ACK every TCP/IP packet that it receives.</p><h2 id="write-buffering" tabindex="-1">Write Buffering <a class="header-anchor" href="#write-buffering" aria-label="Permalink to &quot;Write Buffering&quot;">​</a></h2><p>The best technical solution to the delayed ACK problem would be to support [write buffering]{.title-ref}. Write buffering is enabled with <code>CONFIG_NET_TCP_WRITE_BUFFERS</code>. If this option is selected, the NuttX networking layer will pre-allocate several write buffers at system initialization time. The sending a buffer of data then works like this:</p><ul><li><code>send()</code> (1) obtains a pre-allocated write buffer from a free list, and then (2) simply copies the buffer of data that the user wishes to send into the allocated write buffer. If no write buffer is available, <code>send()</code> would have to block waiting for free write buffer space.</li><li><code>send()</code> then (3) adds the write buffer to a queue of outgoing data for a TCP socket. Each open TCP socket has to support such a queue. <code>send()</code> could then (4) return success to the caller (even thought the transfer could still fail later).</li><li>Logic outside of the <code>send()</code> implementation manages the actual transfer of data from the write buffer. When the Ethernet driver is able to send a packet on the TCP connection, this external logic (5) copies a packet of data from the write buffer so that the Ethernet driver can perform the transmission (a [zero-copy]{.title-ref} implementation would be preferable). Note that the data has to remain in the write buffer for now; it may need to be re-transmitted.</li><li>This external logic would also manage the receipt TCP ACKs. When TCP peer acknowledges the receipt of data, the acknowledged portion of the data can the (6) finally be deleted from the write buffer.</li></ul><p>The following options configure TCP write buffering:</p><ul><li><code>CONFIG_NET_TCP_WRITE_BUFSIZE</code>: The size of one TCP write buffer.</li><li><code>CONFIG_NET_NTCP_WRITE_BUFFERS</code>: The number of TCP write buffers (may be zero to disable TCP/IP write buffering)</li></ul><p>NuttX also supports TCP read-ahead buffering. This option is enabled with <code>CONFIG_NET_TCP_READAHEAD</code>. TCP read-ahead buffer is necessary on TCP connections; otherwise data received while there is no <code>recv()</code> in place would be lost. For consistency, it would be best if such a TCP write buffer implementation worked in a manner similar to the existing TCP read-ahead buffering.</p><p>The following lists the NuttX configuration options available to configure the TCP read-ahead buffering feature:</p><ul><li><code>CONFIG_NET_TCP_READAHEAD_BUFSIZE</code>: The size of one TCP read-ahead buffer.</li><li><code>CONFIG_NET_NTCP_READAHEAD_BUFFERS</code>: The number of TCP read-ahead buffers (may be zero to disable TCP/IP read-ahead buffering)</li></ul><p>A future enhancement is to combine the TCP write buffer management logic and the TCP read-ahead buffer management so that one common pool of buffers can be used for both functions (this would probably also require additional logic to [throttle]{.title-ref} read-buffering so that received messages do not consume all of the buffers).</p>',31)]))}const p=t(i,[["render",r]]);export{u as __pageData,p as default};
