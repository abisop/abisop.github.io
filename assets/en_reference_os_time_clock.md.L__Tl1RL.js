import{_ as a,c as s,al as o,j as e,a as t,o as n}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"System Time and Clock","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/os/time_clock.md","filePath":"en/reference/os/time_clock.md"}'),r={name:"en/reference/os/time_clock.md"};function l(c,i,d,h,p,m){return n(),s("div",null,i[0]||(i[0]=[o(`<h1 id="system-time-and-clock" tabindex="-1">System Time and Clock <a class="header-anchor" href="#system-time-and-clock" aria-label="Permalink to &quot;System Time and Clock&quot;">​</a></h1><h2 id="basic-system-timer" tabindex="-1">Basic System Timer <a class="header-anchor" href="#basic-system-timer" aria-label="Permalink to &quot;Basic System Timer&quot;">​</a></h2><p><strong>System Timer</strong> In most implementations, system time is provided by a timer interrupt. That timer interrupt runs at rate determined by <code>CONFIG_USEC_PER_TICK</code> (default 10000 microseconds or 100Hz. If <code>CONFIG_SCHED_TICKLESS</code> is selected, the default is 100 microseconds). The timer generates an interrupt each <code>CONFIG_USEC_PER_TICK</code> microseconds and increments a counter called <code>g_system_ticks</code>. <code>g_system_ticks</code> then provides a time-base for calculating <em>up-time</em> and elapsed time intervals in units of <code>CONFIG_USEC_PER_TICK</code>. The range of <code>g_system_ticks</code> is, by default, 32-bits. However, if the MCU supports type <code>long long</code> and <code>CONFIG_SYSTEM_TIME16</code> is selected, a 64-bit system timer will be supported instead.</p><p><strong>System Timer Accuracy</strong> On many system, the exact timer interval specified by <code>CONFIG_USEC_PER_TICK</code> cannot be achieved due to limitations in frequencies or in dividers. As a result, the time interval specified by <code>CONFIG_USEC_PER_TICK</code> may only be approximate and there may be small errors in the apparent <em>up-time</em> time. These small errors, however, will accumulate over time and after a long period of time may have an unacceptably large error in the apparent <em>up-time</em> of the MCU.</p><p>If the timer tick period generated by the hardware is not exactly <code>CONFIG_USEC_PER_TICK</code> <em>and</em> if there you require accurate up-time for the MCU, then there are measures that you can take:</p><ul><li>Perhaps you can adjust <code>CONFIG_USEC_PER_TICK</code> to a different value so that an exactly <code>CONFIG_USEC_PER_TICK</code> can be realized.</li><li>Or you can use a technique known as <em>Delta-Sigma Modulation</em>. (Suggested by Uros Platise). Consider the example below.</li></ul><p><strong>Delta-Sigma Modulation Example</strong>. Consider this case: The system timer is a count-up timer driven at 32.768KHz. There are dividers that can be used, but a divider of one yields the highest accuracy. This counter counts up until the count equals a match value, then a timer interrupt is generated. The desire frequency is 100Hz (<code>CONFIG_USEC_PER_TICK</code> is 10000).</p><p>This exact frequency of 100Hz cannot be obtained in this case. In order to obtain that exact frequency a match value of 327.68 would have to be provided. The closest integer value is 328 but the ideal match value is between 327 and 328. The closest value, 328, would yield an actual timer frequency of 99.9Hz! That will may cause significant timing errors in certain usages.</p><p>Use of Delta-Sigma Modulation can eliminate this error in the long run. Consider this example implementation:</p><blockquote><ol><li><p>Initially an accumulator is zero an the match value is programmed to 328:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>accumulator = 0;</span></span>
<span class="line"><span>match = 328;</span></span></code></pre></div></li><li><p>On each timer interrupt, accumulator is updated with difference that, in this reflects, 100* the error in interval that just passed. So on the first timer interrupt, the accumulator would be updated like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if (match == 328)</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    accumulator += 32; // 100*(328 - 327.68)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    accumulator -= 68; // (100*(327 - 327.68)</span></span>
<span class="line"><span>  }</span></span></code></pre></div></li><li><p>And on that same timer interrupt a new match value would be programmed:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if (accumulator &lt; 0)</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    match = 328;</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    match = 327;</span></span>
<span class="line"><span>  }</span></span></code></pre></div></li></ol></blockquote><p>In this way, the timer interval is controlled from interrupt-to-interrupt to produce an average frequency of exactly 100Hz.</p><h2 id="hardware" tabindex="-1">Hardware <a class="header-anchor" href="#hardware" aria-label="Permalink to &quot;Hardware&quot;">​</a></h2><p>To enable hardware module use the following configuration options:</p><p><code>CONFIG_RTC</code></p><p>: Enables general support for a hardware RTC. Specific architectures may require other specific settings.</p><p><code>CONFIG_RTC_EXTERNAL</code></p><p>: Most MCUs include RTC hardware built into the chip. Other RTCs, <em>external</em> MCUs, may be provided as separate chips typically interfacing with the MCU via a serial interface such as SPI or I2C. These external RTCs differ from the built-in RTCs in that they cannot be initialized until the operating system is fully booted and can support the required serial communications. <code>CONFIG_RTC_EXTERNAL</code> will configure the operating system so that it defers initialization of its time facilities.</p><p><code>CONFIG_RTC_DATETIME</code></p><p>: There are two general types of RTC: (1) A simple battery backed counter that keeps the time when power is down, and (2) A full date / time RTC the provides the date and time information, often in BCD format. If <code>CONFIG_RTC_DATETIME</code> is selected, it specifies this second kind of RTC. In this case, the RTC is used to &quot;seed&quot;&quot; the normal NuttX timer and the NuttX system timer provides for higher resolution time.</p><p><code>CONFIG_RTC_HIRES</code></p><p>: If <code>CONFIG_RTC_DATETIME</code> not selected, then the simple, battery backed counter is used. There are two different implementations of such simple counters based on the time resolution of the counter: The typical RTC keeps time to resolution of 1 second, usually supporting a 32-bit <code>time_t</code> value. In this case, the RTC is used to &quot;seed&quot; the normal NuttX timer and the NuttX timer provides for higher resolution time. If <code>CONFIG_RTC_HIRES</code> is enabled in the NuttX configuration, then the RTC provides higher resolution time and completely replaces the system timer for purpose of date and time.</p><p><code>CONFIG_RTC_FREQUENCY</code></p><p>: If <code>CONFIG_RTC_HIRES</code> is defined, then the frequency of the high resolution RTC must be provided. If <code>CONFIG_RTC_HIRES</code> is not defined, <code>CONFIG_RTC_FREQUENCY</code> is assumed to be one.</p><p><code>CONFIG_RTC_ALARM</code></p><p>: Enable if the RTC hardware supports setting of an alarm. A callback function will be executed when the alarm goes off</p><p>which requires the following base functions to read and set time:</p><ul><li><code>up_rtc_initialize()</code>. Initialize the built-in, MCU hardware RTC per the selected configuration. This function is called once very early in the OS initialization sequence. NOTE that initialization of external RTC hardware that depends on the availability of OS resources (such as SPI or I2C) must be deferred until the system has fully booted. Other, RTC-specific initialization functions are used in that case.</li><li><code>up_rtc_time()</code>. Get the current time in seconds. This is similar to the standard <code>time()</code> function. This interface is only required if the low-resolution RTC/counter hardware implementation selected. It is only used by the RTOS during initialization to set up the system time when <code>CONFIG_RTC</code> is set but neither <code>CONFIG_RTC_HIRES</code> nor <code>CONFIG_RTC_DATETIME</code> are set.</li><li><code>up_rtc_gettime()</code>. Get the current time from the high resolution RTC clock/counter. This interface is only supported by the high-resolution RTC/counter hardware implementation. It is used to replace the system timer (<code>g_system_ticks</code>).</li><li><code>up_rtc_settime()</code>. Set the RTC to the provided time. All RTC implementations must be able to set their time based on a standard timespec.</li></ul><h2 id="system-tick-and-time" tabindex="-1">System Tick and Time <a class="header-anchor" href="#system-tick-and-time" aria-label="Permalink to &quot;System Tick and Time&quot;">​</a></h2><p>The system tick is represented by <code>g_system_ticks</code>.</p><p>Running at rate of system base timer, used for time-slicing, and so forth.</p><p>If hardware RTC is present (<code>CONFIG_RTC</code>) and and high-resolution timing is enabled (<code>CONFIG_RTC_HIRES</code>), then after successful initialization variables are overridden by calls to <code>up_rtc_gettime()</code> which is running continuously even in power-down modes.</p><p>In the case of <code>CONFIG_RTC_HIRES</code> is set the <code>g_system_ticks</code> keeps counting at rate of a system timer, which however, is disabled in power-down mode. By comparing this time and RTC (actual time) one may determine the actual system active time. To retrieve that variable use:</p><h2 id="tickless-os" tabindex="-1">Tickless OS <a class="header-anchor" href="#tickless-os" aria-label="Permalink to &quot;Tickless OS&quot;">​</a></h2><p><strong>Default System Timer</strong>. By default, a NuttX configuration uses a periodic timer interrupt that drives all system timing. The timer is provided by architecture-specific code that calls into NuttX at a rate controlled by <code>CONFIG_USEC_PER_TICK</code>. The default value of <code>CONFIG_USEC_PER_TICK</code> is 10000 microseconds which corresponds to a timer interrupt rate of 100 Hz.</p><p>On each timer interrupt, NuttX does these things:</p><ul><li>Increments a counter. This counter is the system time and has a resolution of <code>CONFIG_USEC_PER_TICK</code> microseconds.</li><li>Checks if it is time to perform time-slice operations on tasks that have select round-robin scheduling.</li><li>Checks for expiration of timed events.</li></ul><p>What is wrong with this default system timer? Nothing really. It is reliable and uses only a small fraction of the CPU band width. But we can do better. Some limitations of default system timer are, in increasing order of importance:</p><ul><li><strong>Overhead</strong>: Although the CPU usage of the system timer interrupt at 100Hz is really very low, it is still mostly wasted processing time. On most timer interrupts, there is really nothing that needs to be done other than incrementing the counter.</li><li><strong>Resolution</strong>: Resolution of all system timing is also determined by <code>CONFIG_USEC_PER_TICK</code>. So nothing can be timed with resolution finer than 10 milliseconds by default. To increase this resolution, <code>CONFIG_USEC_PER_TICK</code> can be reduced. However, then the system timer interrupts use more of the CPU bandwidth processing useless interrupts.</li><li><strong>Power Usage</strong>: But the biggest issue is power usage. When the system is IDLE, it enters a light, low-power mode (for ARMs, this mode is entered with the <code>wfi</code> or <code>wfe</code> instructions for example). But each interrupt awakens the system from this low power mode. Therefore, higher rates of interrupts cause greater power consumption.</li></ul><p><strong>Tickless OS</strong>. The so-called <em>Tickless OS</em> provides one solution to this issue. The basic concept here is that the periodic, timer interrupt is eliminated and replaced with a one-shot, interval timer. It becomes event driven instead of polled: The default system timer is a polled design. On each interrupt, the NuttX logic checks if it needs to do anything and, if so, it does it.</p><p>Using an interval timer, one can anticipate when the next interesting OS event will occur, program the interval time and wait for it to fire. When the interval time fires, then the scheduled activity is performed.</p><h3 id="tickless-platform-support" tabindex="-1">Tickless Platform Support <a class="header-anchor" href="#tickless-platform-support" aria-label="Permalink to &quot;Tickless Platform Support&quot;">​</a></h3><p>In order to use the Tickless OS, one must provide special support from the platform-specific code. Just as with the default system timer, the platform-specific code must provide the timer resources to support the OS behavior. Currently these timer resources are only provided on a few platforms. An example implementation is for the simulation is at <code>nuttx/arch/sim/src/up_tickless.c</code>. There is another example for the Atmel SAMA5 at <code>nuttx/arch/arm/src/sama5/sam_tickless.c</code>. These paragraphs will explain how to provide the Tickless OS support to any platform.</p><h3 id="tickless-configuration-options" tabindex="-1">Tickless Configuration Options <a class="header-anchor" href="#tickless-configuration-options" aria-label="Permalink to &quot;Tickless Configuration Options&quot;">​</a></h3><ul><li><p><code>CONFIG_ARCH_HAVE_TICKLESS</code>: If the platform provides support for the <em>Tickless OS</em>, then this setting should be selected in the <code>Kconfig</code> file for the architecture. Here is what the selection looks in the <code>arch/Kconfig</code> file for the simulated platform:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>config ARCH_SIM</span></span>
<span class="line"><span>   bool &quot;Simulation&quot;</span></span>
<span class="line"><span>   select ARCH_HAVE_TICKLESS</span></span>
<span class="line"><span>   ---help---</span></span>
<span class="line"><span>           Linux/Cygwin user-mode simulation.</span></span></code></pre></div><p>When the simulation platform is selected, <code>ARCH_HAVE_TICKLESS</code> is automatically selected, informing the configuration system that <em>Tickless OS</em> options can be selected.</p></li><li><p><code>CONFIG_SCHED_TICKLESS</code>: If <code>CONFIG_ARCH_HAVE_TICKLESS</code> is selected, then you will be able to use this option to enable the <em>Tickless OS</em> features in NuttX.</p></li><li><p><code>CONFIG_SCHED_TICKLESS_ALARM</code>: The tickless option can be supported either via a simple interval timer (plus elapsed time) or via an alarm. The interval timer allows programming events to occur after an interval. With the alarm, you can set a time in the future and get an event when that alarm goes off. This option selects the use of an alarm.</p><p>The advantage of an alarm is that it avoids some small timing errors; the advantage of the use of the interval timer is that the hardware requirement may be simpler.</p></li><li><p><code>CONFIG_USEC_PER_TICK</code>: This option is not unique to <em>Tickless OS</em> operation, but changes its relevance when the <em>Tickless OS</em> is selected. In the default configuration, where system time is provided by a periodic timer interrupt, the default system timer is configured for 100Hz, that is, <code>CONFIG_USEC_PER_TICK=10000</code>. If <code>CONFIG_SCHED_TICKLESS</code> is selected, then there are no system timer interrupts. In this case, <code>CONFIG_USEC_PER_TICK</code> does not control any timer rates. Rather, it only determines the resolution of time reported by <code>clock_systime_ticks()</code> and the resolution of times that can be set for certain delays including watchdog timers and delayed work.</p><p>In this case there is still a trade-off: It is better to have the <code>CONFIG_USEC_PER_TICK</code> as low as possible for higher timing resolution. However, the time is currently held in <code>unsigned int</code>. On some systems, this may be 16-bits in width but on most contemporary systems it will be 32-bits. In either case, smaller values of <code>CONFIG_USEC_PER_TICK</code> will reduce the range of values that delays that can be represented. So the trade-off is between range and resolution (you could also modify the code to use a 64-bit value if you really want both).</p><p>The default, 100 microseconds, will provide for a range of delays up to 120 hours.</p><p>This value should never be less than the underlying resolution of the timer. Errors may ensue.</p></li></ul><h3 id="tickless-imported-interfaces" tabindex="-1">Tickless Imported Interfaces <a class="header-anchor" href="#tickless-imported-interfaces" aria-label="Permalink to &quot;Tickless Imported Interfaces&quot;">​</a></h3><p>The interfaces that must be provided by the platform specified code are defined in <code>include/nuttx/arch.h</code>, listed below, and summarized in the following paragraphs:</p><blockquote><ul><li><code>&lt;arch&gt;_timer_initialize()</code> Initializes the timer facilities. Called early in the initialization sequence (by <code>up_initialize()</code>).</li><li><code>up_timer_gettime()</code>: Returns the current time from the platform specific time source.</li></ul></blockquote><p>The tickless option can be supported either via a simple interval timer (plus elapsed time) or via an alarm. The interval timer allows programming events to occur after an interval. With the alarm, you can set a time in* the future and get an event when that alarm goes off.</p><p>If <code>CONFIG_SCHED_TICKLESS_ALARM</code> is defined, then the platform code must provide the following:</p><ul><li><code>up_alarm_cancel()</code>: Cancels the alarm.</li><li><code>up_alarm_start()</code>: Enables (or re-enables) the alarm.</li></ul><p>If <code>CONFIG_SCHED_TICKLESS_ALARM</code> is <em>not</em>defined, then the platform code must provide the following verify similar functions:</p><ul><li><code>up_timer_cancel()</code>: Cancels the interval timer.</li><li><code>up_timer_start()</code>: Starts (or re-starts) the interval timer.</li></ul><p>Note that a platform-specific implementation would probably require two hardware timers: (1) A interval timer to satisfy the requirements of <code>up_timer_start()</code> and <code>up_timer_cancel()</code>, and (2) a counter to handle the requirement of <code>up_timer_gettime()</code>. Ideally, both timers would run at the rate determined by <code>CONFIG_USEC_PER_TICK</code> (and certainly never slower than that rate).</p><p>Since timers are a limited resource, the use of two timers could be an issue on some systems. The job could be done with a single timer if, for example, the single timer were kept in a free-running mode at all times. Some timer/counters have the capability to generate a compare interrupt when the timer matches a comparison value but also to continue counting without stopping. If your hardware supports such counters, one might use the <code>CONFIG_SCHED_TICKLESS_ALARM</code> option and be able to simply set the comparison count at the value of the free running timer <em>PLUS</em> the desired delay. Then you could have both with a single timer: An alarm and a free-running counter with the same timer!</p><p>In addition to these imported interfaces, the RTOS will export the following interfaces for use by the platform-specific interval timer implementation:</p><ul><li><code>nxsched_alarm_expiration()</code>: called by the platform-specific logic when the alarm expires.</li><li><code>nxsched_timer_expiration()</code>: called by the platform-specific logic when the interval time expires.</li></ul><p>Cancel the interval timer and return the time remaining on the timer. These two steps need to be as nearly atomic as possible. <code>nxsched_timer_expiration()</code> will not be called unless the timer is restarted with <code>up_timer_start()</code>. If, as a race condition, the timer has already expired when this function is called, then that pending interrupt must be cleared so that <code>nxsched_timer_expiration()</code> is not called spuriously and the remaining time of zero should be returned.</p><p>param ts</p><p>: Location to return the remaining time. Zero should be returned if the timer is not active.</p><p>return</p><p>: Zero (OK) on success; a negated errno value on failure.</p><p><strong>Assumptions</strong>: May be called from interrupt level handling or from the normal tasking level. interrupts may need to be disabled internally to assure non-reentrancy.</p><p>Start the interval timer. <code>nxsched_timer_expiration()</code> will be called at the completion of the timeout (unless <code>up_timer_cancel()</code> is called to stop the timing).</p><p>param ts</p><p>: Provides the time interval until <code>nxsched_timer_expiration()</code> is called.</p><p>return</p><p>: Zero (OK) on success; a negated errno value on failure.</p><p><strong>Assumptions</strong>: May be called from interrupt level handling or from the normal tasking level. Interrupts may need to be disabled internally to assure non-reentrancy.</p><h2 id="watchdog-timer-interfaces" tabindex="-1">Watchdog Timer Interfaces <a class="header-anchor" href="#watchdog-timer-interfaces" aria-label="Permalink to &quot;Watchdog Timer Interfaces&quot;">​</a></h2><p>NuttX provides a general watchdog timer facility. This facility allows the NuttX user to specify a watchdog timer function that will run after a specified delay. The watchdog timer function will run in the context of the timer interrupt handler. Because of this, a limited number of NuttX interfaces are available to he watchdog timer function. However, the watchdog timer function may use <code>mq_send()</code>, <code>sigqueue()</code>, or <code>kill()</code> to communicate with NuttX tasks.</p>`,70),e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"wd_start")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"wd_cancel")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"wd_gettime")]),e("li",null,"Watchdog Timer Callback")],-1)]))}const _=a(r,[["render",l]]);export{f as __pageData,_ as default};
