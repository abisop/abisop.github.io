import{_ as t,c as o,al as r,o as a}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"Keyboard/Keypad Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/character/input/keypad.md","filePath":"en/components/drivers/character/input/keypad.md"}'),n={name:"en/components/drivers/character/input/keypad.md"};function s(d,e,c,i,l,p){return a(),o("div",null,e[0]||(e[0]=[r('<h1 id="keyboard-keypad-drivers" tabindex="-1">Keyboard/Keypad Drivers <a class="header-anchor" href="#keyboard-keypad-drivers" aria-label="Permalink to &quot;Keyboard/Keypad Drivers&quot;">â€‹</a></h1><p><strong>Keypads vs. Keyboards</strong> Keyboards and keypads are really the same devices for NuttX. A keypad is thought of as simply a keyboard with fewer keys.</p><p><strong>Special Commands</strong>. In NuttX, a keyboard/keypad driver is simply a character driver that may have an (optional) encoding/decoding layer on the data returned by the character driver. A keyboard may return simple text data (alphabetic, numeric, and punctuation) or control characters (enter, control-C, etc.) when a key is pressed. We can think about this the &quot;normal&quot; keyboard data stream. However, in addition, most keyboards support actions that cannot be represented as text or control data. Such actions include things like cursor controls (home, up arrow, page down, etc.), editing functions (insert, delete, etc.), volume controls, (mute, volume up, etc.) and other special functions. In this case, some special encoding may be required to multiplex the normal text data and special command key press data streams.</p><p><strong>Key Press and Release Events</strong> Sometimes the time that a key is released is needed by applications as well. Thus, in addition to normal and special key press events, it may also be necessary to encode normal and special key release events.</p><p><strong>Encoding/Decoding</strong> Layer. An optional encoding/decoding layer can be used with the basic character driver to encode the keyboard events into the text data stream. The function interfaces that comprise that encoding/decoding layer are defined in the header file <code>include/nuttx/input/kbd_code.h</code>. These functions provide an matched set of (a) driver encoding interfaces, and (b) application decoding interfaces.</p><ol><li><strong>Driver Encoding Interfaces</strong>. These are interfaces used by the keyboard/keypad driver to encode keyboard events and data. <ul><li><p><code>kbd_press()</code></p><p><strong>Function Prototype:</strong></p><p><strong>Description:</strong></p><p><strong>Input Parameters:</strong></p><ul><li><code>ch</code>: The character to be added to the output stream.</li><li><code>stream</code>: An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.</li></ul><p><strong>Returned Value:</strong></p></li><li><p><code>kbd_release()</code></p><p><strong>Function Prototype:</strong></p><p><strong>Description:</strong></p><p><strong>Input Parameters:</strong></p><ul><li><code>ch</code>: The character associated with the key that was released.</li><li><code>stream</code>: An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.</li></ul><p><strong>Returned Value:</strong></p></li><li><p><code>kbd_specpress()</code></p><p><strong>Function Prototype:</strong></p><p><strong>Description:</strong></p><p><strong>Input Parameters:</strong></p><ul><li><code>keycode</code>: The command to be added to the output stream. The enumeration <code>enum kbd_keycode_e keycode</code> identifies all commands known to the system.</li><li><code>stream</code>: An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.</li></ul><p><strong>Returned Value:</strong></p></li><li><p><code>kbd_specrel()</code></p><p><strong>Function Prototype:</strong></p><p><strong>Description:</strong></p><p><strong>Input Parameters:</strong></p><ul><li><code>keycode</code>: The command to be added to the output stream. The enumeration <code>enum kbd_keycode_e keycode</code> identifies all commands known to the system.</li><li><code>stream</code>: An instance of <code>lib_outstream_s</code> to perform the actual low-level put operation.</li></ul><p><strong>Returned Value:</strong></p></li></ul></li><li><strong>Application Decoding Interfaces</strong>. These are user interfaces to decode the values returned by the keyboard/keypad driver. <ul><li><p><code>kbd_decode()</code></p><p><strong>Function Prototype:</strong></p><p><strong>Description:</strong></p><p><strong>Input Parameters:</strong></p><ul><li><code>stream</code>: An instance of <code>lib_instream_s</code> to perform the actual low-level get operation.</li><li><code>pch</code>: The location to save the returned value. This may be either a normal, character code or a special command (i.e., a value from <code>enum kbd_getstate_s</code>.</li><li><code>state</code>: A user provided buffer to support parsing. This structure should be cleared the first time that <code>kbd_decode()</code> is called.</li></ul><p><strong>Returned Value:</strong></p><ul><li><code>KBD_PRESS</code> (0)**: Indicates the successful receipt of normal, keyboard data. This corresponds to a keypress event. The returned value in <code>pch</code> is a simple byte of text or control data.</li><li><code>KBD_RELEASE</code> (1)**: Indicates a key release event. The returned value in <code>pch</code> is the byte of text or control data corresponding to the released key.</li><li><code>KBD_SPECPRESS</code> (2)**: Indicates the successful receipt of a special keyboard command. The returned value in <code>pch</code> is a value from <code>enum kbd_getstate_s</code>.</li><li><code>KBD_SPECREL</code> (3)**: Indicates a special command key release event. The returned value in <code>pch</code> is a value from <code>enum kbd_getstate_s</code>.</li><li><code>KBD_ERROR</code> (<code>EOF</code>)**: An error has getting the next character (reported by the <code>stream</code>). Normally indicates the end of file.</li></ul></li></ul></li></ol><p><strong>I/O Streams</strong>. Notice the use of the abstract I/O streams in these interfaces. These stream interfaces are defined in <code>include/nuttx/streams.h</code>.</p>',7)]))}const m=t(n,[["render",s]]);export{h as __pageData,m as default};
