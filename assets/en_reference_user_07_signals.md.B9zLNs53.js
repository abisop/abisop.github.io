import{_ as s,c as i,al as n,j as e,a as t,o as r}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"Signal Interfaces","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/user/07_signals.md","filePath":"en/reference/user/07_signals.md"}'),l={name:"en/reference/user/07_signals.md"};function o(c,a,d,h,p,u){return r(),i("div",null,a[0]||(a[0]=[n('<h1 id="signal-interfaces" tabindex="-1">Signal Interfaces <a class="header-anchor" href="#signal-interfaces" aria-label="Permalink to &quot;Signal Interfaces&quot;">â€‹</a></h1><p><strong>Tasks and Signals</strong>. NuttX provides signal interfaces for tasks and pthreads. Signals are used to alter the flow control of tasks by communicating asynchronous events within or between task contexts. Any task or interrupt handler can post (or send) a signal to a particular task using its task ID. The task being signaled will execute task-specified signal handler function the next time that the task has priority. The signal handler is a user-supplied function that is bound to a specific signal and performs whatever actions are necessary whenever the signal is received.</p><p>By default, here are no predefined actions for any signal. The default action for all signals (i.e., when no signal handler has been supplied by the user) is to ignore the signal. In this sense, all NuttX are <em>real time</em> signals by default. If the configuration option <code>CONFIG_SIG_DEFAULT=y</code> is included, some signals will perform their default actions dependent upon addition configuration settings as summarized in the following table:</p><p>Signal Action Additional Configuration</p><hr><p>SIGUSR1 Abnormal Termination CONFIG_SIG_SIGUSR1_ACTION SIGUSR2 Abnormal Termination CONFIG_SIG_SIGUSR2_ACTION SIGALRM Abnormal Termination CONFIG_SIG_SIGALRM_ACTION SIGPOLL Abnormal Termination CONFIG_SIG_SIGPOLL_ACTION SIGSTOP Suspend task CONFIG_SIG_SIGSTOP_ACTION SIGTSTP Suspend task CONFIG_SIG_SIGSTOP_ACTION SIGCONT Resume task CONFIG_SIG_SIGSTOP_ACTION SIGINT Abnormal Termination CONFIG_SIG_SIGKILL_ACTION SIGKILL Abnormal Termination CONFIG_SIG_SIGKILL_ACTION</p><p>Tasks may also suspend themselves and wait until a signal is received.</p><p><strong>Tasks Groups</strong>. NuttX supports both tasks and pthreads. The primary difference between tasks and pthreads is the tasks are much more independent. Tasks can create pthreads and those pthreads will share the resources of the task. The main task and its children pthreads together are referred as a <em>task group</em>. A task group is used in NuttX to emulate a POSIX <em>process</em>.</p><p>Note</p><p>Behavior of features related to task groups depend of NuttX configuration settings. See also the<a href="https://cwiki.apache.org/confluence/display/NUTTX/NuttX+Tasking" target="_blank" rel="noreferrer">NuttX Tasking</a>page and the<a href="https://cwiki.apache.org/confluence/display/NUTTX/Tasks+vs.+Threads+FAQ" target="_blank" rel="noreferrer">Tasks vs. Threads FAQ</a>for additional information on tasks and threads in NuttX.</p><p><strong>Signaling Multi-threaded Task Groups</strong>. The behavior of signals in the multi-thread task group is complex. NuttX emulates a process model with task groups and follows the POSIX rules for signaling behavior. Normally when you signal the task group you would signal using the task ID of the main task that created the group (in practice, a different task should not know the IDs of the internal threads created within the task group); that ID is remembered by the task group (even if the main task thread exits).</p><p>Here are some of the things that should happen when you signal a multi-threaded task group:</p><ul><li>If a task group receives a signal then one and only one indeterminate thread in the task group which is not blocking the signal will receive the signal.</li><li>If a task group receives a signal and more than one thread is waiting on that signal, then one and only one indeterminate thread out of that waiting group will receive the signal.</li></ul><p>You can mask out that signal using &#39;&#39;sigprocmask()&#39;&#39; (or &#39;&#39;pthread_sigmask()&#39;&#39;). That signal will then be effectively disabled and will never be received in those threads that have the signal masked. On creation of a new thread, the new thread will inherit the signal mask of the parent thread that created it. So you if block signal signals on one thread then create new threads, those signals will also be blocked in the new threads as well.</p><p>You can control which thread receives the signal by controlling the signal mask. You can, for example, create a single thread whose sole purpose it is to catch a particular signal and respond to it: Simply block the signal in the main task; then the signal will be blocked in all of the pthreads in the group too. In the one &quot;signal processing&quot; pthread, enable the blocked signal. This thread will then be only thread that will receive the signal.</p><p><strong>Signal Interfaces</strong>. The following signal handling interfaces are provided by NuttX:</p>',16),e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigemptyset")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigfillset")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigaddset")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigdelset")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigismember")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigaction")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigignore")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigset")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigprocmask")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sighold")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigrelse")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigpending")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigsuspend")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigpause")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigwaitinfo")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigtimedwait")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sigqueue")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"kill")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"pause")])],-1),n("<p>Equivalent to sigtimedwait() with a NULL timeout parameter. (see below).</p><blockquote><p>param set</p><p>: The set of pending signals to wait for.</p><p>param info</p><p>: The returned signal values</p><p>return</p><p>: Signal number that cause the wait to be terminated, otherwise -1 (<code>ERROR</code>) is returned.</p><p><strong>POSIX Compatibility:</strong> Comparable to the POSIX interface of the same name.</p></blockquote>",2)]))}const m=s(l,[["render",o]]);export{f as __pageData,m as default};
