import{_ as o,c as i,al as t,j as e,a,o as l}from"./chunks/framework.NFAqBSgQ.js";const x=JSON.parse('{"title":"NXP S32K1XX","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/s32k1xx/index.md","filePath":"en/platforms/arm/s32k1xx/index.md"}'),s={name:"en/platforms/arm/s32k1xx/index.md"};function n(d,r,p,c,h,u){return l(),i("div",null,r[0]||(r[0]=[t('<h1 id="nxp-s32k1xx" tabindex="-1">NXP S32K1XX <a class="header-anchor" href="#nxp-s32k1xx" aria-label="Permalink to &quot;NXP S32K1XX&quot;">​</a></h1><p>The <a href="https://www.nxp.com/products/processors-and-microcontrollers/s32-automotive-platform/s32k-general-purpose-mcus/s32k1-microcontrollers-for-general-purpose:S32K1" target="_blank" rel="noreferrer">S32K1XX series</a> is a family of automotive-grade general-purpose microcontrollers from NXP Semiconductors. The lower end of the family is based on an Arm Cortex-M0+ core and can run at clockspeeds up to 48 MHz. The higher end chips are based on the Arm Cortex-M4F core which runs at up to 80 or 112 MHz.</p><h2 id="supported-mcus" tabindex="-1">Supported MCUs <a class="header-anchor" href="#supported-mcus" aria-label="Permalink to &quot;Supported MCUs&quot;">​</a></h2><p>The following list includes MCUs from the S32K1XX series and indicates whether they are supported in NuttX:</p><p>+----------+---------+------------+-----------+ | MCU | Support | Core | Frequency | +==========+=========+============+===========+ | S32K116 | Yes* | Cortex-M0+ | &gt; 48 MHz | +----------+---------+------------+-----------+ | S32K118 | Yes* | Cortex-M0+ | &gt; 48 MHz | +----------+---------+------------+-----------+ | S32K142 | Yes* | Cortex-M4F | 112 MHz | +----------+---------+------------+-----------+ | S32K144 | Yes | Cortex-M4F | 112 MHz | +----------+---------+------------+-----------+ | S32K146 | Yes | Cortex-M4F | 112 MHz | +----------+---------+------------+-----------+ | S32K148 | Yes | Cortex-M4F | 112 MHz | +----------+---------+------------+-----------+ | S32K142W | No** | Cortex-M4F | &gt; 80 MHz | +----------+---------+------------+-----------+ | S32K144W | No** | Cortex-M4F | &gt; 80 MHz | +----------+---------+------------+-----------+</p><p>| * Supported but (mostly) untested. | ** Not supported (yet), but it is expected that existing code can be adapted with limited effort.</p><h2 id="supported-modules-peripherals" tabindex="-1">Supported Modules &amp; Peripherals <a class="header-anchor" href="#supported-modules-peripherals" aria-label="Permalink to &quot;Supported Modules &amp; Peripherals&quot;">​</a></h2><p>The following list indicates modules and peripherals supported in NuttX. Note that this list does not include all MCU modules. Please refer to the S32K1XX Reference Manual for a complete overview of its features.</p><p>Peripheral Support Comments</p><hr><p>ADC CMP eDMA No No No<br> EEPROM ENET Yes Yes EEPROM emulated by FlexRAM FlexCAN Yes SocketCAN-compatible FlexIO Yes Emulated I2C Master driver FTM GPIO Yes Yes PWM driver only LPI2C LPSPI LPUART QSPI RTC SAI Yes Yes Yes No Yes No I2C Master and Slave</p><h3 id="adc" tabindex="-1">ADC <a class="header-anchor" href="#adc" aria-label="Permalink to &quot;ADC&quot;">​</a></h3><p>12-Bit Successive Approximation (SAR) Analog-to-Digital Converter (ADC). No driver support (yet).</p><h3 id="cmp" tabindex="-1">CMP <a class="header-anchor" href="#cmp" aria-label="Permalink to &quot;CMP&quot;">​</a></h3><p>Analog Comparator. No driver support (yet).</p><h3 id="edma" tabindex="-1">eDMA <a class="header-anchor" href="#edma" aria-label="Permalink to &quot;eDMA&quot;">​</a></h3><p>Enhanced Direct Memory Access module. There is a driver that was copied from the i.MX RT port, but this was not tested on S32K1XX.</p><h3 id="eeprom" tabindex="-1">EEPROM <a class="header-anchor" href="#eeprom" aria-label="Permalink to &quot;EEPROM&quot;">​</a></h3><p>Emulated EEPROM (implemented by FlexRAM module). A basic block driver is available to read and write data.</p><h3 id="enet" tabindex="-1">ENET <a class="header-anchor" href="#enet" aria-label="Permalink to &quot;ENET&quot;">​</a></h3><p>10/100 Mbit/s Ethernet MAC. Only available on S32K148. Driver is available.</p><h3 id="flexcan" tabindex="-1">FlexCAN <a class="header-anchor" href="#flexcan" aria-label="Permalink to &quot;FlexCAN&quot;">​</a></h3><p>The S32K1XX family has up to 3x FlexCAN modules (which may not all have CAN FD support). A SocketCAN-compatible driver is available.</p><h3 id="flexio" tabindex="-1">FlexIO <a class="header-anchor" href="#flexio" aria-label="Permalink to &quot;FlexIO&quot;">​</a></h3><p>A configurable module providing a range of functionality like emulation of a variety of serial/parallel communication protocols, flexible 16-bit timers or programmable logic blocks.</p><p>The <code>s32k1xx_flexio_i2c.c</code> driver implements an emulated I2C master using FlexIO. Albeit the current implementation has some limitations:</p><ul><li>Max I2C speed of 400KHz</li><li>Max transfer of 12 bytes (Could be extended by utilizing EDMA)</li><li>No abort on NACK reception, shifter simplies continues on</li><li>No multi-master support</li><li>No restart support</li></ul><h3 id="ftm" tabindex="-1">FTM <a class="header-anchor" href="#ftm" aria-label="Permalink to &quot;FTM&quot;">​</a></h3><p>A PWM driver based on FlexTimer (FTM) is available.</p><h3 id="gpio" tabindex="-1">GPIO <a class="header-anchor" href="#gpio" aria-label="Permalink to &quot;GPIO&quot;">​</a></h3>',30),e("p",null,[a("Pins can be configured using :c"),e("code",null,"s32k1xx_pinconfig"),a('{.interpreted-text role="func"} function. Writing to pins is done by :c'),e("code",{class:"interpreted-text",role:"func"},"s32k1xx_gpiowrite"),a(" function and reading is done by :c"),e("code",{class:"interpreted-text",role:"func"},"s32k1xx_gpioread"),a(".")],-1),e("h3",{id:"lpi2c",tabindex:"-1"},[a("LPI2C "),e("a",{class:"header-anchor",href:"#lpi2c","aria-label":'Permalink to "LPI2C"'},"​")],-1),e("p",null,[a("Low-Power Inter-Integrated Circuit (I2C) module supporting an interface to an I2C bus as master and/or as a slave. The lower-half of this driver is initialize by calling :c"),e("code",null,"s32k1xx_i2cbus_initialize"),a('{.interpreted-text role="func"}.')],-1),e("h3",{id:"lpspi",tabindex:"-1"},[a("LPSPI "),e("a",{class:"header-anchor",href:"#lpspi","aria-label":'Permalink to "LPSPI"'},"​")],-1),e("p",null,[a("Low-Power Serial Peripheral Interface (SPI) module that supports an interface to an SPI bus as a master and/or a slave. The lower-half of this driver is initialize by calling :c"),e("code",{class:"interpreted-text",role:"func"},"s32k1xx_lpspibus_initialize"),a(".")],-1),t('<h3 id="lpuart" tabindex="-1">LPUART <a class="header-anchor" href="#lpuart" aria-label="Permalink to &quot;LPUART&quot;">​</a></h3><p>Low-Power Universal Asynchronous Receiver/Transmitter (UART) module. UART is initialized automatically during MCU boot.</p><h3 id="qspi" tabindex="-1">QSPI <a class="header-anchor" href="#qspi" aria-label="Permalink to &quot;QSPI&quot;">​</a></h3><p>QuadSPI memory interface for external serial flash devices. No driver implemented.</p><h3 id="rtc" tabindex="-1">RTC <a class="header-anchor" href="#rtc" aria-label="Permalink to &quot;RTC&quot;">​</a></h3><p>Real-Time Clock module. A basic driver has been implemented.</p><h3 id="sai" tabindex="-1">SAI <a class="header-anchor" href="#sai" aria-label="Permalink to &quot;SAI&quot;">​</a></h3><p>The Synchronous Audio Interface for digital audio over I2S (Inter-IC Sound) is only available on S32K148. No driver implemented.</p><h2 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h2><blockquote><p>boards/<em>/</em></p></blockquote>',10)]))}const f=o(s,[["render",n]]);export{x as __pageData,f as default};
