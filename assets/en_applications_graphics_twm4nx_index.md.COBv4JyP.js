import{_ as t,c as i,al as o,o as n}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"twm4nx Tab Window Manager (TWM)","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/graphics/twm4nx/index.md","filePath":"en/applications/graphics/twm4nx/index.md"}'),a={name:"en/applications/graphics/twm4nx/index.md"};function s(r,e,l,d,c,h){return n(),i("div",null,e[0]||(e[0]=[o(`<h1 id="twm4nx-tab-window-manager-twm" tabindex="-1"><code>twm4nx</code> Tab Window Manager (TWM) <a class="header-anchor" href="#twm4nx-tab-window-manager-twm" aria-label="Permalink to &quot;\`twm4nx\` Tab Window Manager (TWM)&quot;">​</a></h1><p>Twm4Nx is a port of twm, Tab Window Manager (or Tom&#39;s Window Manager) version <code>1.0.10</code> to NuttX NX windows server. No, a port is not the right word. It is a re-design of TWM from the inside out to work with the NuttX NX server. The name Twm4Nx reflects this legacy. But Twm4Nx is more a homage to TWM than a port of TWM.</p><p>The original TWM was based on X11 which provides a rich set of features. TWM provided titlebars, shaped windows, several forms of icon management, user-defined macro functions, click-to-type and pointer-driven keyboard focus, graphic contexts, and user-specified key and pointer button bindings, etc.</p><p>Twm4Nx, on the other hand is based on the NuttX NX server which provides comparatively minimal support. Additional drawing support comes from the NuttX NxWidgets library (which necessitated the change to C++).</p><p>Twm4Nx is greatly stripped down and targeted on small embedded systems with minimal resources. For example, no assumption is made about the availability of a file system; no <code>.twmrc</code> file is used. Bitmaps are not used (other than for fonts).</p><p>The TWM license is, I believe compatible with the BSD license used by NuttX. The origin TWM license required notice of copyrights within each file and a full copy of the original license which you can find in the <code>COPYING</code> file. within this directory.</p><h2 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h2><h3 id="progress" tabindex="-1">Progress <a class="header-anchor" href="#progress" aria-label="Permalink to &quot;Progress&quot;">​</a></h3><ul><li><p><code>2019-04-28</code> This port was brutal. Much TWM logic was removed because it depended on X11 features (or just because I could not understand how to use it). The replacement logic is only mostly in place but more needs to be done to have a complete system (hence, it is marked <code>EXPERIMENTAL</code>). The kinds of things that need to done are:</p><ol><li><p>Right click should bring up a window list (like the icon manager???)</p></li><li></li></ol><pre><code>For TWM-like behavior, a window frame and toolbar should be highlighted

:   when the window has focus.
</code></pre><ol start="3"><li>A right click on the toolbar should bring up a window-specific menu.</li></ol></li><li><p><code>2019-05-02</code> Some testing progress. The system comes up, connects to and initializes the VNC window. For some reason, the VNC client breaks the connection. The server is no longer connected so Twm4Nx constipates and and eventually hangs.</p></li><li><p><code>2019-05-08</code> I abandoned the VNC interface and found that things are much better using a direct, hardware framebuffer. The background comes up properly and the Icon Manager appears properly in the upper right hand corner. The Icon Manager Window can be iconified or de-iconified. The Icon Manager window can be grabbed by the toolbar title and moved about on the window (the movement is not very smooth on the particular hardware that I am working with).</p></li><li><p><code>2019-05-10</code> A left click on the background brings up the main menu. At present there are only two options: _<a href="./.html">Desktop</a> which will iconify all windows and &quot;Twm4Nx Icon Manager&quot; which will de-iconify and/or raise the Icon Manager window to the top of the hierarchy. That latter option is only meaningful when the desktop is very crowded.</p></li><li><p><code>2019-05-13</code> Added the NxTerm application. If enabled via <code>CONFIG_TWM4XN_NXTERM</code>, there will now be a _<a href="./.html">NuttShell</a> entry in the Main Menu. When pressed, this will bring up an NSH session in a Twm4Nx window.</p></li><li><p><code>2019-05-14</code> We can now move an icon on the desktop. Includes logic to avoid collisions with other icons and with the background image. That later is an issue. The background image image widget needs to be removed; it can occlude a desktop icon. We need to paint the image directly on the background without the use of a widget.</p></li><li><p><code>2019-05-15</code> Resizing now seems to work correctly in Twm4Nx.</p></li><li><p><code>2019-05-20</code> Calibration screen is now in place.</p></li><li><p><code>2019-05-21</code> A <code>CONTEMPORARY</code> theme was added. Still has a few glitches.</p></li><li><p><code>2019-06-01</code> A retro, emulated segment LCD clock is now in place.</p></li></ul><h2 id="how-to" tabindex="-1">How To <a class="header-anchor" href="#how-to" aria-label="Permalink to &quot;How To&quot;">​</a></h2><h3 id="icon-manager" tabindex="-1">Icon Manager <a class="header-anchor" href="#icon-manager" aria-label="Permalink to &quot;Icon Manager&quot;">​</a></h3><ul><li><p>At start up, only the Icon Manager window is shown. The Icon Manager is a TWM alternative to more common desktop icons. Currently Twm4Nx supports both desktop icons and the Icon Manager.</p><p>Whenever a new application is started from the Main Menu, its name shows up in the Icon Manager. Selecting the name will either de-iconify the window, or just raise it to the top of the display.</p></li></ul><h3 id="main-menu" tabindex="-1">Main Menu <a class="header-anchor" href="#main-menu" aria-label="Permalink to &quot;Main Menu&quot;">​</a></h3><ul><li>A touch/click at any open location on the background (except the image at the center or on another icon) will bring up the Main Menu. Options: <ul><li>Desktop. Iconify all windows and show the desktop</li><li>Twm4Nx Icom Manager. De-iconify and/or raise the Icon Manager to the top of the display.</li><li>Calibration. Perform touchscreen re-calibration.</li><li>Clock. Start and instance of clock in the window. The uses the the retro, LCD emulation of <code>apps/graphics/slcd</code>.</li><li>NuttShell. Start and instance of NSH running in an NxTerm.</li></ul></li><li>All windows close after the terminal menu option is selected.</li></ul><h3 id="window-toolbar" tabindex="-1">Window Toolbar <a class="header-anchor" href="#window-toolbar" aria-label="Permalink to &quot;Window Toolbar&quot;">​</a></h3><ul><li>Most windows have a toolbar at the top. It is optional but used in most windows.</li><li>The toolbar contains window title and from zero to 4 buttons: <ul><li>Right side: A menu button may be presented. The menu button is not used by anything in the current implementation and is always suppressed</li><li>Left side: The far left is (1) the terminate button (if present). If present, it will close window when selected. Not all windows can be closed. You can&#39;t close the Icon Manager or menu windows, for example. Then (2) a resize button. If presented and is selected, then the resize sequence described below it started. This may the be preceded by a minimize button that iconifies the window.</li></ul></li></ul><h3 id="moving-a-window" tabindex="-1">Moving a Window <a class="header-anchor" href="#moving-a-window" aria-label="Permalink to &quot;Moving a Window&quot;">​</a></h3><ul><li>Grab the title in the toolbar and move the window to the desired position.</li></ul><h3 id="resizing-a-window" tabindex="-1">Resizing a Window <a class="header-anchor" href="#resizing-a-window" aria-label="Permalink to &quot;Resizing a Window&quot;">​</a></h3><ul><li>A window must have the green resize button with the square or it cannot be resized.</li><li>Press resize button. A small window should pop-up in the upper left hand corner showing the current window size.</li><li>Touch anywhere in window (not the toolbar) and slide your finger. The resize window will show the new size but there will be no other update to the display. It is thought that continuous size updates would overwhelm lower end MCUs. Movements support include: <ul><li>Move toward the right increases the width of the window</li><li>Move toward the left decreases the width of the window</li><li>Move toward the bottom increases the height of the window</li><li>Move toward the top decreases the height of the Window</li><li>Other moves will affect both the height and width of the window.</li></ul></li><li><strong>Note</strong>: While resizing, non-critical events from all other windows are ignored.</li></ul><h3 id="themes" tabindex="-1">Themes <a class="header-anchor" href="#themes" aria-label="Permalink to &quot;Themes&quot;">​</a></h3><ul><li>There are two themes support by the configuration system: <ul><li><code>CONFIG_TWM4NX_CLASSIC</code> -- Strong bordered windows with dark primary colors. Reminiscent of Windows 98.</li><li><code>CONFIG_TWM4NX_CONTEMPORARY</code> -- Border-less windows in pastel shades for a more contemporary look.</li></ul></li></ul><h3 id="issues" tabindex="-1">Issues <a class="header-anchor" href="#issues" aria-label="Permalink to &quot;Issues&quot;">​</a></h3><p><code>2019-05-16</code> Twm4Nx is in a very complete state but only at perhaps _<a href="./.html">alpha</a> in its maturity. You should expect to see some undocumented problems. If you see such problems and can describe a sequence to actions to reproduce the problem, let me know and I will try to resolve the problems.</p><p>Here are all known issues and features that are missing:</p><p>TWM Compatibilities Issues:</p><ol><li>Resizing works a little differently in Twm4Nx.</li><li>Right click should bring up a window list</li><li>For TWM-like behavior, a window frame and toolbar should be highlighted when the window has focus.</li><li>A right click on the toolbar should bring up a window-specific menu.</li></ol><p>There are no near-term plans to address these compatibility issues.</p><p>Other issues/bugs. All-in-all, I would say that Twm4Nx is maturing well and is attaining stability. That being said, there are some issues and untested functionality that should be addressed:</p><ol><li>Icon drag movement includes logic to avoid collisions with other icons and with the background image. That later is an issue. We need to paint the image directly on the background without the use of a widget.</li><li>There are a few color artifacts in the toolbar of the <code>CONTEMPORARY</code> theme. These look like borders are being drawn around the toolbar widgets (even though the are configured to be borderless).</li><li>Most Twm4Nx configuration settings are hard-coded in <code>*_config.hxx</code> header files. These all need to be brought out and made accessible via Kconfig files</li><li>I have seen some odd behavior when many NxTerm windows have been opened (around 15). Specifically, I see failures to start NSH in the windows so they come up blank. All other behaviors seem normal. Most likely, some NxTerm resource allocation is failing silently and leaving things in an unusable state. The board I am using has 128Mb of SDRAM so I can&#39;t believe that memory is the limiting factor. These are, however, RAM-backed windows and will use significant amounts of memory. The primary issue is that the number of windows should probably be managed in some way to assure that the end-user does not experience odd behaviors when resource usage is high.</li><li>Menus with sub-menus have not been verified. There is no use of sub- menus in the current code base so I expect that there are issues when, for example, and item from a sub-menu item: That menu and all of its antecedent menus should be closed.</li><li>There is an optional MENU button that may appear at the far left on the toolbar. It is not used by any window in the current code base and, hence, is unverified. I would expect some issues with generating and routing the MENU button events to applications. There are likely other unverified features.</li><li>X/Y input may be either via a touchscreen or a mouse. Only touchscreen input has been verified. There is, however, very little difference. The primary issue is in cursor support: Cursors are needed with a mouse. Cursor images also change depending on the state (like grabbing and dragging or resizing). There is also a possibility of using auto-raise with a mouse as well. All of this logic is in place, but none has been verified.</li><li>NxTerm windows really need to be scrollable. They are difficult to use with only a few lines on a small display. A related usability issue is the font height: The fonts report a maximum font height that results in a large line spacing on the display and, hence, fewer lines visible in the small window. This is latter issues is a problem with the fonts not Twm4Nx, however.</li><li>There is a trivial rounding error in the calculation of the LCD width in <code>SLcd::CSLcd::getWidth()</code>. It currently truncates down. It needs to round up. This sometimes leaves a small, one-pixel- wide sliver on the clock display. This display always recovers and this only cosmetic.</li></ol><h2 id="adding-twm4nx-applications" tabindex="-1">Adding Twm4Nx Applications <a class="header-anchor" href="#adding-twm4nx-applications" aria-label="Permalink to &quot;Adding Twm4Nx Applications&quot;">​</a></h2><h3 id="application-factories-and-the-main-menu" tabindex="-1">Application Factories and the Main Menu <a class="header-anchor" href="#application-factories-and-the-main-menu" aria-label="Permalink to &quot;Application Factories and the Main Menu&quot;">​</a></h3><p>The original TWM supported a .twmrc in which you could describe application programs supported on the desktop. Currently no such start-up file is available for Twm4Nx. Rather, all applications must be added via run-time interfaces. And overview of these interfaces is provided in this paragraph.</p><p>Currently, there are only two applications developed for Twm4Nx: (1) An NxTerm hosting NSH that is analogous to an XTerm hosting the Bash shell in a Unix environment, and (2) a touchscreen calibration application. Let&#39;s focus instead on the NxTerm application as an example because the touchscreen calibration is a rather unusual beast.</p><p>These example applications can be found at: <code>apps/graphics/twm4nx/apps</code> and <code>apps/include/graphics/twm4nx/apps</code></p><p>In short, adding an application involves a &quot;Factory Object&quot; that is hooked into the Main Menu. A Factory Object is an object that is used to create other object instances. The way in which the Factory Object is represented is purely a decision of the application developer. One option, however, is to use the pure virtual base class <code>IApplicationFactory</code> as defined in <code>apps/include/graphics/twm4nx/iapplication.hxx</code>. This base class provides only a single method:</p><pre><code>bool initialize(FAR CTwm4Nx *twm4nx);
</code></pre><p>where CTwm4Nx is the Twm4NX session instance that allows the class implementation to interact with session specific resources. Multiple sessions would be required, for example, if the platform supported multiple displays.</p><p>In practice, the application factory implementation class inherits from the following base classes:</p><ol><li><p><code>IApplicationFactory</code>. Provides the common <code>initialize()</code> method.</p></li><li></li></ol><pre><code>\`IApplication\`. Provides the information for the application\\&#39;s entry in the

:   Main Menu
</code></pre><ol start="3"><li></li></ol><pre><code>\`CTwm4NxEvent\`. Hooks the application factory into the Twm4Nx event

:   notification system.
</code></pre><p>Initialization consists of instantiating the application factory instance and calling its <code>IApplicationFactory::initialize()</code> method. The application factory instance is a singleton that must persist for the life of the session. For the NxTerm application factory, this is done in <code>apps/graphics/twm4nx/src/twm4nx_main.c</code> like:</p><pre><code>CNxTermFactory nxtermFactory;
success = nxtermFactory.initialize(twm4nx);
</code></pre><p>In addition to general initialization, the <code>IApplicationFactory::initialize()</code> method must register a new entry with the main menu. You can see an example of this in <code>apps/graphics/twm4nx/apps/cnxterm.c</code>:</p><pre><code>FAR CMainMenu *cmain = twm4nx-&gt;getMainMenu();
return cmain-&gt;addApplication(this);
</code></pre><p>The argument to the <code>CMainMenu::addApplication()</code> method is of type <code>IApplication *</code>. Remember, however, that our application implementation <code>class</code> inherited from <code>IApplication</code>.</p><p>The IApplication pure virtual base class is also defined in <code>apps/include/graphics/twm4nx/iapplication.hxx</code>. It essentially describes what the Main Menu logic should do when the menu item is selected. It includes these methods:</p><ol><li></li></ol><pre><code>\`getName()\`. Provides the name string that will be shown in the Main Menu for

:   this selection.
</code></pre><ol start="2"><li></li></ol><pre><code>\`getSubMenu()\`. One possibility is that selecting the Main Menu item is that

:   it may bring up yet another sub-menu of options.
</code></pre><ol start="3"><li></li></ol><pre><code>\`getEventHandler()\`. Returns an instance of \`CTwm4NxEvent\` that is used to

:   route menu selection events. Remember that our application
    factory inherits from \`CTwm4NxEvent\` so this function only needs
    to return the \\&#39;this\\&#39; pointer.
</code></pre><ol start="4"><li></li></ol><pre><code>\`getEvent()\`. Provides the event ID that will be used in the event

:   notification. The returned value must conform to the description
    in \`apps/include/graphics/twm4nx/twm4nx_events.hxx\`. In
    particular, the recipient of the event must be
    \`EVENT_RECIPIENT_APP\`.
</code></pre><p>The Twm4Nx application is then started when the application factory&#39;s <code>CTwm4NxEvent::event()</code> method is called with the specified event.</p><h3 id="application-windows" tabindex="-1">Application Windows <a class="header-anchor" href="#application-windows" aria-label="Permalink to &quot;Application Windows&quot;">​</a></h3><p>How the application factory starts an application instance is purely up to the application designer. Typically this would include starting a new application task. General characteristics of an application include:</p><ol><li></li></ol><pre><code>It probably should inherit from \`CTwm4NxEvent\` so that it can receive events

:   from the system.
</code></pre><ol start="2"><li></li></ol><pre><code>To create the window, it must instantiate and initialize an instance of

:   \`CWindow\`.
</code></pre><ol start="3"><li>It must configure application events to receive notifications from Twm4Nx.</li></ol><p>To create an application window, the application must call the <code>CWindowFactory::createWindow()</code> method. For the NxTerm example, this looks like:</p><pre><code>NXWidgets::CNxString name(&quot;NuttShell&quot;);

uint8_t wflags = (WFLAGS_NO_MENU_BUTTON | WFLAGS_HIDDEN);

FAR CWindowFactory *factory = m_twm4nx-&gt;getWindowFactory();
m_nxtermWindow = factory-&gt;createWindow(name, &amp;CONFIG_TWM4NX_NXTERM_ICON,
                                        (FAR CIconMgr *)0, wflags);
</code></pre><p>The window factory is another factory that creates and manages window instance. The <code>createWindow()</code> method requires four parameters:</p><ol><li></li></ol><pre><code>The name of the window. This is the name that is show in the window toolbar

:   and may be the same name as was used in the Main Menu entry.
</code></pre><ol start="2"><li></li></ol><pre><code>A reference to the the Icon image associated with the window. This is the

:   image that is show on the desktop when the window is iconified.
    It is of type \`NXWidgets::SRlePaletteBitmap\`.
</code></pre><ol start="3"><li></li></ol><pre><code>A pointer to the Icon Manager instance that this window belongs with. This

:   can be NULL to use the default Twm4Nx Icon Manager.
</code></pre><ol start="4"><li>A set of flags that describe properties of the windows.</li></ol><blockquote><p>The flag values are defined byte <code>WFLAGS_*</code> definitions provided in <code>apps/include/graphics/twm4nx/cwindow.hxx</code>:</p><ul><li><code>WFLAGS_NO_MENU_BUTTON</code> -- Omit the menu button from the toolbar.</li><li><code>WFLAGS_NO_DELETE_BUTTON</code> -- Omit the delete button from the toolbar.</li><li><code>WFLAGS_NO_RESIZE_BUTTON</code> -- Omit the resize button from the toolbar.</li><li><code>WFLAGS_NO_MINIMIZE_BUTTON</code> -- Omit the minimize button from the toolbar.</li><li><code>WFLAGS_NO_TOOLBAR</code> -- Omit the toolbar altogether.</li><li><code>WFLAGS_ICONMGR</code> -- This window is an icon manager.</li><li><code>WFLAGS_MENU</code> -- This window is a menu window.</li><li><code>WFLAGS_HIDDEN</code> -- Start with the window hidden.</li></ul></blockquote><p>Once the <code>CWindow</code> is instantiated, events needed by the application can be configured as is done in the NxTerm application:</p><pre><code>struct SAppEvents events;
events.eventObj    = (FAR void *)this;
events.redrawEvent = EVENT_NXTERM_REDRAW;
events.resizeEvent = EVENT_NXTERM_RESIZE;
events.mouseEvent  = EVENT_NXTERM_XYINPUT;
events.kbdEvent    = EVENT_NXTERM_KBDINPUT;
events.closeEvent  = EVENT_NXTERM_CLOSE;
events.deleteEvent = EVENT_NXTERM_DELETE;

bool success = m_nxtermWindow-&gt;configureEvents(events);
</code></pre><p>Again, recall that the application inherits from <code>CTwm4NxEvent</code>. So passing <code>this</code> as the event object above assures that the specific events are routed to the application instance.</p><p>Drawing in the application window can be performed using that facilities of NXWidgets using the <code>NXWidgets::CGraphicsPort</code> associated with the window. The NxTerm application does not perform any drawing, however; that drawing is performed by the NxTerm driver.</p><p>The <code>NXWidgets::CGraphicsPort</code> can be obtained from a <code>CWindow</code> instance, say <code>m_window</code>, like:</p><pre><code>FAR NXWidgets::CWidgetControl *control = m_window-&gt;getWidgetControl();
NXWidgets::CGraphicsPort *port = control-&gt;getGraphicsPort();
</code></pre><p>That <code>CGraphicsPort</code> is then passed to the widget constructor, binding the widget to that window and forcing all widget drawing to occur within the window.</p><p>Obviously, a lot more could be written about drawing, much more than can be addressed in this README file.</p>`,84)]))}const w=t(a,[["render",s]]);export{u as __pageData,w as default};
