import{_ as t,c as o,al as i,o as n}from"./chunks/framework.NFAqBSgQ.js";const c=JSON.parse('{"title":"fire-stm2v2","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/stm32f1/boards/fire-stm32v2/index.md","filePath":"en/platforms/arm/stm32f1/boards/fire-stm32v2/index.md"}'),a={name:"en/platforms/arm/stm32f1/boards/fire-stm32v2/index.md"};function r(s,e,l,d,h,u){return n(),o("div",null,e[0]||(e[0]=[i(`<h1 id="fire-stm2v2" tabindex="-1">fire-stm2v2 <a class="header-anchor" href="#fire-stm2v2" aria-label="Permalink to &quot;fire-stm2v2&quot;">​</a></h1><p>chip:stm32, chip:stm32f1, chip:stm32f103</p><p>This page discusses issues unique to NuttX configurations for the M3 Wildfire development board (STM32F103VET6). See <a href="http://firestm32.taobao.com" target="_blank" rel="noreferrer">http://firestm32.taobao.com</a></p><p>This configuration should support both the version 2 and version 3 of the Wildfire board (using NuttX configuration options). However, only version 2 has been verified.</p><h2 id="pin-configuration" tabindex="-1">Pin Configuration <a class="header-anchor" href="#pin-configuration" aria-label="Permalink to &quot;Pin Configuration&quot;">​</a></h2><h2 id="dfu-and-jtag" tabindex="-1">DFU and JTAG <a class="header-anchor" href="#dfu-and-jtag" aria-label="Permalink to &quot;DFU and JTAG&quot;">​</a></h2><h3 id="enabling-support-for-the-dfu-bootloader" tabindex="-1">Enabling Support for the DFU Bootloader <a class="header-anchor" href="#enabling-support-for-the-dfu-bootloader" aria-label="Permalink to &quot;Enabling Support for the DFU Bootloader&quot;">​</a></h3><p>The linker files in these projects can be configured to indicate that you will be loading code using STMicro built-in USB Device Firmware Upgrade (DFU) loader or via some JTAG emulator. You can specify the DFU bootloader by adding the following line:</p><pre><code>CONFIG_STM32_DFU=y
</code></pre><p>to your .config file. Most of the configurations in this directory are set up to use the DFU loader.</p><p>If CONFIG_STM32_DFU is defined, the code will not be positioned at the beginning of FLASH (0x08000000) but will be offset to 0x08003000. This offset is needed to make space for the DFU loader and 0x08003000 is where the DFU loader expects to find new applications at boot time. If you need to change that origin for some other bootloader, you will need to edit the file(s) ld.script.dfu for the configuration.</p><p>The DFU SE PC-based software is available from the STMicro website, <a href="http://www.st.com" target="_blank" rel="noreferrer">http://www.st.com</a>. General usage instructions:</p><ol><li>Convert the NuttX Intel Hex file (nuttx.hex) into a special DFU file (nuttx.dfu)... see below for details.</li><li>Connect the M3 Wildfire board to your computer using a USB cable.</li><li>Start the DFU loader on the M3 Wildfire board. You do this by resetting the board while holding the <em>Key</em> button. Windows should recognize that the DFU loader has been installed.</li><li>Run the DFU SE program to load nuttx.dfu into FLASH.</li></ol><p>What if the DFU loader is not in FLASH? The loader code is available inside of the Demo directory of the USBLib ZIP file that can be downloaded from the STMicro Website. You can build it using RIDE (or other toolchains); you will need a JTAG emulator to burn it into FLASH the first time.</p><p>In order to use STMicro&#39;s built-in DFU loader, you will have to get the NuttX binary into a special format with a .dfu extension. The DFU SE PC_based software installation includes a file &quot;DFU File Manager&quot; conversion program that a file in Intel Hex format to the special DFU format. When you successfully build NuttX, you will find a file called nutt.hex in the top-level directory. That is the file that you should provide to the DFU File Manager. You will end up with a file called nuttx.dfu that you can use with the STMicro DFU SE program.</p><h3 id="enabling-jtag" tabindex="-1">Enabling JTAG <a class="header-anchor" href="#enabling-jtag" aria-label="Permalink to &quot;Enabling JTAG&quot;">​</a></h3><p>If you are not using the DFU, then you will probably also need to enable JTAG support. By default, all JTAG support is disabled but there NuttX configuration options to enable JTAG in various different ways.</p><p>These configurations effect the setting of the SWJ_CFG[2:0] bits in the AFIO MAPR register. These bits are used to configure the SWJ and trace alternate function I/Os. The SWJ (SerialWire JTAG) supports JTAG or SWD access to the Cortex debug port. The default state in this port is for all JTAG support to be disabled.:</p><pre><code>CONFIG_STM32_JTAG_FULL_ENABLE - sets SWJ_CFG[2:0] to 000 which enables full
  SWJ (JTAG-DP + SW-DP)

CONFIG_STM32_JTAG_NOJNTRST_ENABLE - sets SWJ_CFG[2:0] to 001 which enable
  full SWJ (JTAG-DP + SW-DP) but without JNTRST.

CONFIG_STM32_JTAG_SW_ENABLE - sets SWJ_CFG[2:0] to 010 which would set JTAG-DP
  disabled and SW-DP enabled.

The default setting (none of the above defined) is SWJ_CFG[2:0] set to 100
which disable JTAG-DP and SW-DP.
</code></pre><h2 id="openocd" tabindex="-1">OpenOCD <a class="header-anchor" href="#openocd" aria-label="Permalink to &quot;OpenOCD&quot;">​</a></h2><p>I have also used OpenOCD with the M3 Wildfire. In this case, I used the Olimex USB ARM OCD. See the script in boards/arm/stm32/fire-stm32v2/tools/oocd.sh for more information. Using the script:</p><ul><li><p>Start the OpenOCD GDB server:</p><pre><code>cd &lt;nuttx-build-directory&gt;
boards/arm/stm32/fire-stm32v2/tools/oocd.sh PWD
</code></pre></li><li><p>Load NuttX:</p><pre><code>cd &lt;nuttx-built-directory&gt;
arm-none-eabi-gdb nuttx
gdb&gt; target remote localhost:3333
gdb&gt; mon reset
gdb&gt; mon halt
gdb&gt; load nuttx
</code></pre></li><li><p>Running NuttX:</p><pre><code>gdb&gt; mon reset
gdb&gt; c
</code></pre></li></ul><h2 id="leds" tabindex="-1">LEDs <a class="header-anchor" href="#leds" aria-label="Permalink to &quot;LEDs&quot;">​</a></h2><p>The M3 Wildfire has 3 LEDs labeled LED1, LED2 and LED3. These LEDs are not used by the NuttX port unless CONFIG_ARCH_LEDS is defined. In that case, the usage by the board port is defined in include/board.h and src/up_autoleds.c. The LEDs are used to encode OS-related events as follows:</p><pre><code>/* LED1   LED2   LED3 */
#define LED_STARTED                0  /* OFF    OFF    OFF */
#define LED_HEAPALLOCATE           1  /* ON     OFF    OFF */
#define LED_IRQSENABLED            2  /* OFF    ON     OFF */
#define LED_STACKCREATED           3  /* OFF    OFF    OFF */

#define LED_INIRQ                  4  /* NC     NC    ON  (momentary) */
#define LED_SIGNAL                 5  /* NC     NC    ON  (momentary) */
#define LED_ASSERTION              6  /* NC     NC    ON  (momentary) */
#define LED_PANIC                  7  /* NC     NC    ON  (2Hz flashing) */
#undef  LED_IDLE                      /* Sleep mode indication not supported */
</code></pre><h2 id="rtc" tabindex="-1">RTC <a class="header-anchor" href="#rtc" aria-label="Permalink to &quot;RTC&quot;">​</a></h2><p>The STM32 RTC may configured using the following settings.:</p><pre><code>CONFIG_RTC - Enables general support for a hardware RTC. Specific
  architectures may require other specific settings.
CONFIG_RTC_HIRES - The typical RTC keeps time to resolution of 1
  second, usually supporting a 32-bit time_t value.  In this case,
  the RTC is used to &amp;quot;seed&amp;quot; the normal NuttX timer and the
  NuttX timer provides for higher resolution time. If CONFIG_RTC_HIRES
  is enabled in the NuttX configuration, then the RTC provides higher
  resolution time and completely replaces the system timer for purpose of
  date and time.
CONFIG_RTC_FREQUENCY - If CONFIG_RTC_HIRES is defined, then the
  frequency of the high resolution RTC must be provided.  If CONFIG_RTC_HIRES
  is not defined, CONFIG_RTC_FREQUENCY is assumed to be one.
CONFIG_RTC_ALARM - Enable if the RTC hardware supports setting of an alarm.
  A callback function will be executed when the alarm goes off.
</code></pre><p>In hi-res mode, the STM32 RTC operates only at 16384Hz. Overflow interrupts are handled when the 32-bit RTC counter overflows every 3 days and 43 minutes. A BKP register is incremented on each overflow interrupt creating, effectively, a 48-bit RTC counter.</p><p>In the lo-res mode, the RTC operates at 1Hz. Overflow interrupts are not handled (because the next overflow is not expected until the year 2106).</p><p>WARNING: Overflow interrupts are lost whenever the STM32 is powered down. The overflow interrupt may be lost even if the STM32 is powered down only momentarily. Therefore hi-res solution is only useful in systems where the power is always on.</p><h2 id="m3-wildfire-specific-configuration-options" tabindex="-1">M3 Wildfire-specific Configuration Options <a class="header-anchor" href="#m3-wildfire-specific-configuration-options" aria-label="Permalink to &quot;M3 Wildfire-specific Configuration Options&quot;">​</a></h2><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><p>Each M3 Wildfire configuration is maintained in a sub-directory and can be selected as follow:</p><pre><code>tools/configure.sh fire-stm32v2:&lt;subdir&gt;
</code></pre><p>Where &lt;subdir&gt; is one of the following:</p><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>Configure the NuttShell (nsh) located at examples/nsh. The nsh configuration contains support for some built-in applications that can be enabled by making some additional minor change to the configuration file.</p><p>Reconfiguring: This configuration uses to the kconfig-mconf configuration tool to control the configuration. See the section entitled &quot;NuttX Configuration Tool&quot; in the top-level README.txt file.</p><p>Start Delays: If no SD card is present in the slot, or if the network is not connected, then there will be long start-up delays before you get the NSH prompt. If I am focused on ENC28J60 debug, I usually disable MMC/SD so that I don&#39;t have to bother with the SD card:</p><pre><code>CONFIG_STM32_SDIO=n
CONFIG_MMCSD=n
</code></pre><p>STATUS: The board port is basically functional. Not all features have been verified. The ENC28J60 network is not yet functional. Networking is enabled by default in this configuration for testing purposes. To use this configuration, the network must currently be disabled. To do this using the kconfig-mconf configuration tool:</p><pre><code>&gt; make menuconfig
</code></pre><p>Then de-select &quot;Networking Support&quot; -&gt; &quot;Networking Support&quot;</p><p>PDATE: The primary problem with the ENC29J60 is a v2 board issue: The SPI FLASH and the ENC28J60 shared the same SPI chip select signal (PA4-SPI1-NSS). In order to finish the debug of the ENC28J60, it may be necessary to lift the SPI FLASH chip select pin from the board.</p>`,45)]))}const p=t(a,[["render",r]]);export{c as __pageData,p as default};
