import{_ as a,c as e,al as n,o as t}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"Testing TCP/IP Network Stacks","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/testingtcpip.md","filePath":"en/guides/testingtcpip.md"}'),p={name:"en/guides/testingtcpip.md"};function i(o,s,l,c,r,d){return t(),e("div",null,s[0]||(s[0]=[n(`<h1 id="testing-tcp-ip-network-stacks" tabindex="-1">Testing TCP/IP Network Stacks <a class="header-anchor" href="#testing-tcp-ip-network-stacks" aria-label="Permalink to &quot;Testing TCP/IP Network Stacks&quot;">​</a></h1><p>When working on the network stack there is a need to test and verify the changes made. While problems may be discovered by chance, it is hard to reproduce such situations. The following sections show some methods to stress the target or generate some specific traffic.</p><p>In the examples the target has the IP address 192.168.2.135</p><h2 id="syn-flood-attack" tabindex="-1">SYN Flood Attack <a class="header-anchor" href="#syn-flood-attack" aria-label="Permalink to &quot;SYN Flood Attack&quot;">​</a></h2><p>Flood the target with SYN packets to exhaust its resources. It&#39;s a good way to test the network driver&#39;s buffer management.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo hping3 --flood -S -p 80 192.168.2.135</span></span></code></pre></div><h2 id="building-packets-with-scapy" tabindex="-1">Building Packets with Scapy <a class="header-anchor" href="#building-packets-with-scapy" aria-label="Permalink to &quot;Building Packets with Scapy&quot;">​</a></h2><p>A wonderful network testing tool is the Scapy lib. It enables you to build pretty much any packet constellation you need for testing.</p><p>You have to add an iptables rule to prevent outgoing RST packets from the OS&#39;s networking stack which does nothing know about our test connection.</p><p>To disable outgoing RST packets:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo iptables -A OUTPUT -p tcp --tcp-flags RST RST -d 192.168.2.135 -j DROP</span></span></code></pre></div><p>For removing the rule:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo iptables -D OUTPUT -p tcp --tcp-flags RST RST -d 192.168.2.135 -j DROP</span></span></code></pre></div><p><strong>Testing Re-transmission behavior</strong></p><p>When sending a 3-way handshake only, the target should time out and reset the connection.</p><p>The following Python Scapy script starts a HTTP request without further responding. The stack should start re-transmit the packets and finally time out.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#!/usr/bin/env python</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import logging</span></span>
<span class="line"><span>logging.getLogger(&quot;scapy.runtime&quot;).setLevel(logging.ERROR)</span></span>
<span class="line"><span>from scapy.all import *</span></span>
<span class="line"><span></span></span>
<span class="line"><span>get = &#39;GET / HTTP/1.1\\r\\n\\r\\n&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ip = IP(dst=&quot;192.168.2.135&quot;)</span></span>
<span class="line"><span>port = RandNum(1024, 65535)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Create SYN packet</span></span>
<span class="line"><span>SYN = ip/TCP(sport=port, dport=80, flags=&quot;S&quot;, seq=42)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Send SYN and receive SYN,ACK</span></span>
<span class="line"><span>SYNACK = sr1(SYN)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># Create ACK with GET request</span></span>
<span class="line"><span>ACK = ip/TCP(sport=SYNACK.dport, dport=80, flags=&quot;A&quot;, seq=SYNACK.ack, ack=SYNACK.seq + 1)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># SEND our ACK</span></span>
<span class="line"><span>send(ACK)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>reply, err = sr(ip/TCP(sport=SYNACK.dport, dport=80, flags=&quot;A&quot;, seq=SYNACK.ack, ack=SYNACK.seq + 1) / get)</span></span></code></pre></div><h2 id="simulating-packet-loss" tabindex="-1">Simulating Packet Loss <a class="header-anchor" href="#simulating-packet-loss" aria-label="Permalink to &quot;Simulating Packet Loss&quot;">​</a></h2><p>With simulating packet loss one can test the re-transmission behavior of the target stack.</p><p>To start packet loss:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># for randomly dropping 10% of incoming packets:</span></span>
<span class="line"><span>sudo iptables -A INPUT -m statistic --mode random --probability 0.1 -j DROP</span></span>
<span class="line"><span></span></span>
<span class="line"><span># and for dropping 10% of outgoing packets:</span></span>
<span class="line"><span>sudo iptables -A OUTPUT -m statistic --mode random --probability 0.1 -j DROP</span></span></code></pre></div><p>To remove the rules:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># for the incoming packets:</span></span>
<span class="line"><span>sudo iptables -D INPUT -m statistic --mode random --probability 0.1 -j DROP</span></span>
<span class="line"><span></span></span>
<span class="line"><span># and for the outgoing packets</span></span>
<span class="line"><span>sudo iptables -D OUTPUT -m statistic --mode random --probability 0.1 -j DROP</span></span></code></pre></div><h2 id="fuzz-testing" tabindex="-1">Fuzz-Testing <a class="header-anchor" href="#fuzz-testing" aria-label="Permalink to &quot;Fuzz-Testing&quot;">​</a></h2><p>For fuzz testing network applications the excellent <a href="https://www.immunitysec.com/resources-freesoftware.shtml" target="_blank" rel="noreferrer">SPIKE</a> tool can be used. To make it compile under Ubuntu 14.04 LTS you have to add <code>-fno-stack-protector</code> to CFLAGS.</p><p>SPIKE complained about missing SSL libs. I simply linked the existing to the needed filenames:</p><pre><code>/lib/i386-linux-gnu sudo ln -s ./libssl.so.1.0.0 ./libssl.so.0
/lib/i386-linux-gnu sudo ln -s ./libcrypto.so.1.0.0 ./libcrypto.so.0
</code></pre><p>Maybe those lib versions aren&#39;t the expected by SPIKE but if you don&#39;t use SSL it works fine.</p><p>SPIKE provides a proxy server to record requests to your web application. Based on these requests a application specific fuzz test can be generated.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>~/SPIKE/src mkdir requests &amp;&amp; cd requests</span></span>
<span class="line"><span># Record requests to the target at 192.168.2.135 on port 80</span></span>
<span class="line"><span>~/SPIKE/src/requests ../webmitm -t 192.168.2.135 -p 80</span></span></code></pre></div><p>Now use your web application through localhost to record some requests. Then you can generate your application-specific fuzz test from the recorded requests.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>~/SPIKE/src ./makewebfuzz.pl ./requests/http_request-1.0 &gt; myfuzz.c</span></span>
<span class="line"><span>~/SPIKE/src gcc ./myfuzz.c -I../include -o myfuzz -L. -ldlrpc -ldl</span></span></code></pre></div><p>Now you can fuzz your target:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>~/SPIKE/src LD_LIBRARY_PATH=. ./myfuzz 192.168.2.135 80</span></span></code></pre></div>`,34)]))}const g=a(p,[["render",i]]);export{h as __pageData,g as default};
