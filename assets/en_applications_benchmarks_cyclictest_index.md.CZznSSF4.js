import{_ as s,c as t,al as a,o as i}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"Cyclictest benchmark utility","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/benchmarks/cyclictest/index.md","filePath":"en/applications/benchmarks/cyclictest/index.md"}'),n={name:"en/applications/benchmarks/cyclictest/index.md"};function o(c,e,l,d,p,r){return i(),t("div",null,e[0]||(e[0]=[a(`<h1 id="cyclictest-benchmark-utility" tabindex="-1"><code>Cyclictest</code> benchmark utility <a class="header-anchor" href="#cyclictest-benchmark-utility" aria-label="Permalink to &quot;\`Cyclictest\` benchmark utility&quot;">​</a></h1><p>Cyclictest is a simple program used to measure the real-time capabilities of a RTOS. Originally, this program comes from the Linux <code>rt-tests</code>. However, NuttX features its own cyclictest utility which is heavily inspired by the original program but does not use some advanced features, while adding features that are NuttX related.</p><p>The creation of the new cyclictest arose from the fact that as of February 2025, POSIX time functions (such as <code>clock_gettime</code> and <code>clock_nanosleep</code>) depend on the systemtick (if the system is not compiled in the Tickless mode) which makes small delays practically impossible. However, if we utilize a hardware device timer, small periodic delays can be achieved with some <code>ioctl</code> calls.</p><p>The documentation needs to be revisited to see how cyclictest performs when NuttX is compiled in tickless mode.</p><h2 id="replacement-for-clock-gettime-and-clock-nanosleep-in-nuttx" tabindex="-1">Replacement for <code>clock_gettime</code> and <code>clock_nanosleep</code> in NuttX <a class="header-anchor" href="#replacement-for-clock-gettime-and-clock-nanosleep-in-nuttx" aria-label="Permalink to &quot;Replacement for \`clock_gettime\` and \`clock_nanosleep\` in NuttX&quot;">​</a></h2><p>Configuring such device timer is simple: firstly, the timer&#39;s timeout is set using the <code>TCIOC_SETTIMEOUT</code> <code>ioctl</code> call. Then the <code>TCIOC_NOTIFICATION</code> <code>ioctl</code> call is performed. Afterwards, the timer can be polled using the <code>poll</code> function which returns when the timer timeouts.</p><p>The thread latency wakeup can be measured using this timer by calling <code>TCIOC_GETSTATUS</code> <code>ioctl</code> call after the <code>poll</code> function has returned. The <code>ioctl</code> call fills the <code>timer_status_s</code> struct which contains two important fields: <code>uint32_t timeleft</code> and <code>uint32_t timeout</code>. The latency of the thread can then be calculated as <code>timeout - timeleft</code>.</p><h2 id="usage-of-this-program" tabindex="-1">Usage of this program <a class="header-anchor" href="#usage-of-this-program" aria-label="Permalink to &quot;Usage of this program&quot;">​</a></h2><p>Despite some differences, the NuttX port stays as faithful as possible to the original program, keeping the most important command-line parameters the same. The user can choose one of two &quot;waiting methods&quot;:</p><ul><li><code>clock_nanosleep</code> (<code>W_NANOSLEEP</code>),</li><li>polling the device (<code>W_DEVTIMER</code>).</li></ul><p>The user can also choose one of two &quot;measuring methods&quot;:</p><ul><li><code>clock_gettime</code> (<code>M_GETTIME</code>),</li><li>utilizing the device timer (<code>M_TIMER_API</code>).</li></ul><p>It is possible to combine the waiting and measuring methods. As of February 2025, using <code>W_DEVTIMER</code> and <code>M_TIMER_API</code> produces the best results. However, it requires a timer device to be registered by your BSP (such as <code>/dev/timer1</code>). Be also advised that when <code>W_DEVTIMER</code> is used, only one thread can poll the timer.</p><p>Following command-line parameters can be supplied:</p><ul><li><code>-c --clock [CLOCK]</code>: 0 selects <code>CLOCK_REALTIME</code>, 1 selects <code>CLOCK_MONOTONIC</code> (default)</li><li><code>-d --distance [US]</code>: The distance of thread intervals. Default is 500 us.</li><li><code>-D --duration [TIME]</code>: Set the test duration in seconds. Default is 0 (endless).</li><li><code>-e --help</code>: Displays help and exits.</li><li><code>-h --histogram [US]</code>: Output the histogram data to stdout. US is the maximum value to be printed.</li><li><code>-H --histofall</code>: Same as <code>-h</code> except that an additional histogram column is displayed at the right that contains summary data of all thread histograms. If cyclictest runs a single thread only, the <code>-H</code> option is equivalent to <code>-h</code>.</li><li><code>-i --interval [US]</code>: The thread interval. Default is 1000 us.</li><li><code>-l --loops [N]</code>: The number of measurement loops. Default is 0 (endless).</li><li><code>-m --measurement [METHODS]</code>: Sets the time measurement method. 0 selects <code>clock_gettime</code>, 1 uses the NuttX timer API. Be advised that if 1 is selected, you need to specify a timer device (e.g. <code>/dev/timer0</code>) in <code>-T</code>.</li><li><code>-n --nanosleep [METHOD]</code>: Sets the waiting method: 0 selects <code>clock_nanosleep</code>, 1 waits for the POLLIN flag on a timer device. Default is 0. Choosing 1 works only with one thread, the <code>-t</code> value is therefore set to 1. If METHOD 1 is selected, you need to specify a timer device (e.g. <code>/dev/timer0</code>) in <code>-T</code>.</li><li><code>-q --quiet</code>: Prints a summary only on exit.</li><li><code>-p --prio</code>: Sets the priority of the first thread.</li><li><code>-t --threads [N]</code>: The number of test threads to be created. Default is 1.</li><li><code>-T --timer-device [DEV]</code>: The measuring timer device. Must be specified when <code>-m=1</code> or <code>-n=1</code>.</li><li><code>-y --policy [NAME]</code>: Set the scheduler policy, where NAME is fifo, rr, batch, idle, normal, other.</li></ul><h2 id="example-usage" tabindex="-1">Example usage <a class="header-anchor" href="#example-usage" aria-label="Permalink to &quot;Example usage&quot;">​</a></h2><p><code>cyclictest -p 150 -T /dev/timer1 -m 1 -n 1 -h 20 -D 100 -i 50</code></p><p>Since <code>W_DEVTIMER</code> is used, only one thread runs every 50 us. The measurement method is the device timer itself, specified in <code>-T</code>. The test runs for 100 seconds. The priority is boosted to 150, so the measurement is not affected by other tasks or communication.</p><p>Output of the command (tested on Microchip ATSAMV71Q21B @ 300 MHz):</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># Histogram</span></span>
<span class="line"><span>000000 000000</span></span>
<span class="line"><span>000001 000000</span></span>
<span class="line"><span>000002 000000</span></span>
<span class="line"><span>000003 000000</span></span>
<span class="line"><span>000004 000000</span></span>
<span class="line"><span>000005 000000</span></span>
<span class="line"><span>000006 000000</span></span>
<span class="line"><span>000007 000000</span></span>
<span class="line"><span>000008 000000</span></span>
<span class="line"><span>000009 000000</span></span>
<span class="line"><span>000010 603045</span></span>
<span class="line"><span>000011 1395782</span></span>
<span class="line"><span>000012 000804</span></span>
<span class="line"><span>000013 000153</span></span>
<span class="line"><span>000014 000034</span></span>
<span class="line"><span>000015 000083</span></span>
<span class="line"><span>000016 000030</span></span>
<span class="line"><span>000017 000000</span></span>
<span class="line"><span>000018 000000</span></span>
<span class="line"><span>000019 000000</span></span>
<span class="line"><span># Total: 001999931</span></span>
<span class="line"><span># Min Latencies: 00010</span></span>
<span class="line"><span># Avg Latencies: 00010</span></span>
<span class="line"><span># Max Latencies: 00016</span></span>
<span class="line"><span># Histogram Overflows: 00000</span></span></code></pre></div>`,20)]))}const u=s(n,[["render",o]]);export{m as __pageData,u as default};
