import{_ as a,c as t,al as s,o as n}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Smaller Vector Tables","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/smaller_vector_tables.md","filePath":"en/guides/smaller_vector_tables.md"}'),i={name:"en/guides/smaller_vector_tables.md"};function o(r,e,p,c,l,d){return n(),t("div",null,e[0]||(e[0]=[s(`<h1 id="smaller-vector-tables" tabindex="-1">Smaller Vector Tables <a class="header-anchor" href="#smaller-vector-tables" aria-label="Permalink to &quot;Smaller Vector Tables&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Smaller+Vector+Tables" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Smaller+Vector+Tables</a></p><p>One of the largest OS data structures is the vector table, <code>g_irqvector[]</code>. This is the table that holds the vector information when <code>irq_attach()</code> is called and used to dispatch interrupts by <code>irq_dispatch()</code>. Recent changes have made that table even larger, for 32-bit arm the size of that table is given by:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nbytes = number_of_interrupts * (2 * sizeof(void *))</span></span></code></pre></div><p>We will focus on the STM32 for this discussion to keep things simple. However, this discussion applies to all architectures.</p><p>The number of (physical) interrupt vectors supported by the MCU hardwared given by the definition <code>NR_IRQ</code> which is provided in a header file in <code>arch/arm/include/stm32</code>. This is, by default, the value of <code>number_of_interrupts</code> in the above equation.</p><p>For a 32-bit ARM like the STM32 with, say, 100 interrupt vectors, this size would be 800 bytes of memory. That is not a lot for high-end MCUs with a lot of RAM memory, but could be a show stopper for MCUs with minimal RAM.</p><p>Two approaches for reducing the size of the vector tables are described below. Both depend on the fact that not all interrupts are used on a given MCU. Most of the time, the majority of entries in <code>g_irqvector[]</code> are zero because only a small number of interrupts are actually attached and enabled by the application. If you know that certain IRQ numbers are not going to be used, then it is possible to filter those out and reduce the size to the number of supported interrupts.</p><p>For example, if the actual number of interrupts used were 20, the the above requirement would go from 800 bytes to 160 bytes.</p><h2 id="software-irq-remapping" tabindex="-1">Software IRQ Remapping <a class="header-anchor" href="#software-irq-remapping" aria-label="Permalink to &quot;Software IRQ Remapping&quot;">​</a></h2><p class="title-ref">[[On March 3, 2017, support for this &quot;Software IRQ Remapping&quot; as included in the NuttX repository.]]</p><p>One of the simplest way of reducing the size of <code>g_irqvector[]</code> would be to remap the large set of physical interrupt vectors into a much small set of interrupts that are actually used. For the sake of discussion, let&#39;s imagine two new configuration settings:</p><ul><li><code>CONFIG_ARCH_MINIMAL_VECTORTABLE</code>: Enables IRQ mapping</li><li><code>CONFIG_ARCH_NUSER_INTERRUPTS</code>: The number of IRQs after mapping.</li></ul><p>Then it could allocate the interrupt vector table to be size <code>CONFIG_IRQ_NMAPPED_IRQ</code> instead of the much bigger <code>NR_IRQS</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_ARCH_MINIMAL_VECTORTABLE</span></span>
<span class="line"><span>struct irq_info_s g_irqvector[CONFIG_ARCH_NUSER_INTERRUPTS];</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>struct irq_info_s g_irqvector[NR_IRQS];</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><p>The <code>g_irqvector[]</code> table is accessed in only three places:</p><h3 id="irq-attach" tabindex="-1"><code>irq_attach()</code> <a class="header-anchor" href="#irq-attach" aria-label="Permalink to &quot;\`irq_attach()\`&quot;">​</a></h3><p><code>irq_attach()</code> receives the physical vector number along with the information needed later to dispatch interrupts:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int irq_attach(int irq, xcpt_t isr, FAR void *arg);</span></span></code></pre></div><p>Logic in <code>irq_attach()</code> would map the incoming physical vector number to a table index like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_ARCH_MINIMAL_VECTORTABLE</span></span>
<span class="line"><span>int ndx = g_irqmap[irq];</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>int ndx = irq;</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><p>where <code>up_mapirq[]</code> is an array indexed by the physical interrupt vector number and contains the new, mapped interrupt vector table index. This array must be provided by platform-specific code.</p><p><code>irq_attach()</code> would this use this index to set the <code>g_irqvector[]</code>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>g_irqvector[ndx].handler = isr;</span></span>
<span class="line"><span>g_irqvector[ndx].arg     = arg;</span></span></code></pre></div><h3 id="irq-dispatch" tabindex="-1"><code>irq_dispatch()</code> <a class="header-anchor" href="#irq-dispatch" aria-label="Permalink to &quot;\`irq_dispatch()\`&quot;">​</a></h3><p><code>irq_dispatch()</code> is called by MCU logic when an interrupt is received:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void irq_dispatch(int irq, FAR void *context);</span></span></code></pre></div><p>Where, again irq is the physical interrupt vector number.</p><p><code>irq_dispatch()</code> would do essentially the same thing as <code>irq_attach()</code>. First it would map the irq number to a table index:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_ARCH_MINIMAL_VECTORTABLE</span></span>
<span class="line"><span>int ndx = g_irqmap[irq];</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>int ndx = irq;</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><p>Then dispatch the interrupt handling to the attached interrupt handler. NOTE that the physical vector number is passed to the handler so it is completely unaware of the underlying [shell]{.title-ref} game:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>vector = g_irqvector[ndx].handler;</span></span>
<span class="line"><span>arg    = g_irqvector[ndx].arg;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>vector(irq, context, arg);</span></span></code></pre></div><h3 id="irq-initialize" tabindex="-1"><code>irq_initialize()</code> <a class="header-anchor" href="#irq-initialize" aria-label="Permalink to &quot;\`irq_initialize()\`&quot;">​</a></h3><p><code>irq_initialize()</code>: simply set the <code>g_irqvector[]</code> table a known state on power-up. It would only have to distinguish the difference in sizes.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_ARCH_MINIMAL_VECTORTABLE</span></span>
<span class="line"><span>#  define TAB_SIZE CONFIG_ARCH_NUSER_INTERRUPTS</span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span>#  define TAB_SIZE NR_IRQS</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for (i = 0; i &lt; TAB_SIZE; i++)</span></span></code></pre></div><h3 id="g-mapirq" tabindex="-1"><code>g_mapirq[]</code> <a class="header-anchor" href="#g-mapirq" aria-label="Permalink to &quot;\`g_mapirq[]\`&quot;">​</a></h3><p>An implementation of <code>up_mapirq()</code> might be something like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;nuttx/irq.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const irq_mapped_t g_irqmap[NR_IRQS] =</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>... IRQ to index mapping values ...</span></span>
<span class="line"><span>};</span></span></code></pre></div><p><code>g_irqmap[]</code> is a array of mapped irq table indices. It contains the mapped index value and is itself indexed by the physical interrupt vector number. It provides an <code>irq_mapped_t</code> value in the range of 0 to <code>CONFIG_ARCH_NUSER_INTERRUPTS</code> that is the new, mapped index into the vector table. Unsupported IRQs would simply map to an out of range value like <code>IRQMAPPED_MAX</code>. So, for example, if <code>g_irqmap[37] == 24</code>, then the hardware interrupt vector 37 will be mapped to the interrupt vector table at index 24. if <code>g_irqmap[42] == IRQMAPPED_MAX</code>, then hardware interrupt vector 42 is not used and if it occurs will result in an unexpected interrupt crash.</p><h2 id="hardware-vector-remapping" tabindex="-1">Hardware Vector Remapping <a class="header-anchor" href="#hardware-vector-remapping" aria-label="Permalink to &quot;Hardware Vector Remapping&quot;">​</a></h2><p class="title-ref">[[This technical approach is discussed here but is discouraged because of technical &quot;Complications&quot; and &quot;Dubious Performance Improvements&quot; discussed at the end of this section.]]</p><p>Most ARMv7-M architectures support two mechanism for handling interrupts:</p><ul><li>The so-called [common]{.title-ref} vector handler logic enabled with <code>CONFIG_ARMV7M_CMNVECTOR=y</code> that can be found in <code>arch/arm/src/armv7-m/</code>, and</li><li>MCU-specific interrupt handling logic. For the STM32, this logic can be found at <code>arch/arm/src/stm32/gnu/stm32_vectors.S</code>.</li></ul><p>The [common]{.title-ref} vector logic is slightly more efficient, the MCU-specific logic is slightly more flexible.</p><p>If we don&#39;t use the [common]{.title-ref} vector logic enabled with <code>CONFIG_ARMV7M_CMNVECTOR=y</code>, but instead the more flexible MCU-specific implementation, then we can also use this to map the large set of hardware interrupt vector numbers to a smaller set of software interrupt numbers. This involves minimal changes to the OS and does not require any magic software lookup table. But is considerably more complex to implement.</p><p>This technical approach requires changes to three files:</p><ul><li>A new header file at <code>arch/arm/include/stm32</code>, say <code>xyz_irq.h</code> for the purposes of this discussion. This new header file is like the other IRQ definition header files in that directory except that it defines only the IRQ number of the interrupts after remapping. So, instead of having the 100 IRQ number definitions of the original IRQ header file based on the physical vector numbers, this header file would define <code>only</code> the small set of 20 <code>mapped</code> IRQ numbers in the range from 0 through 19. It would also set <code>NR_IRQS</code> to the value 20.</li><li>A new header file at <code>arch/arm/src/stm32/hardware</code>, say <code>xyz_vector.h</code>. It would be similar to the other vector definitions files in that directory: It will consist of a sequence of 100 <code>VECTOR</code> and <code>UNUSED</code> macros. It will define <code>VECTOR</code> entries for the 20 valid interrupts and 80 <code>UNUSED</code> entries for the unused interrupt vector numbers. More about this below.</li><li>Modification of the <code>stm32_vectors.S</code> file. These changes are trivial and involve only the conditional inclusion of the new, special <code>xyz_vectors.h</code> header file.</li></ul><p><strong>REVISIT</strong>: This needs to be updated. Neither the <code>xyz_vector.h</code> files nor the <code>stm32_vectors.S</code> exist in the current realization. This has all been replaced with the common vector handling at <code>arch/arm/src/armv7-m</code>.</p><h2 id="vector-definitions" tabindex="-1">Vector Definitions <a class="header-anchor" href="#vector-definitions" aria-label="Permalink to &quot;Vector Definitions&quot;">​</a></h2><p>In <code>arch/arm/src/stm32/gnu/stm32_vector.S</code>, notice that the <code>xyz_vector.h</code> file will be included twice. Before each inclusion, the macros <code>VECTOR</code> and <code>UNUSED</code> are defined.</p><p>The first time that <code>xyz_vector.h</code> included, it defines the hardware vector table. The hardware vector table consists of <code>NR_IRQS</code> 32-bit addresses in an array. This is accomplished by setting:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#undef VECTOR</span></span>
<span class="line"><span>#define VECTOR(l,i) .word l</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#undef UNUSED</span></span>
<span class="line"><span>#define UNUSED(i)   .word stm32_reserved</span></span></code></pre></div><p>Then including <code>xyz_vector.h</code>. So consider the following definitions in the original file:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>
<span class="line"><span>VECTOR(stm32_usart1, STM32_IRQ_USART1) /* Vector 16+37: USART1 global interrupt */</span></span>
<span class="line"><span>VECTOR(stm32_usart2, STM32_IRQ_USART2) /* Vector 16+38: USART2 global interrupt */</span></span>
<span class="line"><span>VECTOR(stm32_usart3, STM32_IRQ_USART3) /* Vector 16+39: USART3 global interrupt */</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>Suppose that we wanted to support only USART1 and that we wanted to have the IRQ number for USART1 to be 12. That would be accomplished in the <code>xyz_vector.h</code> header file like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>
<span class="line"><span>VECTOR(stm32_usart1, STM32_IRQ_USART1) /* Vector 16+37: USART1 global interrupt */</span></span>
<span class="line"><span>UNUSED(0)                              /* Vector 16+38: USART2 global interrupt */</span></span>
<span class="line"><span>UNUSED(0)                              /* Vector 16+39: USART3 global interrupt */</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>Where the value of <code>STM32_IRQ_USART1</code> was defined to be 12 in the <code>arch/arm/include/stm32/xyz_irq.h</code> header file. When <code>xyz_vector.h</code> is included by <code>stm32_vectors.S</code> with the above definitions for <code>VECTOR</code> and <code>UNUSED</code>, the following would result:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>
<span class="line"><span>.word stm32_usart1</span></span>
<span class="line"><span>.word stm32_reserved</span></span>
<span class="line"><span>.word stm32_reserved</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>These are the settings for vector 53, 54, and 55, respectively. The entire vector table would be populated in this way. <code>stm32_reserved</code>, if called would result in an &quot;unexpected ISR&quot; crash. <code>stm32_usart1</code>, if called will process the USART1 interrupt normally as we will see below.</p><h3 id="interrupt-handler-definitions" tabindex="-1">Interrupt Handler Definitions <a class="header-anchor" href="#interrupt-handler-definitions" aria-label="Permalink to &quot;Interrupt Handler Definitions&quot;">​</a></h3><p>in the vector table, all of the valid vectors are set to the address of a [handler]{.title-ref} function. All unused vectors are force to vector to <code>stm32_reserved</code>. Currently, only vectors that are not supported by the hardware are marked <code>UNUSED</code>, but you can mark any vector <code>UNUSED</code> in order to eliminate it.</p><p>The second time that <code>xyz_vector.h</code> is included by <code>stm32_vector.S</code>, the [handler]{.title-ref} functions are generated. Each of the valid vectors point to the matching handler function. In this case, you do NOT have to provide handlers for the <code>UNUSED</code> vectors, only for the used <code>VECTOR</code> vectors. All of the unused vectors will go to the common <code>stm32_reserved</code> handler. The remaining set of handlers is very sparse.</p><p>These are the values of <code>UNUSED</code> and <code>VECTOR</code> macros on the second time the <code>xzy_vector.h</code> is included by <code>stm32_vectors.S</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.macro HANDLER, label, irqno</span></span>
<span class="line"><span>    .thumb_func</span></span>
<span class="line"><span>label:</span></span>
<span class="line"><span>    mov r0, #\\irqno</span></span>
<span class="line"><span>    b       exception_common</span></span>
<span class="line"><span>.endm</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#undef VECTOR</span></span>
<span class="line"><span>#define VECTOR(l,i) HANDLER l, i</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#undef UNUSED</span></span>
<span class="line"><span>#define UNUSED(i)</span></span></code></pre></div><p>In the above USART1 example, a single handler would be generated that will provide the IRQ number 12. Remember that 12 is the expansion of the macro <code>STM32_IRQ_USART1</code> that is provided in the <code>arch/arm/include/stm32/xyz_irq.h</code> header file:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.thumb_func</span></span>
<span class="line"><span>stm32_usart1:</span></span>
<span class="line"><span>mov r0, #12</span></span>
<span class="line"><span>b       exception_common</span></span></code></pre></div><p>Now, when vector 16+37 occurs it is mapped to IRQ 12 with no significant software overhead.</p><h3 id="a-complication" tabindex="-1">A Complication <a class="header-anchor" href="#a-complication" aria-label="Permalink to &quot;A Complication&quot;">​</a></h3><p>A complication in the above logic has been noted by David Sidrane: When we access the NVIC in <code>stm32_irq.c</code> in order to enable and disable interrupts, the logic requires the physical vector number in order to select the NVIC register and the bit(s) the modify in the NVIC register.</p><p>This could be handled with another small IRQ lookup table (20 <code>uint8_t</code> entries in our example situation above). But then this approach is not so much better than the [Software Vector Mapping]{.title-ref} described about which does not suffer from this problem. Certainly enabling/disabling interrupts in a much lower rate operation and at least does not put the lookup in the critical interrupt path.</p><p>Another option suggested by David Sidrane is equally ugly:</p><ul><li>Don&#39;t change the <code>arch/arm/include/stm32</code> IRQ definition file.</li><li>Instead, encode the IRQ number so that it has both the index and physical vector number:</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>
<span class="line"><span>VECTOR(stm32_usart1, STM32_IRQ_USART1 &lt;&lt; 8 | STM32_INDEX_USART1)</span></span>
<span class="line"><span>UNUSED(0)</span></span>
<span class="line"><span>UNUSED(0)</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>The STM32_INDEX_USART1 would have the value 12 and STM32_IRQ_USART1 would be as before (53). This encoded value would be received by <code>irq_dispatch()</code> and it would decode both the index and the physical vector number. It would use the index to look up in the <code>g_irqvector[]</code> table but would pass the physical vector number to the interrupt handler as the IRQ number.</p><p>A lookup would still be required in <code>irq_attach()</code> in order to convert the physical vector number back to an index (100 <code>uint8_t</code> entries in our example). So some lookup is unavoidable.</p><p>Based upon these analysis, my recommendation is that we do not consider the second option any further. The first option is cleaner, more portable, and generally preferable.is well worth that.</p><h3 id="dubious-performance-improvements" tabindex="-1">Dubious Performance Improvements <a class="header-anchor" href="#dubious-performance-improvements" aria-label="Permalink to &quot;Dubious Performance Improvements&quot;">​</a></h3><p>The intent of this second option was to provide a higher performance mapping of physical interrupt vectors to IRQ numbers compared to the pure software mapping of option 1. However, in order to implement this approach, we had to use the less efficient, non-common vector handling logic. That logic is not terribly less efficient, the cost is probably only a 16 bit load immediate instruction and branch to another location in FLASH (which will cause the CPU pipeline to be flushed).</p><p>The variant of option 2 where both the physical vector number and vector table index are encoded would require even more processing in <code>irq_dispatch()</code> in order to decode the physical vector number and vector table index. Possible just AND and SHIFT instructions.</p><p>However, the minimal cost of the first pure software mapping approach was possibly as small as a single indexed byte fetch from FLASH in <code>irq_attach()</code>. Indexing is, of course, essentially [free]{.title-ref} in the ARM ISA, the primary cost would be the FLASH memory access. So my first assessment is that the performance of both approaches is the essentially the same. If anything, the first approach is possibly the more performant if implemented efficiently.</p><p>Both options would require some minor range checking in <code>irq_attach()</code> as well.</p><p>Because of this and because of the simplicity of the first option, I see no reason to support or consider this second option any further.</p><h3 id="complexity-and-generalizability" tabindex="-1">Complexity and Generalizability <a class="header-anchor" href="#complexity-and-generalizability" aria-label="Permalink to &quot;Complexity and Generalizability&quot;">​</a></h3><p>Option 2 is overly complex; it depends on a deep understanding on how the MCU interrupt logic works and on a high level of Thumb assembly language skills.</p><p>Another problem with option 2 is that really only applies to the Cortex-M family of processors and perhaps others that support interrupt vectored interrupts in a similar fashion. It is not a general solution that can be used with any CPU architectures.</p><p>And even worse, the MCU-specific interrupt handling logic that this support depends upon is is very limited. As soon as the common interrupt handler logic was added, I stopped implementing the MCU specific logic in all newer ARMv7-M ports. So that MCU specific interrupt handler logic is only present for EFM32, Kinetis, LPC17, SAM3/4, STM32, Tiva, and nothing else. Very limited!</p><p>These are further reasons why option 2 is no recommended and will not be supported explicitly.</p>`,88)]))}const m=a(i,[["render",o]]);export{u as __pageData,m as default};
