import{_ as a,c as t,al as n,o as s}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"ARMv7-M Run Time Stack Checking","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/armv7m_runtimestackcheck.md","filePath":"en/guides/armv7m_runtimestackcheck.md"}'),i={name:"en/guides/armv7m_runtimestackcheck.md"};function o(c,e,p,l,r,h){return s(),t("div",null,e[0]||(e[0]=[n(`<h1 id="armv7-m-run-time-stack-checking" tabindex="-1">ARMv7-M Run Time Stack Checking <a class="header-anchor" href="#armv7-m-run-time-stack-checking" aria-label="Permalink to &quot;ARMv7-M Run Time Stack Checking&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/ARMv7-M+Run+Time+Stack+Checking" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/ARMv7-M+Run+Time+Stack+Checking</a></p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>Nuttx supports facilities to verify the dynamically allocated stacks and fixed stacks used by the tasks and interrupt context running under Nuttx. There are 2 types of stack checking that can be used together or separately.</p><ol><li>The Stack Monitor</li><li>Per function Call (ARMV7 Only)</li></ol><h3 id="the-stack-monitor" tabindex="-1">The Stack Monitor <a class="header-anchor" href="#the-stack-monitor" aria-label="Permalink to &quot;The Stack Monitor&quot;">​</a></h3><p>The use of the Stack Monitor application requires that <code>CONFIG_STACK_COLORATION</code> be enabled. This compile time option enables the writing of a know pattern <code>STACK_COLOR</code> to the stack memory at creation time. In the case of the idle task and interrupt, this is done in the code that runs just after reset at startup. This is known as stack coloring.</p><p>Once the pattern has been established, the functions <code>up_check_stack</code> and friends are used to perform the stack checking by finding the lowest word of the pattern in the allocated stack.</p><p>The Stack Monitor is enabled with <code>CONFIG_SYSTEM_STACKMONITOR</code> which will enable a daemon that will periodically run and check the stack penetration of the tasks running on the system.</p><p>The stack monitor is good to help size and check the usage of tasks. However it is not really useful to detect, certain kinds, nor the cause of a stack overrun.</p><p>The reason for this is because a corrupted stack may not be eaten away at. It may have overruns where the stack pointer is set way below the stack bottom in a function call as it allocates local variables on the stack. The code in the function call can then corrupt the memory below the stack bottom, restores the stack pointer and returns to the caller without actually overwriting the coloring at the base of the stack.</p><p>This brings us the the next method of stack checking.</p><h3 id="per-function-call" tabindex="-1">Per function Call <a class="header-anchor" href="#per-function-call" aria-label="Permalink to &quot;Per function Call&quot;">​</a></h3><p>This method of stack checking leverages the profiler hook mechanism supported by the compiler. Once enabled using <code>CONFIG_ARMV7M_STACKCHECK</code>, one register is set aside (<code>R10</code> is the default) and the value of the base of stack is saved there (<code>rBS</code>). Then every function call will have a preamble and a postamble code added to it. The preamble (<code>__cyg_profile_func_enter</code>) checks the current stack pointer, minus a margin of 64 bytes (with an additional 136 bytes for the <code>FP</code> registers) against the value in the reserved register <code>rBS</code>. If the computed value lies below the value in <code>rBS</code> a hard fault is generated. The postamble code (<code>__cyg_profile_func_exit</code>) just returns to the caller.</p><p>The rationale for subtracting the margin can be viewed two ways. If the configuration is not using a separate ISR stack, then the space reserved will accommodate the context save of the CPU and optionally the FPU registers to service an interrupt on the users stack. If the configuration is using a separate ISR stack, some the 64 bytes will accommodate the transition to the interrupt stack and the remaining 60-200 bytes are just margin. Either way stacks should always be allocated with at least 200 bytes of margin.</p><p>Because of the reserved register rBS contains the current context&#39;s stack base, and rBS is not updated on the entry to an ISR, it is not possible to check the stack penetration for an interrupt with Per function Call stack checking.</p><p>One thing to consider is the impact on code size and speed this method of stack checking will have. Each function will have two additional call and return instructions added to it. In the execution path of each function, there will be an added set of instructions to perform the preamble and postamble functionality. In a call tree that is nested several layers deep, this can add up. In one particular use, we saw an increase of 30% to 35% additional CPU utilization required to support per function call stack checking.</p><p>Is this just a debugging tool? One could imagine that in a mission critical application, this might be part of a release build if the code size and speed impact can be tolerated.</p><p>As of commit 4942867 Register R11 will contain the value that the stack pointer would hit that caused the fault. This can be used to calculate the stack size needed for that task that faulted. To do so, take the difference of R10-R11 and round it up by 12 bytes (The round up is to make up for the 8 byte stack alignment and 4 byte decrease that may happen in the stack allocation) Then add that amount to the failing tasks stack size.</p><h3 id="details-for-support-of-per-call-stack-checking" tabindex="-1">Details for Support of Per Call Stack Checking <a class="header-anchor" href="#details-for-support-of-per-call-stack-checking" aria-label="Permalink to &quot;Details for Support of Per Call Stack Checking&quot;">​</a></h3><p>Currently only ARMV7 derivatives support Per Call Stack Checking. Support requires the following components:</p><p>The start function must establish the value in <code>rBS</code> (<code>R10</code> by default see below). Yet to do this the start function must NOT have the preamble and postamble code added to it. This is accomplished with the use the following gcc attribute:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_ARMV7M_STACKCHECK</span></span>
<span class="line"><span>/* we need to get r10 set before we can allow instrumentation calls */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void __start(void) __attribute__ ((no_instrument_function));</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><p>...</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void __start(void)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  const uint32_t *src;</span></span>
<span class="line"><span>  uint32_t *dest;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef CONFIG_ARMV7M_STACKCHECK</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Set the stack limit before we attempt to call any functions */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  __asm__ volatile (&quot;sub r10, sp, %0&quot; : : &quot;r&quot; (CONFIG_IDLETHREAD_STACKSIZE -64) : );</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><p>The minus 64 is setting the limit 64 bytes above the bottom of the stack. Note: This may be adding another 64 bytes of margin</p><p>For the creation of a task&#39;s context the following code is needed to set up <code>rBS</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void up_initial_state(struct tcb_s *tcb)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  struct xcptcontext *xcp = &amp;tcb-&gt;xcp;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Initialize the initial exception register context structure */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  memset(xcp, 0, sizeof(struct xcptcontext));</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Save the initial stack pointer */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  xcp-&gt;regs[REG_SP]      = (uint32_t)tcb-&gt;adj_stack_ptr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef CONFIG_ARMV7M_STACKCHECK</span></span>
<span class="line"><span>  /* Set the stack limit value */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  xcp-&gt;regs[REG_R10]     = (uint32_t)tcb-&gt;stack_alloc_ptr + 64;</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><p>And finally up_stackcheck.c needs to be included in the build and the compiler flags set to reserve <code>R10</code> and enable the instrumentation.</p><p>This is done for a given architecture in nuttx/arch/arm/src/&lt;arch&gt;/Make.defs:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ifeq ((CONFIG_ARMV7M_STACKCHECK),y)</span></span>
<span class="line"><span>CMN_CSRCS += up_stackcheck.c</span></span>
<span class="line"><span>endif</span></span></code></pre></div><p>The compiler flags are added in the nuttx/arch/arm/src/armv7-m/Toolchain.defs</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># enable precise stack overflow tracking</span></span>
<span class="line"><span>ifeq ((CONFIG_ARMV7M_STACKCHECK),y)</span></span>
<span class="line"><span>INSTRUMENTATIONDEFINES   = -finstrument-functions -ffixed-r10</span></span>
<span class="line"><span>endif</span></span></code></pre></div><h3 id="other-considerations" tabindex="-1">Other Considerations <a class="header-anchor" href="#other-considerations" aria-label="Permalink to &quot;Other Considerations&quot;">​</a></h3><p>If using the export build feature of Nuttx: For the runtime stack checking both the Application and Nuttx need to be built with the <code>CONFIG_ARMV7M_STACKCHECK</code> option set the same state, enabled or disabled. Any mismatch will created either compile time or runtime issues.</p>`,36)]))}const k=a(i,[["render",o]]);export{u as __pageData,k as default};
