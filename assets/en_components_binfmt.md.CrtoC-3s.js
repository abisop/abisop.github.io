import{_ as o,c as n,al as t,j as e,a,o as i}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"Binary Loader","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/binfmt.md","filePath":"en/components/binfmt.md"}'),l={name:"en/components/binfmt.md"};function s(d,r,h,c,b,m){return i(),n("div",null,r[0]||(r[0]=[t('<h1 id="binary-loader" tabindex="-1">Binary Loader <a class="header-anchor" href="#binary-loader" aria-label="Permalink to &quot;Binary Loader&quot;">​</a></h1><p>The purpose of a <em>binary loader</em> is to load and execute modules in various <em>binary formats</em> that reside in a file system. Loading refers instantiating the binary module in some fashion, usually copy all or some of the binary module into memory and then linking the module with other components. In most architectures, it is the base FLASH code that is the primary component that the binary module must link with because that is where the RTOS and primary tasks reside. Program modules can then be executed after they have been loaded.</p><p><strong>Binary Formats</strong>. The binary loader provides generic support for different binary formats. It supports a <em>registration interface</em> that allows the number of support binary formats to be loaded at run time. Each binary format provides a common, interface for use by the binary loader. When asked to load a binary, the binary loader will query each registered binary format, providing it with the path of the binary object to be loaded. The binary loader will stop when first binary format the recognizes the binary object and successfully loads it or when all registered binary formats have attempt loading the binary object and failed.</p><p>At present, the following binary formats are support by NuttX:</p>',4),e("blockquote",null,[e("ul",null,[e("li",null,[e("strong",null,"ELF"),a(". Standard ELF formatted files.")]),e("li",null,[e("strong",null,"NXFLAT"),a(". NuttX NXFLAT formatted files. More information about the NXFLAT binary format can be found in the "),e("code",{class:"interpreted-text",role:"ref"},"NXFLAT documentation <nxflat>"),a(".")])])],-1),t('<p><strong>Executables and Libraries</strong> The generic binary loader logic does not care what it is that it being loaded. It could load an executable program or a library. There are no strict rules, but a library will tend to export symbols and a program will tend to import symbols: The program will use the symbols exported by the library. However, at this point in time, none of the supported binary formats support exporting of symbols.</p><p><strong>binfmt</strong>. In the NuttX source code, the short name <code>binfmt</code> is used to refer to the NuttX binary loader. This is the name of the directory containing the binary loader and the name of the header files and variables used by the binary loader.</p><p>The name <code>binfmt</code> is the same name used by the Linux binary loader. However, the NuttX binary loader is an independent development and shares nothing with the Linux binary loader other the same name and the same basic functionality.</p><h2 id="binary-loader-interface" tabindex="-1">Binary Loader Interface <a class="header-anchor" href="#binary-loader-interface" aria-label="Permalink to &quot;Binary Loader Interface&quot;">​</a></h2><h3 id="header-files" tabindex="-1">Header Files <a class="header-anchor" href="#header-files" aria-label="Permalink to &quot;Header Files&quot;">​</a></h3><p>The interface to the binary loader is described in the header file <code>include/nuttx/binfmt/binfmt.h</code>. A brief summary of the data structures and interfaces prototyped in that header file are listed below.</p><h3 id="data-structures" tabindex="-1">Data Structures <a class="header-anchor" href="#data-structures" aria-label="Permalink to &quot;Data Structures&quot;">​</a></h3><p>When a binary format registers with the binary loader, it provides a pointer to a write-able instance of :c<code>binfmt_s</code>{.interpreted-text role=&quot;struct&quot;}.</p><h3 id="function-interfaces" tabindex="-1">Function Interfaces <a class="header-anchor" href="#function-interfaces" aria-label="Permalink to &quot;Function Interfaces&quot;">​</a></h3><h4 id="binary-format-management" tabindex="-1">Binary format management <a class="header-anchor" href="#binary-format-management" aria-label="Permalink to &quot;Binary format management&quot;">​</a></h4><h4 id="basic-module-management" tabindex="-1">Basic module management <a class="header-anchor" href="#basic-module-management" aria-label="Permalink to &quot;Basic module management&quot;">​</a></h4><p>Tip</p>',12),e("p",null,[a("The function :c"),e("code",{class:"interpreted-text",role:"func"},"exec"),a(" is a convenience function that wraps :c"),e("code",{class:"interpreted-text",role:"func"},"load_module"),a(" and :c"),e("code",{class:"interpreted-text",role:"func"},"exec_module"),a(" into one call.")],-1),e("h4",{id:"path-traversal-logic",tabindex:"-1"},[e("code",null,"PATH"),a(" traversal logic "),e("a",{class:"header-anchor",href:"#path-traversal-logic","aria-label":'Permalink to "`PATH` traversal logic"'},"​")],-1),e("p",null,[a("Release all resources set aside by envpath_init when the handle value was created. The handle value is invalid on return from this function. Attempts to all :c"),e("code",{class:"interpreted-text",role:"func"},"envpath_next"),a(" or :c"),e("code",{class:"interpreted-text",role:"func"},"envpath_release"),a(" with such a stale handle will result in undefined (i.e., not good) behavior.")],-1),t('<blockquote><p>param handle</p><p>: The handle value returned by :c<code>envpath_init</code>{.interpreted-text role=&quot;func&quot;}.</p></blockquote><h2 id="symbol-tables" tabindex="-1">Symbol Tables <a class="header-anchor" href="#symbol-tables" aria-label="Permalink to &quot;Symbol Tables&quot;">​</a></h2><p><strong>Symbol Tables</strong>. Symbol tables are lists of name value mappings: The name is a string that identifies a symbol, and the value is an address in memory where the symbol of that name has been positioned. In most NuttX architectures symbol tables are required, as a minimum, in order to dynamically link the loaded binary object with the base code on FLASH. Since the binary object was separately built and separately linked, these symbols will appear as <em>undefined</em> symbols in the binary object. The binary loader will use the symbol table to look up the symbol by its name and to provide the address associated with the symbol as needed to perform the dynamic linking of the binary object to the base FLASH code.</p><p>Some toolchains will prefix symbols with an underscore. To support these toolchains the <code>CONFIG_SYMTAB_DECORATED</code> setting may be defined. This will cause a leading underscore to be ignored on <em>undefined</em> symbols during dynamic linking.</p><h3 id="symbol-table-header-files" tabindex="-1">Symbol Table Header Files <a class="header-anchor" href="#symbol-table-header-files" aria-label="Permalink to &quot;Symbol Table Header Files&quot;">​</a></h3><p>The interface to the symbol table logic is described in the header file <code>include/nuttx/binfmt/symtab.h</code>. A brief summary of the data structures and interfaces prototyped in that header file are listed below.</p><h3 id="symbol-table-data-structures" tabindex="-1">Symbol Table Data Structures <a class="header-anchor" href="#symbol-table-data-structures" aria-label="Permalink to &quot;Symbol Table Data Structures&quot;">​</a></h3><h3 id="symbol-table-function-interfaces" tabindex="-1">Symbol Table Function Interfaces <a class="header-anchor" href="#symbol-table-function-interfaces" aria-label="Permalink to &quot;Symbol Table Function Interfaces&quot;">​</a></h3><h2 id="configuration-variables" tabindex="-1">Configuration Variables <a class="header-anchor" href="#configuration-variables" aria-label="Permalink to &quot;Configuration Variables&quot;">​</a></h2><blockquote><ul><li><code>CONFIG_BINFMT_DISABLE</code>: By default, support for loadable binary formats is built. This logic may be suppressed be defining this setting.</li><li><code>CONFIG_BINFMT_CONSTRUCTORS</code>: Build in support for C++ constructors in loaded modules.</li><li><code>CONFIG_SYMTAB_ORDEREDBYNAME</code>: Symbol tables are order by name (rather than value).</li><li><code>CONFIG_SYMTAB_DECORATED</code>: Symbols will have a leading underscore in object files.</li></ul></blockquote><p>Additional configuration options may be required for the each enabled binary format.</p>',11)]))}const y=o(l,[["render",s]]);export{f as __pageData,y as default};
