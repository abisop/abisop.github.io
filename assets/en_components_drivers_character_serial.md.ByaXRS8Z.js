import{_ as r,c as t,al as a,o}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"Serial Device Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/character/serial.md","filePath":"en/components/drivers/character/serial.md"}'),c={name:"en/components/drivers/character/serial.md"};function i(s,e,d,l,n,p){return o(),t("div",null,e[0]||(e[0]=[a('<h1 id="serial-device-drivers" tabindex="-1">Serial Device Drivers <a class="header-anchor" href="#serial-device-drivers" aria-label="Permalink to &quot;Serial Device Drivers&quot;">​</a></h1><ul><li><p><code>include/nuttx/serial/serial.h</code>. All structures and APIs needed to work with serial drivers are provided in this header file.</p></li><li><p><code>struct uart_ops_s</code>. Each serial device driver must implement an instance of <code>struct uart_ops_s</code>. That structure defines a call table with the following methods:</p></li><li><p><code>int uart_register(FAR const char *path, FAR uart_dev_t *dev);</code>. A serial driver may register itself by calling <code>uart_register()</code>, passing it the <code>path</code> where it will appear in the <code>pseudo file system &lt;file_system_overview&gt;</code>{.interpreted-text role=&quot;ref&quot;} and it&#39;s initialized instance of <code>struct uart_ops_s</code>. By convention, serial device drivers are registered at paths like <code>/dev/ttyS0</code>, <code>/dev/ttyS1</code>, etc. See the <code>uart_register()</code> implementation in <code>drivers/serial.c</code>.</p></li><li><p><strong>TTY_LAUNCH</strong> this depends on <code>CONFIG_TTY_LAUNCH</code>, this feature allow user launch a new program with a special char input.</p><p>e.g. use ctrl+R to start a nuttx shell. e.g. use ctrl+E to start user entry.</p><p>You can use <code>TTY_LAUNCH_CHAR</code> to customize which special char.</p><p>You can choose launch method: <code>TTY_LAUNCH_ENTRY</code> or <code>TTY_LAUNCH_FILE</code>, If<code>TTY_LAUNCH_ENTRY</code> you can set program entry by <code>TTY_LAUNCH_ENTRYPOINT</code>. If<code>TTY_LAUNCH_FILE</code> you can set file path by <code>TTY_LAUNCH_FILEPATH</code>.</p><p>Also, you can customize: <code>TTY_LAUNCH_ARGS</code> <code>TTY_LAUNCH_PRIORITY</code><code>TTY_LAUNCH_STACKSIZE</code></p></li><li><p><strong>User Access</strong>. Serial drivers are, ultimately, normal <a href="#chardrivers">character drivers</a> and are accessed as other character drivers.</p></li><li><p><strong>Examples</strong>: <code>arch/arm/src/stm32/stm32_serial.c</code>, <code>arch/arm/src/lpc214x/lpc214x_serial.c</code>, <code>arch/z16/src/z16f/z16f_serial.c</code>, etc.</p></li></ul><h2 id="serial-error-reporting" tabindex="-1">Serial Error Reporting <a class="header-anchor" href="#serial-error-reporting" aria-label="Permalink to &quot;Serial Error Reporting&quot;">​</a></h2><p>It is possible to check if there are some frame, parity, overrun, break, or other error using the ioctl TIOCGICOUNT just like on Linux.</p>',4)]))}const u=r(c,[["render",i]]);export{h as __pageData,u as default};
