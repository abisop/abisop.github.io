import{_ as n,c as i,al as a,j as e,a as o,o as l}from"./chunks/framework.NFAqBSgQ.js";const b=JSON.parse('{"title":"NXFLAT","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/nxflat.md","filePath":"en/components/nxflat.md"}'),s={name:"en/components/nxflat.md"};function r(d,t,c,h,p,u){return l(),i("div",null,t[0]||(t[0]=[a(`<h1 id="nxflat" tabindex="-1">NXFLAT <a class="header-anchor" href="#nxflat" aria-label="Permalink to &quot;NXFLAT&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><h3 id="functionality" tabindex="-1">Functionality <a class="header-anchor" href="#functionality" aria-label="Permalink to &quot;Functionality&quot;">​</a></h3><p>NXFLAT is a customized and simplified version of binary format implemented a few years ago called <a href="http://xflat.sourceforge.net/" target="_blank" rel="noreferrer">XFLAT</a> With the NXFLAT binary format you will be able to do the following:</p><blockquote><ul><li>Place separately linked programs in a file system, and</li><li>Execute those programs by dynamically linking them to the base NuttX code.</li></ul></blockquote><p>This allows you to extend the NuttX base code after it has been written into FLASH. One motivation for implementing NXFLAT is support clean CGI under an HTTPD server.</p><p>This feature is especially attractive when combined with the NuttX ROMFS support: ROMFS allows you to execute programs in place (XIP) in flash without copying anything other than the .data section to RAM. In fact, the initial NXFLAT release only worked on ROMFS. Later extensions also support execution NXFLAT binaries from an SRAM copy as well.</p><p>This NuttX feature includes:</p><blockquote><ul><li>A dynamic loader that is built into the NuttX core (See <a href="https://github.com/apache/nuttx/blob/master/binfmt/" target="_blank" rel="noreferrer">GIT</a>).</li><li>Minor changes to RTOS to support position independent code, and</li><li>A linker to bind ELF binaries to produce the NXFLAT binary format (See GIT).</li></ul></blockquote><h3 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;Background&quot;">​</a></h3><p>NXFLAT is derived from <a href="http://xflat.sourceforge.net/" target="_blank" rel="noreferrer">XFLAT</a>. XFLAT is a toolchain add that provides full shared library and XIP executable support for processors that have no Memory Management Unit (MMU^1^). NXFLAT is greatly simplified for the deeply embedded environment targeted by NuttX:</p><blockquote><ul><li>NXFLAT does not support shared libraries, because</li><li>NXFLAT does not support <em>exportation</em> of symbol values from a module</li></ul></blockquote><p>Rather, the NXFLAT module only <em>imports</em> symbol values. In the NXFLAT model, the (PIC^2^) NXFLAT module resides in a FLASH file system and when it is loaded at run time, it is dynamically linked only to the (non-PIC) base NuttX code: The base NuttX <em>exports</em> a symbol table; the NXFLAT module <em>imports</em> those symbol value to dynamically bind the module to the base code.</p><h3 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to &quot;Limitations&quot;">​</a></h3><blockquote><ul><li><p><strong>ROMFS (or RAM mapping) Only</strong>: The current NXFLAT release will work only with either (1) NXFLAT executable modules residing on a ROMFS file system, or (2) executables residing on other file systems provided that CONFIG_FS_RAMMAP is defined. This limitation is because the loader depends on the capability to mmap() the code segment. See the NuttX User Guide for further information.</p><p>NUTTX does not provide any general kind of file mapping capability. In fact, true file mapping is only possible with MCUs that provide an MMU1. Without an MMU, file system may support eXecution In Place (XIP) to mimic file mapping. Only the ROMFS file system supports that kind of XIP execution need by NXFLAT.</p><p>It is also possible to simulate file mapping by allocating memory, copying the NXFLAT binary file into memory, and executing from the copy of the executable file in RAM. That capability can be enabled with the CONFIG_FS_RAMMAP configuration option. With that option enabled, NXFLAT will work that kind of file system but will require copying of all NXFLAT executables to RAM.</p></li><li><p><strong>GCC/ARM/Cortex-M3/4 Only</strong>: At present, the NXFLAT toolchain is only available for ARM and Cortex-M3/4 (thumb2) targets.</p></li><li><p><strong>Read-Only Data in RAM</strong>: With older GCC compilers (at least up to 4.3.3), read-only data must reside in RAM. In code generated by GCC, all data references are indexed by the PIC2 base register (that is usually R10 or sl for the ARM processors). The includes read-only data (.rodata). Embedded firmware developers normally like to keep .rodata in FLASH with the code sections. But because all data is referenced with the PIC base register, all of that data must lie in RAM. A NXFLAT change to work around this is under investigation3.</p><p>Newer GCC compilers (at least from 4.6.3), read-only data is no long GOT-relative, but is now accessed PC-relative. With PC relative addressing, read-only data must reside in the I-Space.</p></li><li><p><strong>Globally Scoped Function Function Pointers</strong>: If a function pointer is taken to a statically defined function, then (at least for ARM) GCC will generate a relocation that NXFLAT cannot handle. The workaround is make all such functions global in scope. A fix would involve a change to the GCC compiler as described in Appendix B.</p></li><li><p><strong>Special Handling of Callbacks</strong>: Callbacks through function pointers must be avoided or, when then cannot be avoided, handled very specially. The reason for this is that the PIC module requires setting of a special value in a PIC register. If the callback does not set the PIC register, then the called back function will fail because it will be unable to correctly access data memory. Special logic is in place to handle some NuttX callbacks: Signal callbacks and watchdog timer callbacks. But other callbacks (like those used with qsort() must be avoided in an NXFLAT module.</p></li></ul></blockquote><h3 id="supported-processors" tabindex="-1">Supported Processors <a class="header-anchor" href="#supported-processors" aria-label="Permalink to &quot;Supported Processors&quot;">​</a></h3><p>As mentioned <a href="#limitations">above</a>, the NXFLAT toolchain is only available for ARM and Cortex-M3 (thumb2) targets. Furthermore, NXFLAT has only been tested on the Eagle-100 LMS6918 Cortex-M3 board.</p><h3 id="development-status" tabindex="-1">Development Status <a class="header-anchor" href="#development-status" aria-label="Permalink to &quot;Development Status&quot;">​</a></h3><p>The initial release of NXFLAT was made in NuttX version 0.4.9. Testing is limited to the tests found under <code>apps/examples/nxflat</code> in the source tree. Some known problems exist (see the <a href="https://github.com/apache/nuttx/blob/master/TODO" target="_blank" rel="noreferrer">TODO</a> list). As such, NXFLAT is currently in an early alpha phase.</p><h2 id="nxflat-toolchain" tabindex="-1">NXFLAT Toolchain <a class="header-anchor" href="#nxflat-toolchain" aria-label="Permalink to &quot;NXFLAT Toolchain&quot;">​</a></h2><h3 id="building-the-nxflat-toolchain" tabindex="-1">Building the NXFLAT Toolchain <a class="header-anchor" href="#building-the-nxflat-toolchain" aria-label="Permalink to &quot;Building the NXFLAT Toolchain&quot;">​</a></h3><p>In order to use NXFLAT, you must use special NXFLAT tools to create the binary module in FLASH. To do this, you will need to download the buildroot package and build it on your Linux or Cygwin machine. The buildroot can be downloaded from <a href="https://bitbucket.org/nuttx/buildroot/downloads" target="_blank" rel="noreferrer">Bitbucket.org</a>. You will need version 0.1.7 or later.</p><p>Here are some general build instructions:</p><ul><li>You must have already configured NuttX in <code>&lt;some-dir&gt;/nuttx</code></li><li>Download the buildroot package <code>buildroot-0.x.y</code> into <code>&lt;some-dir&gt;</code></li><li>Unpack <code>&lt;some-dir&gt;/buildroot-0.x.y.tar.gz</code> using a command like <code>tar zxf buildroot-0.x.y</code>. This will result in a new directory like <code>&lt;some-dir&gt;/buildroot-0.x.y</code></li><li>Move this into position: <code>mv &lt;some-dir&gt;/buildroot-0.x.y</code>&lt;some-dir&gt;/buildroot</li><li><code>cd</code>&lt;some-dir&gt;/buildroot</li><li>Copy a configuration file into the top buildroot directory: <code>cp boards/abc-defconfig-x.y.z .config</code>.</li><li>Enable building of the NXFLAT tools by <code>make menuconfig</code>. Select to build the NXFLAT toolchain with GCC (you can also select omit building GCC with and only build the NXFLAT toolchain for use with your own GCC toolchain).</li><li>Make the toolchain: <code>make</code>. When the make completes, the tool binaries will be available under <code>&lt;some-dir&gt;/buildroot/build_abc/staging_dir/bin</code></li></ul><h3 id="mknxflat" tabindex="-1">mknxflat <a class="header-anchor" href="#mknxflat" aria-label="Permalink to &quot;mknxflat&quot;">​</a></h3><p><code>mknxflat</code> is used to build a <em>thunk</em> file. See below for usage:</p><pre><code>Usage: mknxflat [options] &lt;bfd-filename&gt;

Where options are one or more of the following.  Note
that a space is always required between the option and
any following arguments.

  -d Use dynamic symbol table. [symtab]
  -f &lt;cmd-filename&gt;
      Take next commands from &lt;cmd-filename&gt; [cmd-line]
  -o &lt;out-filename&gt;
     Output to  [stdout]
  -v Verbose output [no output]
  -w Import weakly declared functions, i.e., weakly
     declared functions are expected to be provided at
     load-time [not imported]
</code></pre><h3 id="ldnxflat" tabindex="-1">ldnxflat <a class="header-anchor" href="#ldnxflat" aria-label="Permalink to &quot;ldnxflat&quot;">​</a></h3><p><code>ldnxflat</code> is use to link your object files along with the <em>thunk</em> file generated by <code>mknxflat</code> to produce the NXFLAT binary module. See below for usage:</p><pre><code>Usage: ldnxflat [options] &lt;bfd-filename&gt;

Where options are one or more of the following.  Note
that a space is always required between the option and
any following arguments.

  -d Use dynamic symbol table [Default: symtab]
  -e &lt;entry-point&gt;
     Entry point to module [Default: _start]
  -o &lt;out-filename&gt;
     Output to &lt;out-filename&gt; [Default: &lt;bfd-filename&gt;.nxf]
  -s &lt;stack-size&gt;
     Set stack size to &lt;stack-size&gt; [Default: 4096]
  -v Verbose output. If -v is applied twice, additional
     debug output is enabled [Default: no verbose output].
</code></pre><h3 id="mksymtab" tabindex="-1">mksymtab <a class="header-anchor" href="#mksymtab" aria-label="Permalink to &quot;mksymtab&quot;">​</a></h3><p>There is a small helper program available in <code>nuttx/tools</code> call <code>mksymtab</code>. <code>mksymtab</code> can be sued to generate symbol tables for the NuttX base code that would be usable by the typical NXFLAT application. <code>mksymtab</code> builds symbol tables from common-separated value (CSV) files. In particular, the CSV files:</p><blockquote><ol><li><code>nuttx/syscall/syscall.csv</code> that describes the NuttX RTOS interface, and</li><li><code>nuttx/libc/libc.csv</code> that describes the NuttX C library interface.</li><li><code>nuttx/libc/math.cvs</code> that describes any math library.</li></ol></blockquote><pre><code>USAGE: ./mksymtab &lt;cvs-file&gt; &lt;symtab-file&gt;

Where:

  &lt;cvs-file&gt;   : The path to the input CSV file
  &lt;symtab-file&gt;: The path to the output symbol table file
  -d           : Enable debug output
</code></pre><p>For example,</p><pre><code>cd nuttx/tools
cat ../syscall/syscall.csv ../libc/libc.csv | sort &gt;tmp.csv
./mksymtab.exe tmp.csv tmp.c
</code></pre><h3 id="making-an-nxflat-module" tabindex="-1">Making an NXFLAT module <a class="header-anchor" href="#making-an-nxflat-module" aria-label="Permalink to &quot;Making an NXFLAT module&quot;">​</a></h3><p>Below is a snippet from an NXFLAT make file (simplified from NuttX <a href="https://github.com/apache/nuttx-apps/blob/master/examples/nxflat/tests/hello/Makefile" target="_blank" rel="noreferrer">Hello, World!</a> example).</p><ul><li><p>Target 1:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>hello.r1: hello.o</span></span>
<span class="line"><span>  abc-nuttx-elf-ld -r -d -warn-common -o @ ^</span></span></code></pre></div></li><li><p>Target 2:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>hello-thunk.S: hello.r1</span></span>
<span class="line"><span>  mknxflat -o @ ^</span></span></code></pre></div></li><li><p>Target 3:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>hello.r2: hello-thunk.S</span></span>
<span class="line"><span>  abc-nuttx-elf-ld -r -d -warn-common -T binfmt/libnxflat/gnu-nxflat-gotoff.ld -no-check-sections -o @ hello.o hello-thunk.o</span></span></code></pre></div></li><li><p>Target 4:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>hello: hello.r2</span></span>
<span class="line"><span>  ldnxflat -e main -s 2048 -o @ ^</span></span></code></pre></div></li></ul><p><strong>Target 1</strong>. This target links all of the module&#39;s object files together into one relocatable object. Two relocatable objects will be generated; this is the first one (hence, the suffic <code>.r1</code>). In this &quot;Hello, World!&quot; case, there is only a single object file, <code>hello.o</code>, that is linked to produce the <code>hello.r1</code> object.</p><p>When the module&#39;s object files are compiled, some special compiler CFLAGS must be provided. First, the option <code>-fpic</code> is required to tell the compiler to generate position independent code (other GCC options, like <code>-fno-jump-tables</code> might also be desirable). For ARM compilers, two additional compilation options are required: <code>-msingle-pic-base</code> and <code>-mpic-register=r10</code>.</p><p><strong>Target 2</strong>. Given the <code>hello.r1</code> relocatable object, this target will invoke <code>\`mknxflat</code> &lt;#mknxflat&gt;[__ to make the *thunk* file, ]{.title-ref}[hello-thunk.S]{.title-ref}\`. This <em>thunk</em> file contains all of the information needed to create the imported function list.</p><p><strong>Target 3</strong> This target is similar to <strong>Target 1</strong>. In this case, it will link together the module&#39;s object files (only <code>hello.o</code> here) along with the assembled <em>thunk</em> file, <code>hello-thunk.o</code> to create the second relocatable object, <code>hello.r2</code>. The linker script, <code>gnu-nxflat-gotoff.ld</code> is required at this point to correctly position the sections. This linker script produces two segments: An <em>I-Space</em> (Instruction Space) segment containing mostly <code>.text</code> and a <em>D-Space</em> (Data Space) segment containing <code>.got</code>, <code>.data</code>, and <code>.bss</code> sections. The I-Space section must be origined at address 0 (so that the segment&#39;s addresses are really offsets into the I-Space segment) and the D-Space section must also be origined at address 0 (so that segment&#39;s addresses are really offsets into the I-Space segment). The option <code>-no-check-sections</code> is required to prevent the linker from failing because these segments overlap.</p><p><strong>NOTE:</strong> There are two linker scripts located at <code>binfmt/libnxflat/</code>.</p><blockquote><ol><li><code>binfmt/libnxflat/gnu-nxflat-gotoff.ld</code>. Older versions of GCC (at least up to GCC 4.3.3), use GOT-relative addressing to access RO data. In that case, read-only data (.rodata) must reside in D-Space and this linker script should be used.</li><li><code>binfmt/libnxflat/gnu-nxflat-pcrel.ld</code>. Newer versions of GCC (at least as of GCC 4.6.3), use PC-relative addressing to access RO data. In that case, read-only data (.rodata) must reside in I-Space and this linker script should be used.</li></ol></blockquote><p><strong>Target 4</strong>. Finally, this target will use the <code>hello.r2</code> relocatable object to create the final, NXFLAT module <code>hello</code> by executing <code>ldnxflat</code>.</p>`,46),e("p",null,[e("strong",null,"binfmt Registration"),o(" NXFLAT calls :c"),e("code",{class:"interpreted-text",role:"func"},"register_binfmt"),o(" to incorporate itself into the system.")],-1),a(`<h2 id="appendix-a-no-got-operation" tabindex="-1">Appendix A: No GOT Operation <a class="header-anchor" href="#appendix-a-no-got-operation" aria-label="Permalink to &quot;Appendix A: No GOT Operation&quot;">​</a></h2><p>When GCC generate position independent code, new code sections will appear in your programs. One of these is the GOT (Global Offset Table) and, in ELF environments, another is the PLT (Procedure Lookup Table. For example, if your C code generated (ARM) assembly language like this without PIC:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ldr     r1, .L0         /* Fetch the offset to &#39;x&#39; */</span></span>
<span class="line"><span>ldr     r0, [r10, r1]   /* Load the value of &#39;x&#39; with PIC offset */</span></span>
<span class="line"><span>/* ... */</span></span>
<span class="line"><span>.L0:    .word   x               /* Offset to &#39;x&#39; */</span></span></code></pre></div><p>Then when PIC is enabled (say with the -fpic compiler option), it will generate code like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>ldr     r1, .L0         /* Fetch the offset to the GOT entry */</span></span>
<span class="line"><span>ldr     r1, [r10, r1]   /* Fetch the (relocated) address of &#39;x&#39; from the GOT */</span></span>
<span class="line"><span>ldr     r0, [r1, #0]    /* Fetch the value of &#39;x&#39; */</span></span>
<span class="line"><span>/* ... */</span></span>
<span class="line"><span>.L1     .word   x(GOT)          /* Offset to entry in the GOT */</span></span></code></pre></div><p>See <a href="http://xflat.sourceforge.net/NoMMUSharedLibs.html#shlibsgot" target="_blank" rel="noreferrer">reference</a></p><p>Notice that the generates an extra level of indirection through the GOT. This indirection is not needed by NXFLAT and only adds more RAM usage and execution time.</p><p>NXFLAT (like <a href="http://xflat.sourceforge.net/" target="_blank" rel="noreferrer">XFLAT</a>) can work even better without the GOT. Patches against older version of GCC exist to eliminate the GOT indirections. Several are available <a href="http://xflat.cvs.sourceforge.net/viewvc/xflat/xflat/gcc/" target="_blank" rel="noreferrer">here</a> if you are inspired to port them to a new GCC version.</p><h2 id="appendix-b-pic-text-workaround" tabindex="-1">Appendix B: PIC Text Workaround <a class="header-anchor" href="#appendix-b-pic-text-workaround" aria-label="Permalink to &quot;Appendix B: PIC Text Workaround&quot;">​</a></h2><p>There is a problem with the memory model in GCC that prevents it from being used as you need to use it in the NXFLAT context. The problem is that GCC PIC model assumes that the executable lies in a flat, contiguous (virtual) address space like:</p><pre><code>Virtual
.text
.got
.data
.bss
</code></pre><p>It assumes that the PIC base register (usually r10 for ARM) points to the base of <code>.text</code> so that any address in <code>.text</code>, <code>.got</code>, <code>.data</code>, <code>.bss</code> can be found with an offset from the same base address. But that is not the memory arrangement that we need in the XIP embedded environment. We need two memory regions, one in FLASH containing shared code and on per task in RAM containing task-specific data:</p><pre><code>Flash   RAM
.text   .got
        .data
        .bss
</code></pre><p>The PIC base register needs to point to the base of the <code>.got</code> and only addresses in the <code>.got</code>, <code>.data</code>, and <code>.bss</code> sections can be accessed as an offset from the PIC base register. See also this <a href="http://xflat.cvs.sourceforge.net/viewvc/*checkout*/xflat/xflat/gcc/README?revision=1.1.1.1" target="_blank" rel="noreferrer">XFLAT discussion</a>.</p><p>Patches against older version of GCC exist to correct this GCC behavior. Several are available <a href="http://xflat.cvs.sourceforge.net/viewvc/xflat/xflat/gcc/" target="_blank" rel="noreferrer">here</a> if you are inspired to port them to a new GCC version.</p>`,15)]))}const f=n(s,[["render",r]]);export{b as __pageData,f as default};
