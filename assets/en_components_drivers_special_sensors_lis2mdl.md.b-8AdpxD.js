import{_ as s,c as a,al as n,o as t}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"LIS2MDL","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/special/sensors/lis2mdl.md","filePath":"en/components/drivers/special/sensors/lis2mdl.md"}'),i={name:"en/components/drivers/special/sensors/lis2mdl.md"};function o(r,e,p,l,c,d){return t(),a("div",null,e[0]||(e[0]=[n(`<h1 id="lis2mdl" tabindex="-1">LIS2MDL <a class="header-anchor" href="#lis2mdl" aria-label="Permalink to &quot;LIS2MDL&quot;">​</a></h1><p>Contributed by Matteo Golin.</p><p>The LIS2MDL is a low power, high-performance 3-axis magnetometer by ST Microelectronics. It has I2C and SPI interfaces, although this driver currently only supports I2C.</p><p>The driver uses the [[uorb](\`uorb.md) &lt;/components/drivers/special/sensors/sensors_uorb&gt;]{.title-ref} interface. It supports the self-test capability</p><h2 id="application-programming-interface" tabindex="-1">Application Programming Interface <a class="header-anchor" href="#application-programming-interface" aria-label="Permalink to &quot;Application Programming Interface&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;nuttx/sensors/lis2mdl.h&gt;</span></span></code></pre></div><p>The LIS2MDL registration function allows the driver to be registered as a UORB driver. Registering this driver will cause the <code>/dev/uorb/sensor_mag&lt;n&gt;</code> topic to appear, where <code>n</code> is the value of <code>devno</code>.</p><p>The driver can be registered either in polling mode or in interrupt-driven mode. The polling mode will create a kernel thread to poll the sensor periodically according to the set interval. Polling mode is registered with <code>NULL</code> instead of a real function pointer to the <code>attach</code> parameter, like so:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int err;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Creates /dev/uorb/mag0 in polled mode */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>err = lis2mdl_register(i2c_master, 0, 0x1e, NULL);</span></span>
<span class="line"><span>if (err &lt; 0)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  syslog(LOG_ERR, &quot;Could not register LIS2MDL driver at 0x1E: %d\\n&quot;, err);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>To register in interrupt-driven mode, a function must be provided by the calling code to register the LIS2MDL interrupt handler properly. This function should take the interrupt handler and <code>arg</code> reference as arguments, and return 0 on success or a negated error code on failure. This function must also enable the interrupt after it is registered successfully.</p><p>Warning</p><p>To use interrupt-driven mode, <code>CONFIG_SCHED_HPWORK</code> must be enabled.</p><p>The example below shows the example process for an RP2040 based board, but it will be similar on other architectures:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* IRQ attach function example for RP2040 board */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>static int board_lis2mdl_attach(xcpt_t handler, FAR void *arg)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  int err;</span></span>
<span class="line"><span>  err = rp2040_gpio_irq_attach(GPIO_MAG_INT, RP2040_GPIO_INTR_EDGE_HIGH,</span></span>
<span class="line"><span>                               handler, arg);</span></span>
<span class="line"><span>  if (err &lt; 0)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      return err;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  rp2040_gpio_enable_irq(GPIO_MAG_INT);</span></span>
<span class="line"><span>  return err;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Later, in the board bringup code ... */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int err;</span></span>
<span class="line"><span>err = lis2mdl_register(i2c_master, 0, 0x1e, board_lis2mdl_attach);</span></span>
<span class="line"><span>if (err &lt; 0)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  syslog(LOG_ERR, &quot;Couldn&#39;t register LIS2MDL driver: %d\\n&quot;, err);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>To debug this device, you can include the <code>uorb_listener</code> in your build with debugging enabled. Running it will show the sensor measurements.</p><p>Warning</p><p>By default, when the sensor is deactivated via the UORB interface, it is put into low power mode and set to idle. When it is reactivated, it is put in high resolution mode and set to continuous measurement. If you want to measure continuously in low power mode, you will need to use the <code>SNIOC_SET_POWER_MODE</code> command explained below.</p><p>The <code>set_calibvalue</code> interface to this sensor takes an array of three [float]{.title-ref} types, representing hard-iron offsets in micro Teslas. This offset is set on the sensor and is subtracted from measurements to compensate for environmental effects.</p><p>Some additional control commands for the LIS2MDL are listed below.</p><h3 id="snioc-who-am-i" tabindex="-1"><code>SNIOC_WHO_AM_I</code> <a class="header-anchor" href="#snioc-who-am-i" aria-label="Permalink to &quot;\`SNIOC_WHO_AM_I\`&quot;">​</a></h3><p>This command reads the <code>WHOAMI</code> register of the LIS2MDL. This should always return <code>0x40</code>. The argument is a pointer to an 8-bit unsigned integer.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uint8_t id; /* Should always contain 0x40 */</span></span>
<span class="line"><span>err = orb_ioctl(sensor, SNIOC_WHO_AM_I, &amp;id);</span></span></code></pre></div><h3 id="snioc-set-power-mode" tabindex="-1"><code>SNIOC_SET_POWER_MODE</code> <a class="header-anchor" href="#snioc-set-power-mode" aria-label="Permalink to &quot;\`SNIOC_SET_POWER_MODE\`&quot;">​</a></h3><p>This command selects the power mode of the LIS2MDL sensor. An argument of <code>true</code> puts the sensor in low power mode, and <code>false</code> puts the sensor into high resolution mode.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/* Puts LIS2MDL into low power mode */</span></span>
<span class="line"><span>err = orb_ioctl(sensor, SNIOC_WHO_AM_I, true);</span></span></code></pre></div><h3 id="snioc-reset" tabindex="-1"><code>SNIOC_RESET</code> <a class="header-anchor" href="#snioc-reset" aria-label="Permalink to &quot;\`SNIOC_RESET\`&quot;">​</a></h3><p>Performs a soft reset of the LIS2MDL, which resets the user registers. This command takes no arguments. Once this command is issue, 5 microseconds must pass before the sensor is operational again.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>err = orb_ioctl(sensor, SNIOC_RESET, NULL);</span></span></code></pre></div><h3 id="snioc-sensor-off" tabindex="-1"><code>SNIOC_SENSOR_OFF</code> <a class="header-anchor" href="#snioc-sensor-off" aria-label="Permalink to &quot;\`SNIOC_SENSOR_OFF\`&quot;">​</a></h3><p>Performs a reboot of the LIS2MDL&#39;s memory contents. This command takes no arguments. After the command is issued, 20ms must pass before the sensor is operational again.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>err = orb_ioctl(sensor, SNIOC_SENSOR_OFF, NULL);</span></span></code></pre></div><h3 id="snioc-set-temp-offset" tabindex="-1"><code>SNIOC_SET_TEMP_OFFSET</code> <a class="header-anchor" href="#snioc-set-temp-offset" aria-label="Permalink to &quot;\`SNIOC_SET_TEMP_OFFSET\`&quot;">​</a></h3><p>Enables or disables temperature compensation on the magnetometer. A arg of <code>true</code> enables compensation, <code>false</code> disables it. By default this is enabled.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>err = orb_ioctl(sensor, SNIOC_SET_TEMP_OFFSET, true);</span></span></code></pre></div><h3 id="snioc-lpf" tabindex="-1"><code>SNIOC_LPF</code> <a class="header-anchor" href="#snioc-lpf" aria-label="Permalink to &quot;\`SNIOC_LPF\`&quot;">​</a></h3><p>Enables or disables the magnetometer low pass filter. A arg of <code>true</code> enables the filter, <code>false</code> disables it. By default this is disabled.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>err = orb_ioctl(sensor, SNIOC_LPF, true);</span></span></code></pre></div>`,37)]))}const m=s(i,[["render",o]]);export{u as __pageData,m as default};
