import{_ as a,c as o,al as t,o as n}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"Debugging ELF Loadable Modules","description":"","frontmatter":{},"headers":[],"relativePath":"en/debugging/debugging_elf_loadable_modules.md","filePath":"en/debugging/debugging_elf_loadable_modules.md"}'),i={name:"en/debugging/debugging_elf_loadable_modules.md"};function l(s,e,d,r,p,u){return n(),o("div",null,e[0]||(e[0]=[t(`<h1 id="debugging-elf-loadable-modules" tabindex="-1">Debugging ELF Loadable Modules <a class="header-anchor" href="#debugging-elf-loadable-modules" aria-label="Permalink to &quot;Debugging ELF Loadable Modules&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Debugging+ELF+Loadable+Modules" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Debugging+ELF+Loadable+Modules</a></p><p>Debugging ELF modules loaded in memory can be tricky because the load address in memory does not match the addresses in the ELF file. This challenge has long existed for debugging uClinux programs and Linux kernel modules; the same solution can be used with NuttX ELF files (and probably with NxFLAT modules as well). Below is a summary of one way to approach this:</p><ol><li>Get ELF Module Load Address</li></ol><hr><p>Put a change in <code>nuttx/binfmt</code> so that you print the address where the ELF text was loaded into memory.</p><p>Turning on BINFMT debug (<code>CONFIG_DEBUG_BINFMT=y</code>) should give you the same information, although it may also provide more output than you really want.</p><p>Alternatively, you could place a <code>printf()</code> at the beginning of your <code>main()</code> function so that your ELF module can print its own load address. For example, the difference between the address of <code>main()</code> in your object file and the address of <code>main()</code> at run time reveals the actual load address.</p><ol start="2"><li>Make the ELF Module Wait for You</li></ol><hr><p>Insert an infinite loop in the <code>main()</code> routine of your ELF program. For example:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>volatile bool waitforme;</span></span>
<span class="line"><span>int main (int arc, char **argv)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    while (!waitforme);</span></span>
<span class="line"><span>    ...</span></span></code></pre></div><p>When you start the ELF program, you will see where it was loaded in memory, and the ELF program will remain stuck in the infinite loop. It will continue to wait for <code>waitforme</code> to become true before proceeding.</p><ol start="3"><li>Start the Debugger</li></ol><hr><p>Start the debugger, connect to the GDB server, and halt the program. If your debugger is well-behaved, it should stop at the infinite loop in <code>main()</code>.</p><ol start="4"><li>Load Offset Symbols</li></ol><hr><p>Load symbols using the offset where the ELF module was loaded:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(gdb) add-symbol-file &lt;myprogram&gt; &lt;load-address&gt;</span></span></code></pre></div><p>Here, <code>&lt;myprogram&gt;</code> is your ELF file containing symbols, and <code>&lt;load-address&gt;</code> is the address where the program text was actually loaded (as determined above). Single-step a couple of times and confirm that you are in the infinite loop.</p><ol start="5"><li>And Debug</li></ol><hr><p>Set <code>waitforme</code> to a non-zero value. Execution should exit the infinite loop, and now you can debug the ELF program loaded into RAM in the usual way.</p><h2 id="an-easier-way" tabindex="-1">An Easier Way? <a class="header-anchor" href="#an-easier-way" aria-label="Permalink to &quot;An Easier Way?&quot;">​</a></h2><p>There might be an alternative that allows you to step into the ELF module without modifying the code to include the <code>waitforme</code> loop. You could place a breakpoint on the OS function <code>task_start()</code>. That function runs before your ELF program starts, so you should be able to single-step from the OS code directly into your loaded ELF application---no changes to the ELF application required.</p><p>When you step into the application&#39;s <code>main()</code>, you have the relocated address of <code>main()</code> and can use that address (see step #1) to compute the load offset.</p>`,28)]))}const g=a(i,[["render",l]]);export{h as __pageData,g as default};
