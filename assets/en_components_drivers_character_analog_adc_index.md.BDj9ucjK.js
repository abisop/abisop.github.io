import{_ as o,c as i,al as r,j as e,a,o as n}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"ADC Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/character/analog/adc/index.md","filePath":"en/components/drivers/character/analog/adc/index.md"}'),s={name:"en/components/drivers/character/analog/adc/index.md"};function c(d,t,l,p,h,u){return n(),i("div",null,t[0]||(t[0]=[r(`<h1 id="adc-drivers" tabindex="-1">ADC Drivers <a class="header-anchor" href="#adc-drivers" aria-label="Permalink to &quot;ADC Drivers&quot;">​</a></h1><ul><li><code>include/nuttx/analog/adc.h</code>. All structures and APIs needed to work with ADC drivers are provided in this header file. This header file includes: <ol><li>Structures and interface descriptions needed to develop a low-level, architecture-specific, ADC driver.</li><li>To register the ADC driver with a common ADC character driver.</li><li>Interfaces needed for interfacing user programs with the common ADC character driver.</li></ol></li><li><code>drivers/analog/adc.c</code>. The implementation of the common ADC character driver.</li></ul><h2 id="application-programming-interface" tabindex="-1">Application Programming Interface <a class="header-anchor" href="#application-programming-interface" aria-label="Permalink to &quot;Application Programming Interface&quot;">​</a></h2><p>The first necessary thing to be done in order to use the ADC driver from an application is to include the correct header filer. It contains the Application Programming Interface to the ADC driver. To do so, include:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;nuttx/analog/adc.h&gt;</span></span></code></pre></div><p>ADC driver is registered as a POSIX character device file into <code>/dev</code> namespace. It is necessary to open the device to get a file descriptor for further operations. This can be done with standard POSIX <code>open()</code> call.</p><p>Standard POSIX <code>read()</code> operation may be used to read the measured data from the controller. The driver utilizes FIFO queue for received measurements and <code>read()</code> operation gets data from this queue. Structure <code>adc_msg_s</code> (or array of these structures) should be passed to buffer parameter of <code>read()</code> call. This structure represents one ADC measurement.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>begin_packed_struct struct adc_msg_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  /* The 8-bit ADC Channel */</span></span>
<span class="line"><span>  uint8_t      am_channel;</span></span>
<span class="line"><span>  /* ADC convert result (4 bytes) */</span></span>
<span class="line"><span>  int32_t      am_data;</span></span>
<span class="line"><span>} end_packed_struct;</span></span></code></pre></div><p>User may perform polling operation on the driver with <code>poll()</code> call. The controller also may be configured/controlled at run time with numerous <code>ioctl()</code> calls. Following commands are supported:</p>`,9),e("blockquote",null,[e("ul",null,[e("li",null,[a(":c"),e("code",{class:"interpreted-text",role:"macro"},"ANIOC_TRIGGER")]),e("li",null,[a(":c"),e("code",{class:"interpreted-text",role:"macro"},"ANIOC_WDOG_UPPER")]),e("li",null,[a(":c"),e("code",{class:"interpreted-text",role:"macro"},"ANIOC_WDOG_LOWER")]),e("li",null,[a(":c"),e("code",{class:"interpreted-text",role:"macro"},"ANIOC_GET_NCHANNELS")]),e("li",null,[a(":c"),e("code",{class:"interpreted-text",role:"macro"},"ANIOC_RESET_FIFO")]),e("li",null,[a(":c"),e("code",{class:"interpreted-text",role:"macro"},"ANIOC_SAMPLES_ON_READ")])])],-1),r('<p>The <code>ANIOC_TRIGGER</code> command triggers one conversion. This call is used when software trigger conversion is configured. The opposite to software trigger is a hardware trigger. This may be some timer driver for example.</p><p>This command is used to set the upper threshold for the watchdog.</p><p>This command is used to set the lower threshold for the watchdog.</p><p>The <code>ANIOC_GET_NCHANNELS</code> gets the number of used/configured channels for given opened instance. This is the only portable way how to get the number of channels from the driver.</p><p>This <code>ioctl</code> command clears the FIFO queue in which measured data are stored.</p><p>The <code>ANIOC_SAMPLES_ON_READ</code> returns number of samples/measured data waiting in the FIFO queue to be read.</p><p>It is possible for a controller to support its specific ioctl commands. These should be described in controller specific documentation.</p><h3 id="application-example" tabindex="-1">Application Example <a class="header-anchor" href="#application-example" aria-label="Permalink to &quot;Application Example&quot;">​</a></h3><p>An example application can be found in <code>nuttx-apps</code> repository under path <code>examples/adc</code>. It is an example application that reads the data from the defined number of channels.</p><h2 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h2><p>This section describes ADC driver configuration in <code>Kconfig</code>. The reader should refer to target documentation for target specific configuration.</p><p>ADC peripheral is enabled by <code>CONFIG_ANALOG</code> and <code>CONFIG_ADC</code> options, respectively. The user can configure FIFO queue size with configuration option <code>CONFIG_ADC_FIFOSIZE</code>. This variable defines the size of the ADC ring buffer that is used to queue received ADC data until they can be retrieved by the application by reading from the ADC character device. Since this is a ring buffer, the actual number of bytes that can be retained in buffer is (<code>CONFIG_ADC_FIFOSIZE - 1</code>).</p><p>Configuration option <code>CONFIG_ADC_NPOLLWAITERS</code> defines number of threads that can be waiting on poll.</p><h2 id="external-devices" tabindex="-1">External Devices <a class="header-anchor" href="#external-devices" aria-label="Permalink to &quot;External Devices&quot;">​</a></h2><p>NuttX also provides support for various external ADC devices. These usually communicates with MCU with I2C or SPI peripherals.</p><blockquote><p><em>/</em></p></blockquote>',16)]))}const g=o(s,[["render",c]]);export{f as __pageData,g as default};
