import{_ as i,c as t,al as r,o as d}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"Removing Device Drivers with NSH","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/remove_device_drivers_nsh.md","filePath":"en/guides/remove_device_drivers_nsh.md"}'),o={name:"en/guides/remove_device_drivers_nsh.md"};function n(s,e,a,c,l,h){return d(),t("div",null,e[0]||(e[0]=[r('<h1 id="removing-device-drivers-with-nsh" tabindex="-1">Removing Device Drivers with NSH <a class="header-anchor" href="#removing-device-drivers-with-nsh" aria-label="Permalink to &quot;Removing Device Drivers with NSH&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Removing+Device+Drivers+with+NSH" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Removing+Device+Drivers+with+NSH</a></p><h2 id="nuttx-and-unix-like-operating-systems-compared" tabindex="-1">NuttX and Unix-like Operating Systems Compared <a class="header-anchor" href="#nuttx-and-unix-like-operating-systems-compared" aria-label="Permalink to &quot;NuttX and Unix-like Operating Systems Compared&quot;">​</a></h2><p>There are many things that are called device drivers. In this context, the discussion is limited to <strong>character device drivers</strong>. In NuttX, character device drivers are represented by device driver nodes in the top-level [[p](`p.md)seudo filesystem &lt;/components/filesystem/pseudofs&gt;]{.title-ref}.</p><p>Standard Unix-like operating systems also support device driver nodes, which superficially resemble NuttX device driver nodes: Both look like files and usually reside under the top-level <code>/dev</code> directory. Both can be accessed with standard POSIX file system commands such as <code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, and so forth. However, the similarity ends there.</p><p>The payload of a standard Unix-like operating system device driver node is a device major and minor number. These major and minor device numbers are used to look up the actual device driver interface using internal OS logic and data structures. A NuttX device node, by contrast, directly holds the device driver interface with no intervening lookup. This design is less flexible, but it is more efficient and conserves limited resources in an embedded system.</p><p>In standard Unix-like operating systems, the device node can simply be deleted using the shell command <code>rm</code> or the programmatic interface <code>unlink()</code>. The node is removed, and nothing special happens to the underlying device driver (except that it may no longer be accessible).</p><p>In NuttX, if the device node were removed in the same way, the entire device interface would also be removed, effectively breaking the driver. Internally, NuttX supports a function called <code>unregister_driver()</code> that can be invoked to remove a device driver. Therefore, removing the device driver node must behave as though <code>unregister_driver()</code> were called.</p><h2 id="the-unlink-method" tabindex="-1">The unlink() Method <a class="header-anchor" href="#the-unlink-method" aria-label="Permalink to &quot;The unlink() Method&quot;">​</a></h2><p>How is this accomplished in NuttX? It is done via a special device driver method called <code>unlink()</code>.</p><p>NuttX device drivers are implemented via a vtable of function pointers. That vtable defines the interface between the pseudo-file system and the device driver. This vtable is the structure <code>struct file_operations</code> defined in <code>[nuttx]/include/nuttx/fs/fs.h</code>. It provides several interfaces that closely match the standard POSIX interfaces---<code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, etc.---and also includes a method called <code>unlink()</code>. This <code>unlink()</code> method is called by the NuttX VFS when a user removes a device driver node.</p><p>Note</p><p>Removal of device driver nodes is only permitted if <code>CONFIG_DISABLE_PSEUDOFS_OPERATIONS</code> is <strong>not</strong> defined. All pseudo-file system operations may be suppressed to reduce the FLASH footprint in systems with extremely limited resources.</p><h2 id="removing-a-device-node-from-nsh" tabindex="-1">Removing a Device Node from NSH <a class="header-anchor" href="#removing-a-device-node-from-nsh" aria-label="Permalink to &quot;Removing a Device Node from NSH&quot;">​</a></h2><p>Below is a summary of what happens when a device node is deleted using the NSH <code>rm</code> command:</p><ol><li>The user enters the <code>rm</code> command. The NSH parser recognizes the command and transfers control to the NSH function <code>cmd_rm()</code>.</li><li><code>cmd_rm()</code> verifies the command, then calls the standard POSIX <code>unlink()</code> interface. The logic in the VFS <code>unlink()</code> function in <code>[nuttx]/fs/vfs/fs_unlink.c</code> is then executed.</li><li>The VFS <code>unlink()</code> detects that the target to be removed is a device node in the top-level pseudo-file system. It calls the device driver&#39;s <code>unlink()</code> method. It also removes the device node from the pseudo-filesystem. However, the underlying resources required to support the device driver interface may remain until the device driver frees those resources.</li><li>When the device driver&#39;s <code>unlink()</code> method is called, it determines if the device resources can be freed immediately. If so, it frees those resources. If, for example, there are still open references to the device driver, it may defer freeing the resources until the last client has closed the device driver and there are no open references. In such a case, it may set a flag indicating that the device driver has been unlinked.</li><li>If freeing of device driver resources has been deferred, that flag will be examined later. For instance, when the last client of the device driver closes its reference to the driver, it checks whether the unlink operation was deferred. If so, it frees any remaining device driver resources at that time.</li></ol><p>Warning</p><p>Some character device driver instances do not implement the <code>unlink()</code> method. If problems arise when attempting to remove character drivers as described in this Wiki page, a missing <code>unlink()</code> method is the most likely cause.</p>',19)]))}const u=i(o,[["render",n]]);export{m as __pageData,u as default};
