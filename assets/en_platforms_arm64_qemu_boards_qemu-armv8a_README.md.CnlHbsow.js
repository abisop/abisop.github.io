import{_ as t,c as r,al as i,o as n}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"README.txt","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm64/qemu/boards/qemu-armv8a/README.md","filePath":"en/platforms/arm64/qemu/boards/qemu-armv8a/README.md"}'),a={name:"en/platforms/arm64/qemu/boards/qemu-armv8a/README.md"};function o(s,e,c,l,m,d){return n(),r("div",null,e[0]||(e[0]=[i(`<h1 id="readme-txt" tabindex="-1">README.txt <a class="header-anchor" href="#readme-txt" aria-label="Permalink to &quot;README.txt&quot;">​</a></h1><p>This board configuration will use QEMU to emulate generic ARM64 v8-A series hardware platform and provides support for these devices:</p><ul><li>GICv2 and GICv3 interrupt controllers</li><li>ARM Generic Timer</li><li>PL011 UART controller</li></ul><h1 id="contents" tabindex="-1">Contents <a class="header-anchor" href="#contents" aria-label="Permalink to &quot;Contents&quot;">​</a></h1><ul><li>Getting Started</li><li>Status</li><li>Platform Features</li><li>Debugging with QEMU</li><li>FPU Support and Performance</li><li>SMP Support</li><li>References</li></ul><h1 id="getting-started" tabindex="-1">Getting Started <a class="header-anchor" href="#getting-started" aria-label="Permalink to &quot;Getting Started&quot;">​</a></h1><ol><li><p>Compile Toolchain 1.1 Host environment GNU/Linux: Ubuntu 18.04 or greater 1.2 Download and Install $ wget <a href="https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86%5C_64-aarch64-none-elf.tar.xz" target="_blank" rel="noreferrer">https://developer.arm.com/-/media/Files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86\\_64-aarch64-none-elf.tar.xz</a> $ xz -d gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf.tar.xz $ tar xf gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf.tar</p><p>Put gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf/bin/ to your host PATH environment variable, like: $ export PATH=$PATH:/opt/software/arm/linaro-toolchain/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf/bin check the toolchain: $ aarch64-none-elf-gcc -v</p></li><li><p>Install QEMU In Ubuntu 18.04(or greater), install qemu: $ sudo apt-get install qemu-system-arm qemu-efi-aarch64 qemu-utils And make sure install is properly: $ qemu-system-aarch64 --help</p></li><li><p>Configuring and running 3.1 Single Core (GICv3) Configuring NuttX and compile: $ ./tools/configure.sh -l qemu-armv8a:nsh $ make Running with qemu $ qemu-system-aarch64 -cpu cortex-a53 -nographic<br> -machine virt,virtualization=on,gic-version=3<br> -net none -chardev stdio,id=con,mux=on -serial chardev:con<br> -mon chardev=con,mode=readline -kernel ./nuttx</p></li></ol><p>3.1.1 Single Core with virtio network, block, rng, serial driver (GICv3) Configuring NuttX and compile: $ ./tools/configure.sh -l qemu-armv8a:netnsh $ make $ dd if=/dev/zero of=./mydisk-1gb.img bs=1M count=1024 Running with qemu $ qemu-system-aarch64 -cpu cortex-a53 -nographic<br> -machine virt,virtualization=on,gic-version=3<br> -chardev stdio,id=con,mux=on -serial chardev:con<br> -global virtio-mmio.force-legacy=false<br> -device virtio-serial-device,bus=virtio-mmio-bus.0<br> -chardev socket,telnet=on,host=127.0.0.1,port=3450,server=on,wait=off,id=foo<br> -device virtconsole,chardev=foo<br> -device virtio-rng-device,bus=virtio-mmio-bus.1<br> -netdev user,id=u1,hostfwd=tcp:127.0.0.1:10023-10.0.2.15:23,hostfwd=tcp:127.0.0.1:15001-10.0.2.15:5001<br> -device virtio-net-device,netdev=u1,bus=virtio-mmio-bus.2<br> -drive file=./mydisk-1gb.img,if=none,format=raw,id=hd<br> -device virtio-blk-device,bus=virtio-mmio-bus.3,drive=hd<br> -mon chardev=con,mode=readline -kernel ./nuttx</p><p>3.1.2 Single Core with virtio gpu driver (GICv3) Configuring NuttX and compile: $ ./tools/configure.sh qemu-armv8a:fb $ make -j Running with qemu $ qemu-system-aarch64 -cpu cortex-a53<br> -machine virt,virtualization=on,gic-version=3<br> -chardev stdio,id=con,mux=on -serial chardev:con<br> -global virtio-mmio.force-legacy=false<br> -device virtio-gpu-device,xres=640,yres=480,bus=virtio-mmio-bus.0<br> -mon chardev=con,mode=readline -kernel ./nuttx</p><p>NuttShell (NSH) NuttX-10.4.0 nsh&gt; fb</p><p>3.1.3 Single Core with virtio 9pFs (GICv3) Configuring NuttX and compile: $ ./tools/configure.sh qemu-armv8a:netnsh $ make -j Running with qemu $ qemu-system-aarch64 -cpu cortex-a53 -nographic<br> -machine virt,virtualization=on,gic-version=3<br> -fsdev local,security_model=none,id=fsdev0,path=/mnt/xxx<br> -device virtio-9p-device,id=fs0,fsdev=fsdev0,mount_tag=host<br> -chardev stdio,id=con,mux=on, -serial chardev:con<br> -mon chardev=con,mode=readline -kernel ./nuttx</p><p>NuttShell (NSH) NuttX-10.4.0 nsh&gt; mkdir mnt nsh&gt; mount -t v9fs -o trans=virtio,tag=host mnt nsh&gt; ls /: dev/ mnt/ proc/</p><p>3.1.4 Single Core with MTE Expansion (GICv3) Configuring NuttX and compile: $ ./tools/configure.sh qemu-armv8a:mte $ make -j Running with qemu $ qemu-system-aarch64 -cpu max -nographic<br> -machine virt,virtualization=on,gic-version=3,mte=on<br> -chardev stdio,id=con,mux=on, -serial chardev:con<br> -mon chardev=con,mode=readline -kernel ./nuttx/nuttx</p><p>NuttShell (NSH) NuttX-10.4.0 nsh&gt; mtetest</p><p>3.2 SMP (GICv3) Configuring NuttX and compile: $ ./tools/configure.sh -l qemu-armv8a:nsh_smp $ make Running with qemu $ qemu-system-aarch64 -cpu cortex-a53 -smp 4 -nographic<br> -machine virt,virtualization=on,gic-version=3<br> -net none -chardev stdio,id=con,mux=on -serial chardev:con<br> -mon chardev=con,mode=readline -kernel ./nuttx</p><p>3.2.1 SMP (GICv3) Configuring NuttX and compile: $ ./tools/configure.sh -l qemu-armv8a:netnsh_smp $ make Running with qemu $ qemu-system-aarch64 -cpu cortex-a53 -smp 4 -nographic<br> -machine virt,virtualization=on,gic-version=3<br> -chardev stdio,id=con,mux=on -serial chardev:con<br> -global virtio-mmio.force-legacy=false<br> -netdev user,id=u1,hostfwd=tcp:127.0.0.1:10023-10.0.2.15:23,hostfwd=tcp:127.0.0.1:15001-10.0.2.15:5001<br> -device virtio-net-device,netdev=u1,bus=virtio-mmio-bus.0<br> -mon chardev=con,mode=readline -kernel ./nuttx</p><p>3.3 Single Core (GICv2) Configuring NuttX and compile: $ ./tools/configure.sh -l qemu-armv8a:nsh_gicv2 $ make Running with qemu $ qemu-system-aarch64 -cpu cortex-a53 -nographic<br> -machine virt,virtualization=on,gic-version=2<br> -net none -chardev stdio,id=con,mux=on -serial chardev:con<br> -mon chardev=con,mode=readline -kernel ./nuttx</p><p>Note: 1. Make sure the aarch64-none-elf toolchain install PATH has been added to environment variable 2. To quit QEMU, type Ctrl + X 3. Nuttx default core number is 4, and Changing CONFIG_SMP_NCPUS &gt; 4 and setting qemu command option -smp will boot more core. For qemu, core limit is 32.</p><p>3.4 SMP + Networking with hypervisor (GICv2) Configuring NuttX and compile: $ ./tools/configure.sh -l qemu-armv8a:netnsh_smp_hv $ make Running with qemu + kvm on raspi3b+ (ubuntu server 20.04) $ qemu-system-aarch64 -nographic<br> -machine virt -cpu host -smp 4 -accel kvm<br> -chardev stdio,id=con,mux=on -serial chardev:con<br> -global virtio-mmio.force-legacy=false<br> -drive file=./mydisk-1gb.img,if=none,format=raw,id=hd -device virtio-blk-device,drive=hd<br> -netdev user,id=u1,hostfwd=tcp:127.0.0.1:10023-10.0.2.15:23,hostfwd=tcp:127.0.0.1:15001-10.0.2.15:5001<br> -device virtio-net-device,netdev=u1,bus=virtio-mmio-bus.0<br> -mon chardev=con,mode=readline -kernel ./nuttx Running with qemu + hvf on M1/MacBook Pro (macOS 12.6.1) $ qemu-system-aarch64 -nographic<br> -machine virt -cpu host -smp 4 -accel hvf<br> -chardev stdio,id=con,mux=on -serial chardev:con<br> -global virtio-mmio.force-legacy=false<br> -drive file=./mydisk-1gb.img,if=none,format=raw,id=hd -device virtio-blk-device,drive=hd<br> -netdev user,id=u1,hostfwd=tcp:127.0.0.1:10023-10.0.2.15:23,hostfwd=tcp:127.0.0.1:15001-10.0.2.15:5001<br> -device virtio-net-device,netdev=u1,bus=virtio-mmio-bus.0<br> -mon chardev=con,mode=readline -kernel ./nuttx</p><p>3.5 Single Core /w kernel mode (GICv3) Configuring NuttX and compile: $ ./tools/configure.sh -l qemu-armv8a:knsh $ make $ make export V=1 $ pushd ../apps $ ./tools/mkimport.sh -z -x ../nuttx/nuttx-export-*.tar.gz $ make import V=1 $ popd</p><p>Running with qemu $ qemu-system-aarch64 -semihosting -cpu cortex-a53 -nographic<br> -machine virt,virtualization=on,gic-version=3<br> -net none -chardev stdio,id=con,mux=on -serial chardev:con<br> -mon chardev=con,mode=readline -kernel ./nuttx</p><h2 id="inter-vm-share-memory-device-ivshmem" tabindex="-1">Inter-VM share memory Device (ivshmem) <a class="header-anchor" href="#inter-vm-share-memory-device-ivshmem" aria-label="Permalink to &quot;Inter-VM share memory Device (ivshmem)&quot;">​</a></h2><p>Inter-VM shared memory support support can be found in <code>drivers/pci/pci_ivshmem.c</code>.</p><p>This implementation is for <code>ivshmem-v1</code> which is compatible with QEMU and ACRN hypervisor but won&#39;t work with Jailhouse hypervisor which uses <code>ivshmem-v2</code>.</p><p>Please refer to the official <code>Qemu ivshmem documentation &lt;https://www.qemu.org/docs/master/system/devices/ivshmem.html&gt;</code>_ for more information.</p><p>This is an example implementation for OpenAMP based on the Inter-VM share memory(ivshmem)::</p><p>rpproxy_ivshmem: Remote slave(client) proxy process. rpserver_ivshmem: Remote master(host) server process.</p><p>Steps for Using NuttX as IVSHMEM host and guest</p><ol><li>Build images</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- --&gt;</span></span></code></pre></div><p>a. Build rpserver_ivshmem::</p><pre><code>\\$ cmake -B server -DBOARD\\_CONFIG=qemu-armv8a:rpserver\\_ivshmem
-GNinja \\$ cmake --build server
</code></pre><p>b. Build rpproxy_ivshmem::</p><pre><code>\\$ cmake -B proxy -DBOARD\\_CONFIG=qemu-armv8a:rpproxy\\_ivshmem
-GNinja \\$ cmake --build proxy
</code></pre><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- --&gt;</span></span></code></pre></div><ol start="2"><li>Bringup firmware via Qemu:</li></ol><p>The Inter-VM Shared Memory device basic syntax is::</p><pre><code>  -device ivshmem-plain,id=shmem0,memdev=shmmem-shmem0,addr=0xb \\
  -object memory-backend-file,id=shmmem-shmem0,mem-path=/dev/shm/ivshmem0,size=4194304,share=yes
</code></pre><p>a. Start rpserver_ivshmem::</p><pre><code>\\$ qemu-system-aarch64 -cpu cortex-a53 -nographic -machine
virt,virtualization=on,gic-version=3 -kernel server/nuttx\\
-device ivshmem-plain,id=shmem0,memdev=shmmem-shmem0,addr=0xb\\
-object
memory-backend-file,id=shmmem-shmem0,mem-path=/dev/shm/ivshmem0,size=4194304,share=yes
</code></pre><p>b. Start rpproxy_ivshmem::</p><pre><code>\\$ qemu-system-aarch64 -cpu cortex-a53 -nographic -machine
virt,virtualization=on,gic-version=3 -kernel proxy/nuttx\\
-device ivshmem-plain,id=shmem0,memdev=shmmem-shmem0,addr=0xb\\
-object
memory-backend-file,discard-data=on,id=shmmem-shmem0,mem-path=/dev/shm/ivshmem0,size=4194304,share=yes
</code></pre><p>c. Check the RPMSG Syslog in rpserver shell:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- --&gt;</span></span></code></pre></div><pre><code>In the current configuration, the proxy syslog will be sent to the server by default.
You can check whether there is proxy startup log in the server shell.

RpServer bring up::

    $ qemu-system-aarch64 -cpu cortex-a53 -nographic -machine virt,virtualization=on,gic-version=3 -kernel server/nuttx \\
      -device ivshmem-plain,id=shmem0,memdev=shmmem-shmem0,addr=0xb \\
      -object memory-backend-file,id=shmmem-shmem0,mem-path=/dev/shm/ivshmem0,size=4194304,share=yes
    [    0.000000] [ 0] [  INFO] [server] pci_register_rptun_ivshmem_driver: Register ivshmem driver, id=0, cpuname=proxy, master=1
    ...
    [    0.033200] [ 3] [  INFO] [server] ivshmem_probe: shmem addr=0x10400000 size=4194304 reg=0x10008000
    [    0.033700] [ 3] [  INFO] [server] rptun_ivshmem_probe: shmem addr=0x10400000 size=4194304

After rpproxy bring up, check the log from rpserver::

    NuttShell (NSH) NuttX-10.4.0
    server&gt;
    [    0.000000] [ 0] [  INFO] [proxy] pci_register_rptun_ivshmem_driver: Register ivshmem driver, id=0, cpuname=server, master=0
    ...
    [    0.031400] [ 3] [  INFO] [proxy] ivshmem_probe: shmem addr=0x10400000 size=4194304 reg=0x10008000
    [    0.031800] [ 3] [  INFO] [proxy] rptun_ivshmem_probe: shmem addr=0x10400000 size=4194304
    [    0.033100] [ 3] [  INFO] [proxy] rptun_ivshmem_probe: Start the wdog
</code></pre><p>d. IPC test via RPMSG socket:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;!-- --&gt;</span></span></code></pre></div><pre><code>Start rpmsg socket server::

    server&gt; rpsock_server stream block test
    server: create socket SOCK_STREAM nonblock 0
    server: bind cpu , name test ...
    server: listen ...
    server: try accept ...
    server: Connection accepted -- 4
    server: try accept ...

Switch to proxy shell and start rpmsg socket client, test start::

    proxy&gt; rpsock_client stream block test server
    client: create socket SOCK_STREAM nonblock 0
    client: Connecting to server,test...
    client: Connected
    client send data, cnt 0, total len 64, BUFHEAD process0007, msg0000, name:test
    client recv data process0007, msg0000, name:test
    ...
    client recv done, total 4096000, endflags, send total 4096000
    client: Terminating

Check the log on rpserver shell::

    server recv data normal exit
    server Complete ret 0, errno 0
</code></pre><h1 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h1><p>2022-11-18: 1. Added support for GICv2.</p><ol start="2"><li>Added board configuration for nsh_gicv2.</li></ol><p>2022-10-13: 1. Renamed the board configuration name from qemu-a53 to qemu-v8a.</p><ol start="2"><li>Added the configurations for Cortex-A57 and Cortex-A72.</li></ol><p>2022-07-01:</p><ol><li>It&#39;s very stranger to see that signal testing of ostest is PASSED at Physical Ubuntu PC rather than an Ubuntu at VMWare. For Physical Ubuntu PC, I have run the ostest for 10 times at least but never see the crash again, but it&#39;s almost crashed every time running the ostest at Virtual Ubuntu in VMWare I check the fail point. It&#39;s seem at signal routine to access another CPU&#39;s task context reg will get a NULL pointer, but I watch the task context with GDB, everything is OK. So maybe this is a SMP cache synchronize issue? But I have done cache synchronize operation at thread switch and how to explain why the crash not happening at Physical Ubuntu PC? So maybe this is a qemu issue at VMWare. I am planning to run the arm64 to real hardware platform like IMX8 and will check the issue again</li></ol><p>2022-06-12:</p><ol><li>SMP is support at QEMU. Add psci interface, armv8 cache operation(data cache) and smccc support. The system can run into nsh shell, SMP test is PASSED, but ostest crash at signal testing</li></ol><p>2022-05-22: Arm64 support version for NuttX is Ready, These Features supported: 1.Cotex-a53 single core support: With the supporting of GICv3, Arch timer, PL101 UART, The system can run into nsh shell. Running ostest seem PASSED.</p><p>2.qemu-a53 board configuration support: qemu-a53 board can configuring and compiling, And running with qemu-system-aarch64 at Ubuntu 18.04. 3.FPU support for armv8-a: FPU context switching in NEON/floating-point TRAP was supported. FPU registers saving at vfork and independent FPU context for signal routine was considered but more testing needs to be do.</p><h1 id="platform-features" tabindex="-1">Platform Features <a class="header-anchor" href="#platform-features" aria-label="Permalink to &quot;Platform Features&quot;">​</a></h1><p>The following hardware features are supported: +--------------+------------+----------------------+ | Interface | Controller | Driver/Component | +==============+============+======================+ | GIC | on-chip | interrupt controller | +--------------+------------+----------------------+ | PL011 UART | on-chip | serial port | +--------------+------------+----------------------+ | ARM TIMER | on-chip | system clock | +--------------+------------+----------------------+</p><p>The kernel currently does not support other hardware features on this qemu platform.</p><h1 id="debugging-with-qemu" tabindex="-1">Debugging with QEMU <a class="header-anchor" href="#debugging-with-qemu" aria-label="Permalink to &quot;Debugging with QEMU&quot;">​</a></h1><p>The nuttx ELF image can be debugged with QEMU.</p><ol><li>To debug the nuttx (ELF) with symbols, make sure the following change have applied to defconfig.</li></ol><p>+CONFIG_DEBUG_SYMBOLS=y</p><ol start="2"><li><p>Run QEMU(at shell terminal 1)</p><p>Single Core $ qemu-system-aarch64 -cpu cortex-a53 -nographic -machine virt,virtualization=on,gic-version=3<br> -net none -chardev stdio,id=con,mux=on -serial chardev:con -mon chardev=con,mode=readline<br> -kernel ./nuttx -S -s SMP $ qemu-system-aarch64 -cpu cortex-a53 -smp 4 -nographic -machine virt,virtualization=on,gic-version=3<br> -net none -chardev stdio,id=con,mux=on -serial chardev:con -mon chardev=con,mode=readline<br> -kernel ./nuttx -S -s</p></li><li><p>Run gdb with TUI, connect to QEMU, load nuttx and continue (at shell terminal 2)</p><p>$ aarch64-none-elf-gdb -tui --eval-command=&#39;target remote localhost:1234&#39; nuttx (gdb) set debug aarch64 (gdb) c Continuing. ^C Program received signal SIGINT, Interrupt. arch_cpu_idle () at common/arm64_cpu_idle.S:37 (gdb) (gdb) where #0 arch_cpu_idle () at common/arm64_cpu_idle.S:37 #1 0x00000000402823ec in nx_start () at init/nx_start.c:742 #2 0x0000000040280148 in arm64_boot_primary_c_routine () at common/arm64_boot.c:184 #3 0x00000000402a5bf8 in switch_el () at common/arm64_head.S:201 (gdb)</p><p>SMP Case Thread 1 received signal SIGINT, Interrupt. arch_cpu_idle () at common/arm64_cpu_idle.S:37 (gdb) info threads Id Target Id Frame</p></li></ol><ul><li>1 Thread 1 (CPU#0 [halted ]) arch_cpu_idle () at common/arm64_cpu_idle.S:37 2 Thread 2 (CPU#1 [halted ]) arch_cpu_idle () at common/arm64_cpu_idle.S:37 3 Thread 3 (CPU#2 [halted ]) arch_cpu_idle () at common/arm64_cpu_idle.S:37 4 Thread 4 (CPU#3 [halted ]) arch_cpu_idle () at common/arm64_cpu_idle.S:37 (gdb)</li></ul><p>Note: 1. it will make your debugging more easier in source level if you setting CONFIG_DEBUG_FULLOPT=n. but there is a risk of stack overflow when the option is disabled. Just enlarging your stack size will avoid the issue (eg. enlarging CONFIG_DEFAULT_TASK_STACKSIZE) 2. TODO: ARMv8-A Supporting for tools/nuttx-gdbinit</p><h1 id="fpu-support-and-performance" tabindex="-1">FPU Support and Performance <a class="header-anchor" href="#fpu-support-and-performance" aria-label="Permalink to &quot;FPU Support and Performance&quot;">​</a></h1><p>I was using FPU trap to handle FPU context switch. For threads accessing the FPU (FPU instructions or registers), a trap will happen at this thread, the FPU context will be saved/restore for the thread at the trap handler. It will improve performance for thread switch since it&#39;s not to save/restore the FPU context (almost 512 bytes) at the thread switch anymore. But some issue need to be considered:</p><ol><li>Floating point argument passing issue In many cases, the FPU trap is triggered by va_start() that copies the content of FP registers used for floating point argument passing into the va_list object in case there were actual float arguments from the caller. adding -mgeneral-regs-only option will make compiler not use the FPU register, we can use the following patch to syslog:</li></ol><p>diff --git a/libs/libc/syslog/Make.defs b/libs/libc/syslog/Make.defs index c58fb45512..acac6febaa --- a/libs/libc/syslog/Make.defs +++ b/libs/libc/syslog/Make.defs @@ -26,3 +26,4 @@ CSRCS += lib_syslog.c lib_setlogmask.c</p><p>DEPPATH += --dep-path syslog VPATH += :syslog +syslog/lib_syslog.c_CFLAGS += -mgeneral-regs-only I cannot commit the patch for NuttX mainline because it&#39;s very special case since ostest is using syslog for lots of information printing. but this is a clue for FPU performance analysis. va_list object is using for many C code to handle argument passing, but if it&#39;s not passing floating point argument indeed. Add the option to your code maybe increase FPU performance</p><ol start="2"><li>memset/memcpy issue For improve performance, the memset/memcpy implement for libc will use the neon/fpu instruction/register. The FPU trap is also triggered in this case.</li></ol><p>we can trace this issue with Procfs:</p><p>nsh&gt; cat /proc/arm64fpu CPU0: save: 7 restore: 8 switch: 62 exedepth: 0 nsh&gt;</p><p>after ostest nsh&gt; cat /proc/arm64fpu CPU0: save: 1329 restore: 2262 switch: 4613 exedepth: 0 nsh&gt;</p><p>Note: save: the counts of save for task FPU context restore: the counts of restore for task FPU context switch: the counts of task switch</p><ol start="2"><li><p>FPU trap at IRQ handler it&#39;s probably need to handle FPU trap at IRQ routine. Exception_depth is handling for this case, it will inc/dec at enter/leave exception. If the exception_depth &gt; 1, that means an exception occurring when another exception is executing, the present implement is to switch FPU context to idle thread, it will handle most case for calling printf-like routine at IRQ routine. But in fact, this case will make uncertainty interrupt processing time sine it&#39;s uncertainty for trap exception handling. It would be best to add &quot;-mgeneral-regs-only&quot; option to compile the IRQ code avoiding accessing FP register. if it&#39;s necessarily for the exception routine to use FPU, calling function to save/restore FPU context directly maybe become a solution. Linux kernel introduce kernel_neon_begin/kernel_neon_end function for this case. Similar function will be add to NuttX if this issue need to be handle.</p></li><li><p>More reading for Linux kernel, please reference:</p></li></ol><ul><li><a href="https://www.kernel.org/doc/html/latest/arm/kernel%5C_mode%5C_neon.html" target="_blank" rel="noreferrer">https://www.kernel.org/doc/html/latest/arm/kernel\\_mode\\_neon.html</a></li></ul><h1 id="smp-support" tabindex="-1">SMP Support <a class="header-anchor" href="#smp-support" aria-label="Permalink to &quot;SMP Support&quot;">​</a></h1><ol><li><p>Booting Primary core call sequence arm64_start -&gt;arm64_boot_primary_c_routine -&gt;arm64_chip_boot -&gt;set init TBBR and Enable MMU -&gt;nx_start -&gt;OS component initialize -&gt;Initialize GIC: GICD and Primary core GICR -&gt;nx_smp_start for every CPU core -&gt;up_cpu_start -&gt;arm64_start_cpu(call PCSI to boot CPU) -&gt;waiting for every core to boot -&gt;nx_bringup</p><p>Secondary Core call sequence arm64_start -&gt;arm64_boot_secondary_c_routine -&gt;Enable MMU -&gt;Initialize GIC: Secondary core GICR -&gt;Notify Primary core booting is Ready -&gt;nx_idle_trampoline</p></li><li><p>interrupt</p></li></ol><p>SGI SGI_CPU_PAUSE: for core pause request, for every core</p><p>PPI ARM_ARCH_TIMER_IRQ: timer interrupt, handle by primary Core</p><p>SPI CONFIG_QEMU_UART_IRQ: serial driver interrupt, handle by primary Core</p><ol start="3"><li>Timer The origin design for ARMv8-A timer is assigned private timer to every PE(CPU core), the ARM_ARCH_TIMER_IRQ is a PPI so it&#39;s should be enabled at every core.</li></ol><p>But for NuttX, it&#39;s design only for primary core to handle timer interrupt and call nxsched_process_timer at timer tick mode. So we need only enable timer for primary core</p><p>IMX6 use GPT which is a SPI rather than generic timer to handle timer interrupt</p><h1 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h1><ol><li>(ID050815) ARM® Cortex®-A Series - Programmer&#39;s Guide for ARMv8-A</li><li>(ID020222) Arm® Architecture Reference Manual - for A profile architecture</li><li>(ARM062-948681440-3280) Armv8-A Instruction Set Architecture</li><li>AArch64 Exception and Interrupt Handling</li><li>AArch64 Programmer&#39;s Guides Generic Timer</li><li>Arm Generic Interrupt Controller v3 and v4 Overview</li><li>Arm® Generic Interrupt Controller Architecture Specification GIC architecture version 3 and version 4</li><li>(DEN0022D.b) Arm Power State Coordination Interface Platform Design Document</li></ol>`,91)]))}const u=t(a,[["render",o]]);export{p as __pageData,u as default};
