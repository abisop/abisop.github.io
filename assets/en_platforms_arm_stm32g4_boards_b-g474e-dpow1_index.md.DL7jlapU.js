import{_ as t,c as o,al as a,o as r}from"./chunks/framework.NFAqBSgQ.js";const c=JSON.parse('{"title":"ST B-G474E-DPOW1","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/stm32g4/boards/b-g474e-dpow1/index.md","filePath":"en/platforms/arm/stm32g4/boards/b-g474e-dpow1/index.md"}'),s={name:"en/platforms/arm/stm32g4/boards/b-g474e-dpow1/index.md"};function i(n,e,l,d,h,p){return r(),o("div",null,e[0]||(e[0]=[a(`<h1 id="st-b-g474e-dpow1" tabindex="-1">ST B-G474E-DPOW1 <a class="header-anchor" href="#st-b-g474e-dpow1" aria-label="Permalink to &quot;ST B-G474E-DPOW1&quot;">​</a></h1><p>chip:stm32, chip:stm32g4, chip:stm32g474</p><p>This page is for a port of NuttX to the ST Micro B-G474E-DPOW1 Discovery kit with STM32G474RE MCU. For more information about this board, see:</p><blockquote><p><a href="https://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-mpu-eval-tools/stm32-mcu-mpu-eval-tools/stm32-discovery-kits/b-g474e-dpow1.html" target="_blank" rel="noreferrer">https://www.st.com/content/st_com/en/products/evaluation-tools/product-evaluation-tools/mcu-mpu-eval-tools/stm32-mcu-mpu-eval-tools/stm32-discovery-kits/b-g474e-dpow1.html</a></p></blockquote><h2 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h2><p>This port boots NuttX through to a functional NSH prompt.</p><h2 id="development-environment" tabindex="-1">Development Environment <a class="header-anchor" href="#development-environment" aria-label="Permalink to &quot;Development Environment&quot;">​</a></h2><h3 id="toolchains" tabindex="-1">Toolchains <a class="header-anchor" href="#toolchains" aria-label="Permalink to &quot;Toolchains&quot;">​</a></h3><p>An appropriate ARM toolchain is needed, such as the one built with the customized NuttX buildroot or the ready-made GNU Tools for Arm Embedded Processors.</p><h3 id="debugging" tabindex="-1">Debugging <a class="header-anchor" href="#debugging" aria-label="Permalink to &quot;Debugging&quot;">​</a></h3><p>The board incorporates a STLINK-V3E programmer/debugger accessible via the Micro-USB Type B connector.</p><p>To debug with OpenOCD and arm-nuttx-eabi-gdb:</p><ul><li><p>Use &#39;make menuconfig&#39; to set CONFIG_DEBUG_SYMBOLS and CONFIG_DEBUG_NOOPT. To see debug output, e.g., the &quot;ABCDE&quot; printed in __start(), also set CONFIG_DEBUG_FEATURES.</p></li><li><p>Build NuttX.</p></li><li><p>Flash the code using:</p><pre><code> openocd -f interface/stlink.cfg -f target/stm32g4x.cfg -c init \\
-c &quot;reset halt&quot; -c &quot;flash write_image erase nuttx.bin 0x08000000&quot;
</code></pre></li></ul><p>NOTE: The above command might fail unless either: udev rules have been configured on the development system (preferred) or the command is run as root with &#39;sudo&#39; (not encouraged). See:</p><blockquote><ul><li><a href="https://openocd.org/doc/html/Running.html" target="_blank" rel="noreferrer">https://openocd.org/doc/html/Running.html</a></li><li><a href="https://forgge.github.io/theCore/guides/running-openocd-without-sudo.html" target="_blank" rel="noreferrer">https://forgge.github.io/theCore/guides/running-openocd-without-sudo.html</a></li></ul></blockquote><ul><li><p>Start GDB with:</p><pre><code> arm-nuttx-eabi-gdb -tui nuttx
</code></pre></li><li><p>In GDB:</p><pre><code>(gdb) target remote localhost:3333
(gdb) monitor reset halt
(gdb) load
</code></pre></li></ul><h2 id="hardware" tabindex="-1">Hardware <a class="header-anchor" href="#hardware" aria-label="Permalink to &quot;Hardware&quot;">​</a></h2><h3 id="mcu-clocking" tabindex="-1">MCU Clocking <a class="header-anchor" href="#mcu-clocking" aria-label="Permalink to &quot;MCU Clocking&quot;">​</a></h3><p>By default, the MCU on this board is clocked from the MCU&#39;s internal HSI clock, and only this option is supported by software at this time.</p><p>If software support is added for it, the MCU could be clocked from the following other sources: a 24 MHz oscillator on X2, MCO from STLINK-V3E, or external clock from connector CN9, pin 26.</p><h3 id="gpios" tabindex="-1">GPIOs <a class="header-anchor" href="#gpios" aria-label="Permalink to &quot;GPIOs&quot;">​</a></h3><h3 id="buttons" tabindex="-1">Buttons <a class="header-anchor" href="#buttons" aria-label="Permalink to &quot;Buttons&quot;">​</a></h3><p>The board has 5 user buttons in the form of a 4-direction &quot;joystick&quot; with a selection button (pressing down on the &quot;joystick&quot;).</p><h3 id="leds" tabindex="-1">LEDs <a class="header-anchor" href="#leds" aria-label="Permalink to &quot;LEDs&quot;">​</a></h3><p>The board has 4 user LEDs.</p><h3 id="rgb-power-led" tabindex="-1">RGB Power LED <a class="header-anchor" href="#rgb-power-led" aria-label="Permalink to &quot;RGB Power LED&quot;">​</a></h3><p>The board has a super bright RGB power LED.</p><p>Caution: For eye safety, ensure that the power LED is covered by the diffuser that comes installed over it.</p><h2 id="serial-consoles" tabindex="-1">Serial Consoles <a class="header-anchor" href="#serial-consoles" aria-label="Permalink to &quot;Serial Consoles&quot;">​</a></h2><p>The MCU&#39;s USART3 is connected to the on-board STLINK-V3E and exposed to the PC as a Virtual COM Port over the same Micro-USB Type B connection used for programming/debugging.</p><p>On Debian Linux, this shows up as /dev/ttyACM0. Other operating systems may differ.</p><h2 id="flash-bootloader-support" tabindex="-1">FLASH Bootloader Support <a class="header-anchor" href="#flash-bootloader-support" aria-label="Permalink to &quot;FLASH Bootloader Support&quot;">​</a></h2><p>If implementing a FLASH bootloader, turn on Kconfig option CONFIG_STM32_DFU. This option activates an alternate linker script, scripts/ld.script.dfu, which causes NuttX to leave a gap at the start of FLASH, leaving that space for the FLASH bootloader. See scripts/ld.script.dfu for details. It also causes NuttX to relocate its vector table and possibly make other adjustments.</p><p>One possible bootloader is STmicro&#39;s OpenBootloader &quot;middleware&quot; supplied with STM32CubeG4 version 1.3.0. On the host (PC), it should be possible to use STmicro&#39;s STM32CubeProgrammer or the stm32loader.py script from <a href="https://github.com/jsnyder/stm32loader" target="_blank" rel="noreferrer">https://github.com/jsnyder/stm32loader</a>. That script can be invoked with parameters such as:</p><pre><code>stm32loader.py -p /dev/ttyACM0 -a 0x08006000 -e -w -v -g 0x08006000 nuttx.bin
</code></pre><p>where the given address (0x08006000 in this case) must match the starting address in scripts/ld.script.dfu.</p>`,36)]))}const m=t(s,[["render",i]]);export{c as __pageData,m as default};
