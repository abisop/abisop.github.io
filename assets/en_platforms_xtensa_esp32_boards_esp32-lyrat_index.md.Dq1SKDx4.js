import{_ as t,c as o,al as a,o as n}from"./chunks/framework.NFAqBSgQ.js";const r="/assets/esp32-lyrat-v4.3-layout-with-wrover-e-module.C2KtL6mZ.jpg",i="/assets/esp32-lyrat-v4.3-electrical-block-diagram-with-wrover-e-module.BO0cW24Z.png",s="/assets/esp32-audio-config-file.BWOmnNZB.png",b=JSON.parse('{"title":"ESP32-LyraT V4.3","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/xtensa/esp32/boards/esp32-lyrat/index.md","filePath":"en/platforms/xtensa/esp32/boards/esp32-lyrat/index.md"}'),d={name:"en/platforms/xtensa/esp32/boards/esp32-lyrat/index.md"};function l(p,e,c,h,u,g){return n(),o("div",null,e[0]||(e[0]=[a('<h1 id="esp32-lyrat-v4-3" tabindex="-1">ESP32-LyraT V4.3 <a class="header-anchor" href="#esp32-lyrat-v4-3" aria-label="Permalink to &quot;ESP32-LyraT V4.3&quot;">​</a></h1><p>chip:esp32, chip:esp32wrover32</p><p>The ESP32-LyraT development board is a hardware platform designed for the dual-core ESP32 audio applications, e.g., Wi-Fi or BT audio speakers, speech-based remote controllers, smart-home appliances with audio functionality(ies), etc. You can find the board schematic <a href="https://dl.espressif.com/dl/schematics/ESP32-LYRAT_V4.3-20220119.pdf" target="_blank" rel="noreferrer">here</a>.</p><p><img src="'+r+`" alt="ESP32-LyraT V4.3 Board
Layout" class="align-center"></p><p>The block diagram below presents main components of the ESP32-LyraT.</p><p><img src="`+i+`" alt="ESP32-LyraT V4.3 Electrical Block
Diagram" class="align-center"></p><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h2><blockquote><ul><li>ESP32-WROVER-E Module</li><li>JTAG Interface</li><li>MicroSD Slot</li><li>Audio Codec Chip</li><li>Battery Charger Chip</li><li>Touch Pad Buttons</li></ul></blockquote><h2 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h2><p>UART0 is, by default, the serial console. It connects to the on-board CP2102N bridge and is available on the USB connector.</p><p>It will show up as /dev/ttyUSB[n] where [n] will probably be 0.</p><h2 id="buttons-and-leds" tabindex="-1">Buttons and LEDs <a class="header-anchor" href="#buttons-and-leds" aria-label="Permalink to &quot;Buttons and LEDs&quot;">​</a></h2><h3 id="board-buttons" tabindex="-1">Board Buttons <a class="header-anchor" href="#board-buttons" aria-label="Permalink to &quot;Board Buttons&quot;">​</a></h3><p>Two key labeled <em>Rec</em> and <em>Mode</em>. They are routed to <strong>ESP32-WROVER-E Module</strong> and intended for developing and testing a UI for audio applications using dedicated API.</p><p>Four touch pads labeled <em>Play</em>, <em>Sel</em>, <em>Vol+</em> and <em>Vol-</em>. They are routed to <strong>ESP32-WROVER-E Module</strong> and intended for development and testing of a UI for audio applications using dedicated API. <strong>They are currently not supported as the driver is in development.</strong></p><p>There are two buttons labeled Boot and EN. The EN button pulls the chip enable line that doubles as a reset line. The BOOT button is connected to IO0. On reset it is used as a strapping pin to determine whether the chip boots normally or into the serial bootloader.</p><p>Entering of the ESP32 into upload mode may be done in two ways:</p><ul><li>Manually by pressing both <strong>Boot</strong> and <strong>RST</strong> keys and then releasing first <strong>RST</strong> and then <strong>Boot</strong> key.</li><li>Automatically by software performing the upload. The software is using <strong>DTR</strong> and <strong>RTS</strong> signals of the serial interface to control states of <strong>EN</strong>, <strong>IO0</strong> and <strong>IO2</strong> pins of the ESP32. This functionality is enabled by installing jumpers in three headers <strong>JP23</strong>, <strong>JP24</strong> and <strong>JP25</strong>. Remove all jumpers after upload is complete.</li></ul><h3 id="board-leds" tabindex="-1">Board LEDs <a class="header-anchor" href="#board-leds" aria-label="Permalink to &quot;Board LEDs&quot;">​</a></h3><p>A general purpose green LED controlled by the <strong>ESP32-WROVER-E Module</strong> to indicate certain operation states of the audio application using dedicated API. It can also be used by the user for other purposes.</p><p>The <strong>Standby</strong> green LED indicates that power has been applied to the <strong>Micro USB Port</strong>. The <strong>Charging</strong> red LED indicates that a battery connected to the <strong>Battery Socket</strong> is being charged.</p><h2 id="audio-codec" tabindex="-1">Audio Codec <a class="header-anchor" href="#audio-codec" aria-label="Permalink to &quot;Audio Codec&quot;">​</a></h2><p><strong>This is currently unsupported. Drivers still in development.</strong></p><p>The Audio Codec Chip, <a href="http://www.everest-semi.com/pdf/ES8388%20DS.pdf" target="_blank" rel="noreferrer">ES8388</a>, is a low power stereo audio codec with a headphone amplifier. It consists of 2-channel ADC, 2-channel DAC, microphone amplifier, headphone amplifier , digital sound effects, analog mixing and gain functions. It is interfaced with <strong>ESP32-WROVER-E Module</strong> over I2S and I2S buses to provide audio processing in hardware independently from the audio application.</p><p>It also provides:</p><blockquote><ul><li>Onboard microphone connected to IN1 of the <strong>Audio Codec Chip</strong>.</li><li>Auxiliary input socket connected to IN2 (left and right channel) of the <strong>Audio Codec Chip</strong>. Use a 3.5 mm stereo jack to connect to this socket.</li><li>Output socket to connect headphones with a 3.5 mm stereo jack.</li></ul><p>Note</p><p>The socket may be used with mobile phone headsets and is compatible with OMPT standard headsets only. It does work with CTIA headsets. Please refer to <a href="https://en.wikipedia.org/wiki/Phone_connector_(audio)#TRRS_standards" target="_blank" rel="noreferrer">Phone connector (audio)</a> on Wikipedia.</p><ul><li>Output socket to connect a speaker. The 4-ohm and 3-watt speaker is recommended. The pins have a 2.00 mm / 0.08&quot; pitch.</li></ul></blockquote><p>The development board uses two mono Class D amplifier ICs, model number NS4150 with maximum output power of 3W and operating voltage from 3.0V to 5.25V. The audio input source is the digital-to-analog converter (DAC) output of the ES8388. Audio output supports two external speakers. An optional audio output is a pair of headphones feed from the same DACs as the amplifier ICs.</p><p>To switch between using headphones and speakers, the board provides a digital input signal to detect when a headphone jack is inserted and a digital output signal to enable or disable the amplifier ICs. In other words selection between speakers and headphones is under software control instead of using mechanical contacts that would disconnect speakers once a headphone jack is inserted.</p><p>Note</p><p>The codec implementation on the LyraT board was validated using 16-bit, 44.1kHz WAV files. Other configurations might not work as expected.</p><h2 id="sd-card" tabindex="-1">SD card <a class="header-anchor" href="#sd-card" aria-label="Permalink to &quot;SD card&quot;">​</a></h2><p>The development board supports a MicroSD card in SPI/1-bit/4-bit modes, and can store or play audio files in the MicroSD card. Note that <strong>JTAG</strong> cannot be used and should be disconnected by setting <strong>Function DIP Switch</strong> when <strong>MicroSD Card</strong> is in operation, because some of signals are shared by both devices.</p><h3 id="enable-microsd-card-in-1-wire-mode" tabindex="-1">Enable MicroSD Card in 1-wire Mode <a class="header-anchor" href="#enable-microsd-card-in-1-wire-mode" aria-label="Permalink to &quot;Enable MicroSD Card in 1-wire Mode&quot;">​</a></h3><p>Set <strong>Function DIP Switch</strong> to:</p><p>+---------+-----------------+ | DIP SW | Position | +=========+=================+ | &gt; 1 | &gt; OFF | +---------+-----------------+ | &gt; 2 | &gt; OFF | +---------+-----------------+ | &gt; 3 | &gt; OFF | +---------+-----------------+ | &gt; 4 | &gt; OFF | +---------+-----------------+ | &gt; 5 | &gt; OFF | +---------+-----------------+ | &gt; 6 | &gt; OFF | +---------+-----------------+ | &gt; 7 | &gt; OFF ^1^ | +---------+-----------------+ | &gt; 8 | &gt; n/a | +---------+-----------------+</p><ol><li><strong>AUX Input</strong> detection may be enabled by toggling the DIP SW 7 <em>ON</em>. Note that the <strong>AUX Input</strong> signal pin should not be be plugged in when the system powers up. Otherwise the ESP32 may not be able to boot correctly.</li></ol><p>In this mode:</p><ul><li><strong>JTAG</strong> functionality is not available</li><li><em>Vol-</em> touch button is available for use with the API</li></ul><h3 id="enable-microsd-card-in-4-wire-mode" tabindex="-1">Enable MicroSD Card in 4-wire Mode <a class="header-anchor" href="#enable-microsd-card-in-4-wire-mode" aria-label="Permalink to &quot;Enable MicroSD Card in 4-wire Mode&quot;">​</a></h3><p>Set <strong>Function DIP Switch</strong> to:</p><p>+---------+-----------+ | DIP SW | Position | +=========+===========+ | &gt; 1 | &gt; ON | +---------+-----------+ | &gt; 2 | &gt; ON | +---------+-----------+ | &gt; 3 | &gt; OFF | +---------+-----------+ | &gt; 4 | &gt; OFF | +---------+-----------+ | &gt; 5 | &gt; OFF | +---------+-----------+ | &gt; 6 | &gt; OFF | +---------+-----------+ | &gt; 7 | &gt; OFF | +---------+-----------+ | &gt; 8 | &gt; n/a | +---------+-----------+</p><p>In this mode:</p><ul><li><strong>JTAG</strong> functionality is not available</li><li><em>Vol-</em> touch button is not available for use with the API</li><li><strong>AUX Input</strong> detection from the API is not available</li></ul><h2 id="jtag" tabindex="-1">JTAG <a class="header-anchor" href="#jtag" aria-label="Permalink to &quot;JTAG&quot;">​</a></h2><p>Provides access to the <strong>JTAG</strong> interface of <strong>ESP32-WROVER-E Module</strong>. It may be used for debugging, application upload, as well as implementing several other functions.</p><h3 id="enable-jtag" tabindex="-1">Enable JTAG <a class="header-anchor" href="#enable-jtag" aria-label="Permalink to &quot;Enable JTAG&quot;">​</a></h3><p>Set <strong>Function DIP Switch</strong> to:</p><p>+---------+-----------+ | DIP SW | Position | +=========+===========+ | &gt; 1 | &gt; OFF | +---------+-----------+ | &gt; 2 | &gt; OFF | +---------+-----------+ | &gt; 3 | &gt; ON | +---------+-----------+ | &gt; 4 | &gt; ON | +---------+-----------+ | &gt; 5 | &gt; ON | +---------+-----------+ | &gt; 6 | &gt; ON | +---------+-----------+ | &gt; 7 | &gt; ON | +---------+-----------+ | &gt; 8 | &gt; n/a | +---------+-----------+</p><p>In this mode:</p><ul><li><strong>MicroSD Card</strong> functionality is not available, remove the card from the slot</li><li><em>Vol-</em> touch button is not available for use with the API</li><li><strong>AUX Input</strong> detection from the API is not available</li></ul><h2 id="battery" tabindex="-1">Battery <a class="header-anchor" href="#battery" aria-label="Permalink to &quot;Battery&quot;">​</a></h2><p>The board has a constant current &amp; constant voltage linear charger for single cell lithium-ion batteries AP5056. Used for charging of a battery connected to the <strong>Battery Socket</strong> over the <strong>Micro USB Port</strong>.</p><p>Note</p><p>Please verify if polarity on the battery plug matches polarity of the socket as marked on the board&#39;s soldermask besides the socket.</p><p>Note</p><p>The <strong>Power On Switch</strong> does not affect/disconnect the Li-ion battery charging.</p><h2 id="pin-mapping" tabindex="-1">Pin Mapping <a class="header-anchor" href="#pin-mapping" aria-label="Permalink to &quot;Pin Mapping&quot;">​</a></h2><p>Several pins ESP32 module are allocated to the on board hardware. Some of them, like GPIO0 or GPIO2, have multiple functions. Please refer to the table below.</p><hr><p>GPIO Pin Type Function Definition</p><hr><p>SENSOR_VP I Audio <strong>Rec</strong> (PB)</p><p>SENSOR_VN I Audio <strong>Mode</strong> (PB)</p><p>IO32 I/O Audio <strong>Set</strong> (TP)</p><p>IO33 I/O Audio <strong>Play</strong> (TP)</p><p>IO27 I/O Audio <strong>Vol+</strong> (TP)</p><p>IO13 I/O JTAG <strong>MTCK</strong>, MicroSD <strong>D3</strong>, Audio <strong>Vol-</strong> (TP)</p><p>IO14 I/O JTAG <strong>MTMS</strong>, MicroSD <strong>CLK</strong></p><p>IO12 I/O JTAG <strong>MTDI</strong>, MicroSD <strong>D2</strong>, Aux signal <strong>detect</strong></p><p>IO15 I/O JTAG <strong>MTDO</strong>, MicroSD <strong>CMD</strong></p><p>IO2 I/O Automatic Upload, MicroSD <strong>D0</strong></p><p>IO4 I/O MicroSD <strong>D1</strong></p><p>IO34 I MicroSD insert <strong>detect</strong></p><p>IO0 I/O Automatic Upload, I2S <strong>MCLK</strong></p><p>IO5 I/O I2S <strong>SCLK</strong></p><p>IO25 I/O I2S <strong>LRCK</strong></p><p>IO26 I/O I2S <strong>DSDIN</strong></p><p>IO35 I I2S <strong>ASDOUT</strong></p><p>IO19 I/O Headphone jack insert <strong>detect</strong></p><p>IO22 I/O Green LED indicator</p><p>IO21 I/O PA Enable output</p><p>IO18 I/O I2C <strong>SDA</strong></p><h2 id="io23-i-o-i2c-scl" tabindex="-1">IO23 I/O I2C <strong>SCL</strong> <a class="header-anchor" href="#io23-i-o-i2c-scl" aria-label="Permalink to &quot;IO23         I/O    I2C **SCL**&quot;">​</a></h2><ul><li>(TP) - touch pad</li><li>(PB) - push button</li></ul><p>There are several pin headers available to connect external components, check the state of particular signal bus or debug operation of ESP32. Note that some signals are shared.</p><h3 id="uart-header-jp2" tabindex="-1">UART Header / JP2 <a class="header-anchor" href="#uart-header-jp2" aria-label="Permalink to &quot;UART Header / JP2&quot;">​</a></h3><hr><pre><code>  Header Pin
</code></pre><hr><p>1 3.3V</p><p>2 TX</p><p>3 RX</p><h2 id="_4-gnd" tabindex="-1">4 GND <a class="header-anchor" href="#_4-gnd" aria-label="Permalink to &quot;4   GND&quot;">​</a></h2><h3 id="i2s-header-jp4" tabindex="-1">I2S Header / JP4 <a class="header-anchor" href="#i2s-header-jp4" aria-label="Permalink to &quot;I2S Header / JP4&quot;">​</a></h3><hr><pre><code>  I2C Header Pin   ESP32 Pin
</code></pre><hr><p>1 MCLK GPIO0</p><p>2 SCLK GPIO5</p><p>1 LRCK GPIO25</p><p>2 DSDIN GPIO26</p><p>3 ASDOUT GPIO35</p><h2 id="_3-gnd-gnd" tabindex="-1">3 GND GND <a class="header-anchor" href="#_3-gnd-gnd" aria-label="Permalink to &quot;3   GND              GND&quot;">​</a></h2><h3 id="i2c-header-jp5" tabindex="-1">I2C Header / JP5 <a class="header-anchor" href="#i2c-header-jp5" aria-label="Permalink to &quot;I2C Header / JP5&quot;">​</a></h3><hr><pre><code>  I2C Header Pin   ESP32 Pin
</code></pre><hr><p>1 SCL GPIO23</p><p>2 SDA GPIO18</p><h2 id="_3-gnd-gnd-1" tabindex="-1">3 GND GND <a class="header-anchor" href="#_3-gnd-gnd-1" aria-label="Permalink to &quot;3   GND              GND&quot;">​</a></h2><h3 id="jtag-header-jp7" tabindex="-1">JTAG Header / JP7 <a class="header-anchor" href="#jtag-header-jp7" aria-label="Permalink to &quot;JTAG Header / JP7&quot;">​</a></h3><hr><pre><code>  ESP32 Pin       JTAG Signal
</code></pre><hr><p>1 MTDO / GPIO15 TDO</p><p>2 MTCK / GPIO13 TCK</p><p>3 MTDI / GPIO12 TDI</p><h2 id="_4-mtms-gpio14-tms" tabindex="-1">4 MTMS / GPIO14 TMS <a class="header-anchor" href="#_4-mtms-gpio14-tms" aria-label="Permalink to &quot;4   MTMS / GPIO14   TMS&quot;">​</a></h2><p>Note</p><p><strong>JTAG</strong> cannot be used if <strong>MicroSD Card</strong> is enabled.</p><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><p>All of the configurations presented below can be tested by running the following commands:</p><pre><code> ./tools/configure.sh esp32-lyrat:&lt;config_name&gt;
 make flash ESPTOOL_PORT=/dev/ttyUSB0 -j
</code></pre><p>Where &lt;config_name&gt; is the name of board configuration you want to use, i.e.: nsh, buttons, wifi... Then use a serial console terminal like <code>picocom</code> configured to 115200 8N1.</p><h3 id="audio" tabindex="-1">audio <a class="header-anchor" href="#audio" aria-label="Permalink to &quot;audio&quot;">​</a></h3><p>This configuration uses the I2S0 peripheral and the ES8388 audio codec present on the LyraT board to play an audio file streamed over HTTP while connected to a Wi-Fi network.</p><p><strong>Simple HTTP server</strong></p><p>Prepare a PCM-encoded ([.wav]{.title-ref}) audio file with 16 bits/sample (sampled at 44.1kHz). This file must be placed into a folder in a computer that could be accessed on the same Wi-Fi network the ESP32 will be connecting to.</p><p>Python provides a simple HTTP server. [cd]{.title-ref} to the audio file folder on the PC and run:</p><pre><code> python3 -m http.server

Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/)
</code></pre><p>Look for your PC IP address and test playing the prepared audio on your browser:</p><p><img src="`+s+`" alt="" class="align-center"></p><p>After successfully built and flashed, connect the board to the Wi-Fi network:</p><pre><code> nsh&gt; wapi psk wlan0 mypasswd 3
 nsh&gt; wapi essid wlan0 myssid 1
 nsh&gt; renew wlan0
</code></pre><p>Once connected, open NuttX&#39;s player and play the file according to its file name and the IP address of the HTTP server (For example [tones.wav]{.title-ref} and [192.168.1.239:8000]{.title-ref}, respectively):</p><pre><code> nsh&gt; nxplayer
 nxplayer&gt; play http://192.168.1.239:8000/tones.wav
</code></pre><p>Note</p><p>The codec implementation on the LyraT board was validated using 16-bit, 44.1kHz WAV files. Other configurations might not work as expected.</p><h3 id="buttons" tabindex="-1">buttons <a class="header-anchor" href="#buttons" aria-label="Permalink to &quot;buttons&quot;">​</a></h3><p>This configuration shows the use of the buttons subsystem. It can be used by executing the <code>buttons</code> application and pressing on any of the available board buttons:</p><pre><code>nsh&gt; buttons
buttons_main: Starting the button_daemon
buttons_main: button_daemon started
button_daemon: Running
button_daemon: Opening /dev/buttons
button_daemon: Supported BUTTONs 0x01
nsh&gt; Sample = 1
Sample = 0
</code></pre><p>Note</p><p>The <code>BOOT</code> is connected to GPIO0 that is shared among some peripherals. To avoid any conflicts, it&#39;s not registered in the buttons subsystem and, thus, is unable to be used.</p><h3 id="mmcsdspi" tabindex="-1">mmcsdspi <a class="header-anchor" href="#mmcsdspi" aria-label="Permalink to &quot;mmcsdspi&quot;">​</a></h3><p>This configuration is used to mount a FAT/FAT32 SD Card into the OS&#39; filesystem. For the ESP32-LyraT, make sure the DIP switches 1 and 2 are turned to the ON position. To access the card&#39;s files, execute the following commands:</p><pre><code>nsh&gt; mount -t vfat /dev/mmcsd0 /mnt
nsh&gt; ls /mnt/
/mnt:
song_16_88200_2ch.wav
song_16_96000_2ch.wav
song_24_44100_2ch.wav
song_32_44100_2ch.wav
</code></pre><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>Basic NuttShell configuration (console enabled in UART0, exposed via USB connection by means of the CP2102N bridge, at 115200 bps).</p><h3 id="nxrecorder" tabindex="-1">nxrecorder <a class="header-anchor" href="#nxrecorder" aria-label="Permalink to &quot;nxrecorder&quot;">​</a></h3><p>This configuration is used to record raw audio from the the ES8388 audio codec through the I2S0 peripheral to a FAT32 SD Card. By default the audio is recorded from the on-board microphones. For the ESP32-LyraT, make sure the DIP switches 1 and 2 are turned to the ON position. To record audio, execute the following commands:</p><pre><code>nsh&gt; mount -t vfat /dev/mmcsd0 /mnt
nsh&gt; nxrecorder
nxrecorder&gt; recordraw /mnt/record.raw
nxrecorder&gt; stop
</code></pre><p>To play the recorded audio, import the raw data into Audacity and set the encoding to signed 16-bit PCM, the sample rate to 44.1kHz and the number of channels to 2.</p><h3 id="rtptools" tabindex="-1">rtptools <a class="header-anchor" href="#rtptools" aria-label="Permalink to &quot;rtptools&quot;">​</a></h3><p><strong>RTP Tools</strong> is a set of small applications that can be used for processing RTP data.</p><ul><li><code>rtpplay</code>: play back RTP sessions recorded by <code>rtpdump</code></li><li><code>rtpsend</code>: generate RTP packets from the textual description, generated by hand or <code>rtpdump</code></li><li><code>rtpdump</code>: parse and print RTP packets, generating output files suitable for <code>rtpplay</code> and <code>rtpsend</code></li><li><code>rtptrans</code>: RTP translator between unicast and multicast networks</li></ul><p>This application is able to receive RTP packets and write the content to a FIFO. <code>nxplayer</code> then reads from the FIFO, enabling using NuttX as a RTP receiver for audio applications.</p><p>This is particularly useful to stream uncompressed audio through Wi-Fi to remote speakers.</p><p><strong>Connect to your Network</strong></p><p>Connect the ESP32-LyraT board to your network in order to be able to receive RTP packets:</p><pre><code>nsh&gt; wapi psk wlan0 mypasswd 3
nsh&gt; wapi essid wlan0 myssid 1
nsh&gt; renew wlan0
nsh&gt; ifconfig
wlan0   Link encap:Ethernet HWaddr aa:bb:cc:dd:ff:ee at RUNNING mtu 1504
        inet addr:192.168.1.38 DRaddr:192.168.1.1 Mask:255.255.255.0

            IPv4   TCP   UDP  ICMP
Received     00d5  0000  00d4  0000
Dropped      0001  0000  0000  0000
IPv4        VHL: 0000   Frg: 0000
Checksum   0000  0000  0000  ----
TCP         ACK: 0000   SYN: 0000
            RST: 0000  0000
Type       0000  ----  ----  0000
Sent         0002  0000  0002  0000
Rexmit     ----  0000  ----  ----
</code></pre><p>Please, check your device&#39;s IP (<code>192.168.1.38</code> in this example): RTP packets will be sent to it.</p><p><strong>Sending Audio through pulseaudio</strong></p><p><code>pulseaudio</code> is able to send RTP packets through the network:</p><pre><code>pactl load-module module-null-sink sink_name=rtp format=s16be channels=2 rate=44100 sink_properties=&quot;device.description=&#39;RTP&#39;&quot;
pactl load-module module-rtp-send source=rtp.monitor format=s16le destination_ip=192.168.1.38 port=46998
</code></pre><p>The loaded sink is used to send PC audio through RTP, using the <code>192.168.1.38:46998</code> (boards&#39;s IP in this example, please adjust accordingly).</p><p><strong>Receiving the RTP packets</strong></p><p>RTP packets will be written to a FIFO: create the FIFO and run <code>rtpdump</code> on background:</p><pre><code>nsh&gt; mkfifo temp
nsh&gt; rtpdump -F payload -o temp /46998 &amp;
rtpdump [31:100]
</code></pre><p><strong>Playing Audio</strong></p><p>Finally, run <code>nxplayer</code> to play from the FIFO:</p><pre><code>nsh&gt; nxplayer
NxPlayer version 1.05
h for commands, q to exit

nxplayer&gt; playraw temp 2 16 44100
</code></pre><p>This board contains the ES8388 audio codec. Please attach your headphones to listen to the content streamed through the Wi-Fi in CD quality!</p><h3 id="wifi" tabindex="-1">wifi <a class="header-anchor" href="#wifi" aria-label="Permalink to &quot;wifi&quot;">​</a></h3><p>Enables Wi-Fi support. You can define your credentials this way:</p><pre><code> make menuconfig
-&gt; Application Configuration
    -&gt; Network Utilities
        -&gt; Network initialization (NETUTILS_NETINIT [=y])
            -&gt; WAPI Configuration
</code></pre><p>Or if you don&#39;t want to keep it saved in the firmware you can do it at runtime:</p><pre><code>nsh&gt; wapi psk wlan0 mypasswd 3
nsh&gt; wapi essid wlan0 myssid 1
nsh&gt; renew wlan0
</code></pre><p>Tip</p><p>Please refer to <code>ESP32 Wi-Fi Station Mode &lt;esp32_wi-fi_sta&gt;</code>{.interpreted-text role=&quot;ref&quot;} for more information.</p>`,179)]))}const f=t(d,[["render",l]]);export{b as __pageData,f as default};
