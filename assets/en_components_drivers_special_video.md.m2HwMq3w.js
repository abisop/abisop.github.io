import{_ as t,c as a,al as r,o}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Video Device Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/special/video.md","filePath":"en/components/drivers/special/video.md"}'),i={name:"en/components/drivers/special/video.md"};function s(l,e,n,d,c,h){return o(),a("div",null,e[0]||(e[0]=[r(`<h1 id="video-device-drivers" tabindex="-1">Video Device Drivers <a class="header-anchor" href="#video-device-drivers" aria-label="Permalink to &quot;Video Device Drivers&quot;">​</a></h1><ul><li><code>include/nuttx/video/</code>. All structures and APIs needed to work with video drivers are provided in this header file.</li></ul><h2 id="max7456" tabindex="-1">max7456 <a class="header-anchor" href="#max7456" aria-label="Permalink to &quot;max7456&quot;">​</a></h2><p>23 March 2019 Bill Gatliff &lt;<a href="mailto:bgat@billgatliff.com" target="_blank" rel="noreferrer">bgat@billgatliff.com</a>&gt;</p><p>The code in drivers/video/max7456.[ch] is a preliminary device driver for the MAX7456 analog on-screen-display generator. This SPI slave chip is a popular feature in many embedded devices due its low cost and power requirements. In particular, you see it a lot on drone flight-management units.</p><p>I use the term &quot;preliminary&quot; because at present, only the most rudimentary capabilities of the chip are supported:</p><blockquote><ul><li>chip reset and startup</li><li>read and write low-level chip control registers (DEBUG mode only)</li><li>write CA (Character Address) data to the chip&#39;s framebuffer memory</li></ul></blockquote><p>Some key missing features are, in no particular order:</p><blockquote><ul><li>VSYNC and HSYNC synchronization (prevents flicker)</li><li>ability to update NVM (define custom character sets)</li></ul></blockquote><p>If you have a factory-fresh chip, then the datasheet shows you what the factory character data set looks like. If you&#39;ve used the chip in other scenarios, i.e. with Betaflight or similar, then your chip will almost certainly have had the factory character data replaced with something application-specific.</p><p>Either way, you&#39;ll probably want to update your character set before long. I should probably get that working, unless you want to take a look at it yoruself...</p><p>The max7456_register() function starts things rolling. The omnibusf4 target device provides an example (there may be others by the time you read this).</p><p>In normal use, the driver creates a set of interfaces under /dev, i.e.:</p><pre><code>/dev/osd0/fb
/dev/osd0/raw   (*)
/dev/osd0/vsync (*)
</code></pre><ul><li><ul><li>not yet implemented</li></ul></li></ul><p>By writing character data to the &quot;fb&quot; interface, you&#39;ll see data appear on the display. NOTE that the data you write is NOT, for example, ASCII text: it is the addresses of the characters in the chip&#39;s onboard character map.</p><p>For example, if entry 42 in your onboard character map is a bitmap that looks like &quot;H&quot;, then when you write the ASCII &quot;*&quot; (decimal 42, hex 2a), you&#39;ll see that &quot;H&quot; appear on your screen.</p><p>If you build the code with the DEBUG macro defined, you will see a bunch more interfaces:</p><pre><code>/dev/osd0/VM0
/dev/osd0/VM1
/dev/osd/DMM
...
...
</code></pre><p>These are interfaces to the low-level chip registers, which can be read and/or written to help you figure out what&#39;s going on inside the chip. They&#39;re probably more useful for me than you, but there they are in case I&#39;m wrong about that.</p><p>b.g.</p>`,21)]))}const m=t(i,[["render",s]]);export{u as __pageData,m as default};
