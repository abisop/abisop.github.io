import{_ as t,c as i,al as o,o as a}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"Host Side Tools","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/tools/index.md","filePath":"en/applications/tools/index.md"}'),s={name:"en/applications/tools/index.md"};function n(r,e,l,d,p,c){return a(),i("div",null,e[0]||(e[0]=[o('<h1 id="host-side-tools" tabindex="-1">Host Side Tools <a class="header-anchor" href="#host-side-tools" aria-label="Permalink to &quot;Host Side Tools&quot;">​</a></h1><h2 id="bitmap-converter-py-nxwidgets" tabindex="-1"><code>bitmap_converter.py</code> NxWidgets <a class="header-anchor" href="#bitmap-converter-py-nxwidgets" aria-label="Permalink to &quot;`bitmap_converter.py` NxWidgets&quot;">​</a></h2><p>This script converts from any image type supported by Python imaging library to the RLE-encoded format used by NxWidgets.</p><p>RLE (Run Length Encoding) is a very simply encoding that compress quite well with certain kinds of images: Images that that have many pixels of the same color adjacent on a row (like simple graphics). It does not work well with photographic images.</p><p>But even simple graphics may not encode compactly if, for example, they have been resized. Resizing an image can create hundreds of unique colors that may differ by only a bit or two in the RGB representation. This &quot;color smear&quot; is the result of pixel interpolation (and might be eliminated if your graphics software supports resizing via pixel replication instead of interpolation).</p><p>When a simple graphics image does not encode well, the symptom is that the resulting RLE data structures are quite large. The palette structure, in particular, may have hundreds of colors in it. There is a way to fix the graphic image in this case. Here is what I do (in fact, I do this on all images prior to conversion just to be certain):</p><ul><li>Open the original image in GIMP.</li><li>Select the option to select the number of colors in the image.</li><li>Pick the smallest number of colors that will represent the image faithfully. For most simple graphic images this might be as few as 6 or 8 colors.</li><li>Save the image as PNG or other lossless format (NOT jpeg).</li><li>Then generate the image.</li></ul><h2 id="mkromfsimg-sh" tabindex="-1"><code>mkromfsimg.sh</code> <a class="header-anchor" href="#mkromfsimg-sh" aria-label="Permalink to &quot;`mkromfsimg.sh`&quot;">​</a></h2><p><strong>Q</strong>: Why are there two versions of the script <code>mkromfsimg.sh</code>, one in <code>apps/tools</code> and one in <code>nuttx/tools</code>.</p><p><strong>A</strong>: The version of <code>mkromfsimg.sh</code> in <code>nuttx/tools</code> is a generic tool to simplify creation of ROMFS file system from any directory contain content that you would like to access within the the target.</p><p>The version in <code>apps/tools</code>, on the other hand, has a very special purpose. It is part of the support that can be used in the KERNEL build mode.</p><h3 id="processes-and-programs-in-the-kernel-build" tabindex="-1">Processes and Programs in the KERNEL Build <a class="header-anchor" href="#processes-and-programs-in-the-kernel-build" aria-label="Permalink to &quot;Processes and Programs in the KERNEL Build&quot;">​</a></h3><p>In the kernel build, there are no tasks. There are only processes and all code lives in its own, private address space. See [[/implementation/proce](]{.title-ref}/implementation/proce.md)sses_vs_tasks`.</p><p>One consequence of that is that functions like <code>task_create()</code> and friends cannot be used in the KERNEL build mode. Instead, all processes must be loaded into a virtual address space from an ELF or NxFLAT file residing in the file system. ROMFS is one of many file system, but one that is particularly usable for this purpose in deeply embedded systems.</p><h3 id="kernel-build-differences" tabindex="-1">KERNEL Build Differences <a class="header-anchor" href="#kernel-build-differences" aria-label="Permalink to &quot;KERNEL Build Differences&quot;">​</a></h3><p>In the FLAT and PROTECTED build mode all applications are built into a single BLOB, so every symbol must have a unique name to avoid name collisions.</p><p>In the KERNEL build mode, all applications are built at separately linked programs that reside in a file system. The entry point to ALL programs is the function <code>main()</code>.</p><h3 id="apps-bin" tabindex="-1">apps/bin <a class="header-anchor" href="#apps-bin" aria-label="Permalink to &quot;apps/bin&quot;">​</a></h3><p>When you build the <code>apps/</code> programs in FLAT or PROTECTED modes, all of the object files are put into an archive apps/libapps.a which is, eventually, copied to <code>nuttx/libs</code> and the BLOB is created by linking NuttX archives with <code>lib/libapps.a</code>.</p><p>But when you build the <code>apps/</code> programs in the KERNEL mode, the directory <code>apps/bin</code> is created by the top-level apps/Makefile. Each source file is compiled, but the object files are not added to ayn archive. Instead, the object files are linked into a separate compiled and linked program. Each program is then installed at <code>apps/bin</code>.</p><h3 id="apps-tools-mkromfsimg-sh" tabindex="-1">apps/tools/mkromfsimg.sh <a class="header-anchor" href="#apps-tools-mkromfsimg-sh" aria-label="Permalink to &quot;apps/tools/mkromfsimg.sh&quot;">​</a></h3><p>When the <code>apps/</code> kernel build is complete, all of the programs have been installed in <code>apps/bin</code>. That is where <code>apps/tools/mkromfsimg.sh</code> file comes into to play. It takes all of the programs in apps/bin and creates a ROMFS file system image containing all of the applications. That ROMFS file system image is built into the kernel.</p><h3 id="application-initialization" tabindex="-1">Application Initialization <a class="header-anchor" href="#application-initialization" aria-label="Permalink to &quot;Application Initialization&quot;">​</a></h3><p>At run time, when the kernel boots, it will mount that ROMFS file system at <code>/bin</code>. In the FLAT build mode, the OS boot logic calls <code>task_create()</code> to start the initial task you have configured with <code>CONFIG_INIT_ENTRYPOINT</code>. But in the KERNEL build, something different happens. <code>CONFIG_INIT_ENTRYPOINT</code> is not used. Instead, <code>CONFIG_INIT_FILEPATH</code> is used. This will be the name of the program to stared in <code>/bin</code> to bring up the system.</p>',24)]))}const u=t(s,[["render",n]]);export{m as __pageData,u as default};
