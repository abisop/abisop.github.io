import{_ as t,c as p,al as e,j as s,a as n,o as i}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"File System Interfaces","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/user/10_filesystem.md","filePath":"en/reference/user/10_filesystem.md"}'),l={name:"en/reference/user/10_filesystem.md"};function o(c,a,r,d,h,m){return i(),p("div",null,a[0]||(a[0]=[e('<h1 id="file-system-interfaces" tabindex="-1">File System Interfaces <a class="header-anchor" href="#file-system-interfaces" aria-label="Permalink to &quot;File System Interfaces&quot;">​</a></h1><h2 id="nuttx-file-system-overview" tabindex="-1">NuttX File System Overview <a class="header-anchor" href="#nuttx-file-system-overview" aria-label="Permalink to &quot;NuttX File System Overview&quot;">​</a></h2><p><strong>Overview</strong>. NuttX includes an optional, scalable file system. This file-system may be omitted altogether; NuttX does not depend on the presence of any file system.</p><p><strong>Pseudo Root File System</strong>. A simple <em>in-memory</em>, <em>pseudo</em> file system can be enabled by default. This is an <em>in-memory</em> file system because it does not require any storage medium or block driver support. Rather, file system contents are generated on-the-fly as referenced via standard file system operations (open, close, read, write, etc.). In this sense, the file system is <em>pseudo</em> file system (in the same sense that the Linux <code>/proc</code> file system is also referred to as a pseudo file system).</p>',4),s("p",null,[n("Any user supplied data or logic can be accessed via the pseudo-file system. Built in support is provided for character and block "),s("code",{class:"interpreted-text",role:"ref"},"driver <drivers-porting>"),n(),s("em",null,"nodes"),n(" in the any pseudo file system directory. (By convention, however, all driver nodes should be in the "),s("code",null,"/dev"),n(" pseudo file system directory).")],-1),e(`<p><strong>Mounted File Systems</strong> The simple in-memory file system can be extended my mounting block devices that provide access to true file systems backed up via some mass storage device. NuttX supports the standard <code>mount()</code> command that allows a block driver to be bound to a mount-point within the pseudo file system and to a a file system. At present, NuttX supports only the VFAT file system.</p><p><strong>Comparison to Linux</strong> From a programming perspective, the NuttX file system appears very similar to a Linux file system. However, there is a fundamental difference: The NuttX root file system is a pseudo file system and true file systems may be mounted in the pseudo file system. In the typical Linux installation by comparison, the Linux root file system is a true file system and pseudo file systems may be mounted in the true, root file system. The approach selected by NuttX is intended to support greater scalability from the very tiny platform to the moderate platform.</p><p><strong>File System Interfaces</strong>. The NuttX file system simply supports a set of standard, file system APIs (<code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write</code>, etc.) and a registration mechanism that allows devices drivers to a associated with <em>nodes</em> in a file-system-like name space.</p><h2 id="driver-operations" tabindex="-1">Driver Operations <a class="header-anchor" href="#driver-operations" aria-label="Permalink to &quot;Driver Operations&quot;">​</a></h2><h3 id="fcntl-h" tabindex="-1"><code>fcntl.h</code> <a class="header-anchor" href="#fcntl-h" aria-label="Permalink to &quot;\`fcntl.h\`&quot;">​</a></h3><h3 id="unistd-h" tabindex="-1"><code>unistd.h</code> <a class="header-anchor" href="#unistd-h" aria-label="Permalink to &quot;\`unistd.h\`&quot;">​</a></h3><h3 id="sys-ioctl-h" tabindex="-1"><code>sys/ioctl.h</code> <a class="header-anchor" href="#sys-ioctl-h" aria-label="Permalink to &quot;\`sys/ioctl.h\`&quot;">​</a></h3><h3 id="poll-h" tabindex="-1"><code>poll.h</code> <a class="header-anchor" href="#poll-h" aria-label="Permalink to &quot;\`poll.h\`&quot;">​</a></h3><h3 id="sys-select-h" tabindex="-1"><code>sys/select.h</code> <a class="header-anchor" href="#sys-select-h" aria-label="Permalink to &quot;\`sys/select.h\`&quot;">​</a></h3><h3 id="directory-operations-dirent-h" tabindex="-1">Directory Operations (<code>dirent.h</code>) <a class="header-anchor" href="#directory-operations-dirent-h" aria-label="Permalink to &quot;Directory Operations (\`dirent.h\`)&quot;">​</a></h3><h3 id="unix-standard-operations-unistd-h" tabindex="-1">UNIX Standard Operations (<code>unistd.h</code>) <a class="header-anchor" href="#unix-standard-operations-unistd-h" aria-label="Permalink to &quot;UNIX Standard Operations (\`unistd.h\`)&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;unistd.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Task Control Interfaces */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>pid_t   vfork(void);</span></span>
<span class="line"><span>pid_t   getpid(void);</span></span>
<span class="line"><span>void    _exit(int status) noreturn_function;</span></span>
<span class="line"><span>unsigned int sleep(unsigned int seconds);</span></span>
<span class="line"><span>void    usleep(unsigned long usec);</span></span>
<span class="line"><span>int     pause(void);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* File descriptor operations */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int     close(int fd);</span></span>
<span class="line"><span>int     dup(int fd);</span></span>
<span class="line"><span>int     dup2(int fd1, int fd2);</span></span>
<span class="line"><span>int     fsync(int fd);</span></span>
<span class="line"><span>off_t   lseek(int fd, off_t offset, int whence);</span></span>
<span class="line"><span>ssize_t read(int fd, FAR void *buf, size_t nbytes);</span></span>
<span class="line"><span>ssize_t write(int fd, FAR const void *buf, size_t nbytes);</span></span>
<span class="line"><span>ssize_t pread(int fd, FAR void *buf, size_t nbytes, off_t offset);</span></span>
<span class="line"><span>ssize_t pwrite(int fd, FAR const void *buf, size_t nbytes, off_t offset);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Check if a file descriptor corresponds to a terminal I/O file */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int     isatty(int fd);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Memory management */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if defined(CONFIG_ARCH_ADDRENV) &amp;&amp; defined(CONFIG_MM_PGALLOC) &amp;&amp; \\</span></span>
<span class="line"><span>    defined(CONFIG_ARCH_USE_MMU)</span></span>
<span class="line"><span>FAR void *sbrk(intptr_t incr);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Special devices */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int     pipe(int fd[2]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Working directory operations */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int     chdir(FAR const char *path);</span></span>
<span class="line"><span>FAR char *getcwd(FAR char *buf, size_t size);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* File path operations */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int     access(FAR const char *path, int amode);</span></span>
<span class="line"><span>int     rmdir(FAR const char *pathname);</span></span>
<span class="line"><span>int     unlink(FAR const char *pathname);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef CONFIG_PSEUDOFS_SOFTLINKS</span></span>
<span class="line"><span>int     link(FAR const char *path1, FAR const char *path2);</span></span>
<span class="line"><span>ssize_t readlink(FAR const char *path, FAR char *buf, size_t bufsize);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Execution of programs from files */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef CONFIG_LIBC_EXECFUNCS</span></span>
<span class="line"><span>int     execl(FAR const char *path, ...);</span></span>
<span class="line"><span>int     execv(FAR const char *path, FAR char * const argv[]);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Networking */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef CONFIG_NET</span></span>
<span class="line"><span>int     gethostname(FAR char *name, size_t size);</span></span>
<span class="line"><span>int     sethostname(FAR const char *name, size_t size);</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Other */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int     getopt(int argc, FAR char * const argv[], FAR const char *optstring);</span></span></code></pre></div><h3 id="standard-i-o" tabindex="-1">Standard I/O <a class="header-anchor" href="#standard-i-o" aria-label="Permalink to &quot;Standard I/O&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;stdio.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Operations on streams (FILE) */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void   clearerr(FAR FILE *stream);</span></span>
<span class="line"><span>int    fclose(FAR FILE *stream);</span></span>
<span class="line"><span>int    fflush(FAR FILE *stream);</span></span>
<span class="line"><span>int    feof(FAR FILE *stream);</span></span>
<span class="line"><span>int    ferror(FAR FILE *stream);</span></span>
<span class="line"><span>int    fileno(FAR FILE *stream);</span></span>
<span class="line"><span>int    fgetc(FAR FILE *stream);</span></span>
<span class="line"><span>int    fgetpos(FAR FILE *stream, FAR fpos_t *pos);</span></span>
<span class="line"><span>FAR char *fgets(FAR char *s, int n, FAR FILE *stream);</span></span>
<span class="line"><span>void   flockfile(FAR FILE *stream);</span></span>
<span class="line"><span>FAR FILE *fopen(FAR const char *path, FAR const char *type);</span></span>
<span class="line"><span>int    fprintf(FAR FILE *stream, FAR const char *format, ...);</span></span>
<span class="line"><span>int    fputc(int c, FAR FILE *stream);</span></span>
<span class="line"><span>int    fputs(FAR const char *s, FAR FILE *stream);</span></span>
<span class="line"><span>size_t fread(FAR void *ptr, size_t size, size_t n_items, FAR FILE *stream);</span></span>
<span class="line"><span>FAR FILE *freopen(FAR const char *path, FAR const char *mode,</span></span>
<span class="line"><span>         FAR FILE *stream);</span></span>
<span class="line"><span>int    fseek(FAR FILE *stream, long int offset, int whence);</span></span>
<span class="line"><span>int    fsetpos(FAR FILE *stream, FAR fpos_t *pos);</span></span>
<span class="line"><span>long   ftell(FAR FILE *stream);</span></span>
<span class="line"><span>int    ftrylockfile(FAR FILE *stream);</span></span>
<span class="line"><span>void   funlockfile(FAR FILE *stream);</span></span>
<span class="line"><span>size_t fwrite(FAR const void *ptr, size_t size, size_t n_items, FAR FILE *stream);</span></span>
<span class="line"><span>FAR char *gets(FAR char *s);</span></span>
<span class="line"><span>FAR char *gets_s(FAR char *s, rsize_t n);</span></span>
<span class="line"><span>void   setbuf(FAR FILE *stream, FAR char *buf);</span></span>
<span class="line"><span>int    setvbuf(FAR FILE *stream, FAR char *buffer, int mode, size_t size);</span></span>
<span class="line"><span>int    ungetc(int c, FAR FILE *stream);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Operations on the stdout stream, buffers, paths, and the whole printf-family *    /</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int    printf(FAR const char *format, ...);</span></span>
<span class="line"><span>int    puts(FAR const char *s);</span></span>
<span class="line"><span>int    rename(FAR const char *source, FAR const char *target);</span></span>
<span class="line"><span>int    sprintf(FAR char *dest, FAR const char *format, ...);</span></span>
<span class="line"><span>int    asprintf(FAR char **ptr, FAR const char *fmt, ...);</span></span>
<span class="line"><span>int    snprintf(FAR char *buf, size_t size, FAR const char *format, ...);</span></span>
<span class="line"><span>int    sscanf(FAR const char *buf, FAR const char *fmt, ...);</span></span>
<span class="line"><span>void   perror(FAR const char *s);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int    vprintf(FAR const char *s, va_list ap);</span></span>
<span class="line"><span>int    vfprintf(FAR FILE *stream, FAR const char *s, va_list ap);</span></span>
<span class="line"><span>int    vsprintf(FAR char *buf, FAR const char *s, va_list ap);</span></span>
<span class="line"><span>int    vasprintf(FAR char **ptr, FAR const char *fmt, va_list ap);</span></span>
<span class="line"><span>int    vsnprintf(FAR char *buf, size_t size, FAR const char *format, va_list ap);</span></span>
<span class="line"><span>int    vsscanf(FAR char *buf, FAR const char *s, va_list ap);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Operations on file descriptors including:</span></span>
<span class="line"><span> *</span></span>
<span class="line"><span> * POSIX-like File System Interfaces (fdopen), and</span></span>
<span class="line"><span> * Extensions from the Open Group Technical Standard, 2006, Extended API Set</span></span>
<span class="line"><span> *   Part 1 (dprintf and vdprintf)</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>FAR FILE *fdopen(int fd, FAR const char *type);</span></span>
<span class="line"><span>int    dprintf(int fd, FAR const char *fmt, ...);</span></span>
<span class="line"><span>int    vdprintf(int fd, FAR const char *fmt, va_list ap);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>/* Operations on paths */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>FAR char *tmpnam(FAR char *s);</span></span>
<span class="line"><span>FAR char *tempnam(FAR const char *dir, FAR const char *pfx);</span></span>
<span class="line"><span>int       remove(FAR const char *path);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#include &lt;sys/stat.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int mkdir(FAR const char *pathname, mode_t mode);</span></span>
<span class="line"><span>int mkfifo(FAR const char *pathname, mode_t mode);</span></span>
<span class="line"><span>int stat(FAR const char *path, FAR struct stat *buf);</span></span>
<span class="line"><span>int fstat(int fd, FAR struct stat *buf);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#include &lt;sys/statfs.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int statfs(FAR const char *path, FAR struct statfs *buf);</span></span>
<span class="line"><span>int fstatfs(int fd, FAR struct statfs *buf);</span></span></code></pre></div><h3 id="standard-library-stdlib-h" tabindex="-1">Standard Library (<code>stdlib.h</code>) <a class="header-anchor" href="#standard-library-stdlib-h" aria-label="Permalink to &quot;Standard Library (\`stdlib.h\`)&quot;">​</a></h3><p>Generally addresses other operating system interfaces. However, the following may also be considered as file system interfaces:</p><h3 id="asynchronous-i-o" tabindex="-1">Asynchronous I/O <a class="header-anchor" href="#asynchronous-i-o" aria-label="Permalink to &quot;Asynchronous I/O&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;aio.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int aio_cancel(int, FAR struct aiocb *aiocbp);</span></span>
<span class="line"><span>int aio_error(FAR const struct aiocb *aiocbp);</span></span>
<span class="line"><span>int aio_fsync(int, FAR struct aiocb *aiocbp);</span></span>
<span class="line"><span>int aio_read(FAR struct aiocb *aiocbp);</span></span>
<span class="line"><span>ssize_t aio_return(FAR struct aiocb *aiocbp);</span></span>
<span class="line"><span>int aio_suspend(FAR const struct aiocb * const list[], int nent,</span></span>
<span class="line"><span>                FAR const struct timespec *timeout);</span></span>
<span class="line"><span>int aio_write(FAR struct aiocb *aiocbp);</span></span>
<span class="line"><span>int lio_listio(int mode, FAR struct aiocb * const list[], int nent,</span></span>
<span class="line"><span>               FAR struct sigevent *sig);</span></span></code></pre></div><h3 id="standard-string-operations" tabindex="-1">Standard String Operations <a class="header-anchor" href="#standard-string-operations" aria-label="Permalink to &quot;Standard String Operations&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;string.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>char  *strchr(const char *s, int c);</span></span>
<span class="line"><span>FAR char *strdup(const char *s);</span></span>
<span class="line"><span>const char *strerror(int);</span></span>
<span class="line"><span>size_t strlen(const char *);</span></span>
<span class="line"><span>size_t strnlen(const char *, size_t);</span></span>
<span class="line"><span>char  *strcat(char *, const char *);</span></span>
<span class="line"><span>char  *strncat(char *, const char *, size_t);</span></span>
<span class="line"><span>int    strcmp(const char *, const char *);</span></span>
<span class="line"><span>int    strncmp(const char *, const char *, size_t);</span></span>
<span class="line"><span>int    strcasecmp(const char *, const char *);</span></span>
<span class="line"><span>int    strncasecmp(const char *, const char *, size_t);</span></span>
<span class="line"><span>char  *strcpy(char *dest, const char *src);</span></span>
<span class="line"><span>char  *strncpy(char *, const char *, size_t);</span></span>
<span class="line"><span>char  *strpbrk(const char *, const char *);</span></span>
<span class="line"><span>char  *strchr(const char *, int);</span></span>
<span class="line"><span>char  *strrchr(const char *, int);</span></span>
<span class="line"><span>size_t strspn(const char *, const char *);</span></span>
<span class="line"><span>size_t strcspn(const char *, const char *);</span></span>
<span class="line"><span>char  *strstr(const char *, const char *);</span></span>
<span class="line"><span>char  *strtok(char *, const char *);</span></span>
<span class="line"><span>char  *strtok_r(char *, const char *, char **);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void  *memset(void *s, int c, size_t n);</span></span>
<span class="line"><span>void  *memcpy(void *dest, const void *src, size_t n);</span></span>
<span class="line"><span>int    memcmp(const void *s1, const void *s2, size_t n);</span></span>
<span class="line"><span>void  *memmove(void *dest, const void *src, size_t count);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#include &lt;strings.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#define bcmp(b1,b2,len)  memcmp(b1,b2,(size_t)len)</span></span>
<span class="line"><span>#define bcopy(b1,b2,len) memmove(b2,b1,len)</span></span>
<span class="line"><span>#define bzero(s,n)       memset(s,0,n)</span></span>
<span class="line"><span>#define index(s,c)       strchr(s,c)</span></span>
<span class="line"><span>#define rindex(s,c)      strrchr(s,c)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int    ffs(int j);</span></span>
<span class="line"><span>int    strcasecmp(const char *, const char *);</span></span>
<span class="line"><span>int    strncasecmp(const char *, const char *, size_t);</span></span></code></pre></div><h3 id="pipes-and-fifos" tabindex="-1">Pipes and FIFOs <a class="header-anchor" href="#pipes-and-fifos" aria-label="Permalink to &quot;Pipes and FIFOs&quot;">​</a></h3><h3 id="mmap-and-execute-in-place-xip" tabindex="-1"><code>mmap()</code> and eXecute In Place (XIP) <a class="header-anchor" href="#mmap-and-execute-in-place-xip" aria-label="Permalink to &quot;\`mmap()\` and eXecute In Place (XIP)&quot;">​</a></h3><p>NuttX operates in a flat open address space and is focused on MCUs that do support Memory Management Units (MMUs). Therefore, NuttX generally does not require <code>mmap()</code> functionality and the MCUs generally cannot support true memory-mapped files.</p><p>However, memory mapping of files is the mechanism used by NXFLAT, the NuttX tiny binary format, to get files into memory in order to execute them. <code>mmap()</code> support is therefore required to support NXFLAT. There are two conditions where <code>mmap()</code> can be supported:</p><ol><li><p><code>mmap()</code> can be used to support <em>eXecute In Place</em> (XIP) on random access media under the following very restrictive conditions:</p><p>a. Any file system that maps files contiguously on the media should implement the mmap file operation. By comparison, most file system scatter files over the media in non-contiguous sectors. As of this writing, ROMFS is the only file system that meets this requirement. b. The underlying block driver supports the <code>BIOC_XIPBASE</code> <code>ioctl</code> command that maps the underlying media to a randomly accessible address. At present, only the RAM/ROM disk driver does this.</p><p>Some limitations of this approach are as follows:</p><p>a. Since no real mapping occurs, all of the file contents are &quot;mapped&quot; into memory. b. All mapped files are read-only. c. There are no access privileges.</p></li><li><p>If <code>CONFIG_FS_RAMMAP</code> is defined in the configuration, then <code>mmap()</code> will support simulation of memory mapped files by copying files whole into RAM. These copied files have some of the properties of standard memory mapped files. There are many, many exceptions exceptions, however. Some of these include:</p><p>a. The goal is to have a single region of memory that represents a single file and can be shared by many threads. That is, given a filename a thread should be able to open the file, get a file descriptor, and call <code>mmap()</code> to get a memory region. Different file descriptors opened with the same file path should get the same memory region when mapped.</p><pre><code>The limitation in the current design is that there is
insufficient knowledge to know that these different file
descriptors correspond to the same file. So, for the time being,
a new memory region is created each time that \`rammmap()\` is
called. Not very useful!
</code></pre><p>b. The entire mapped portion of the file must be present in memory. Since it is assumed that the MCU does not have an MMU, on-demanding paging in of file blocks cannot be supported. Since the while mapped portion of the file must be present in memory, there are limitations in the size of files that may be memory mapped (especially on MCUs with no significant RAM resources).</p><p>c. All mapped files are read-only. You can write to the in-memory image, but the file contents will not change.</p><p>d. There are no access privileges.</p><p>e. Since there are no processes in NuttX, all <code>mmap()</code> and <code>munmap()</code> operations have immediate, global effects. Under Linux, for example, <code>munmap()</code> would eliminate only the mapping with a process; the mappings to the same file in other processes would not be effected.</p><p>f. Like true mapped file, the region will persist after closing the file descriptor. However, at present, these ram copied file regions are <em>not</em> automatically &quot;unmapped&quot; (i.e., freed) when a thread is terminated. This is primarily because it is not possible to know how many users of the mapped region there are and, therefore, when would be the appropriate time to free the region (other than when munmap is called).</p><pre><code>NOTE: Note, if the design limitation of a) were solved, then it
would be easy to solve exception d) as well.
</code></pre></li></ol><h3 id="fdsan" tabindex="-1">Fdsan <a class="header-anchor" href="#fdsan" aria-label="Permalink to &quot;Fdsan&quot;">​</a></h3><p>FD (file descriptor) is widely used in system software development, and almost all implementations of posix os (including nuttx) use FD as an index. the value of fd needs to be allocated starting from the minimum available value of 3, and each process has a copy, so the same fd value is very easy to reuse in the program.</p><p>In multi threaded or multi process environments without address isolation, If the ownership, global variables, and competition relationships of fd are not properly handled, there may be issues with fd duplication or accidental closure. Further leading to the following issues, which are difficult to troubleshoot.</p><ol><li>Security vulnerability: the fd we wrote is not the expected fd and will be accessed by hackers to obtain data</li><li>Program exceptions or crashes: write or read fd failures, and program logic errors</li><li>The structured file XML or database is damaged: the data format written to the database is not the expected format.</li></ol><p>The implementation principle of fdsan is based on the implementation of Android <a href="https://android.googlesource.com/platform/bionic/+/master/docs/fdsan.md" target="_blank" rel="noreferrer">https://android.googlesource.com/platform/bionic/+/master/docs/fdsan.md</a></p>`,30)]))}const y=t(l,[["render",o]]);export{u as __pageData,y as default};
