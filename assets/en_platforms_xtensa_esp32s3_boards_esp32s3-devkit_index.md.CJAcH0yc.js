import{_ as o}from"./chunks/esp32-audio-config-file.nNc5QnB1.js";import{_ as s,c as r,al as n,j as e,a as t,o as i}from"./chunks/framework.NFAqBSgQ.js";const d="/assets/esp32-s3-devkitc-1.Csj5pt3p.png",p="data:image/png;base64,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",S=JSON.parse('{"title":"ESP32S3-DevKit","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/xtensa/esp32s3/boards/esp32s3-devkit/index.md","filePath":"en/platforms/xtensa/esp32s3/boards/esp32s3-devkit/index.md"}'),l={name:"en/platforms/xtensa/esp32s3/boards/esp32s3-devkit/index.md"};function c(h,a,u,m,f,A){return i(),r("div",null,a[0]||(a[0]=[n('<h1 id="esp32s3-devkit" tabindex="-1">ESP32S3-DevKit <a class="header-anchor" href="#esp32s3-devkit" aria-label="Permalink to &quot;ESP32S3-DevKit&quot;">​</a></h1><p>chip:esp32, chip:esp32s3</p><p>The <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/hw-reference/esp32s3/user-guide-devkitc-1.html" target="_blank" rel="noreferrer">ESP32S3 DevKit</a> is a development board for the ESP32-S3 SoC from Espressif, based on a ESP32-S3-WROOM-1 module.</p><hr><h2 id="" tabindex="-1"><img src="'+d+`" alt="" class="align-center"> <a class="header-anchor" href="#" aria-label="Permalink to &quot;![](esp32-s3-devkitc-1.png){.align-center}&quot;">​</a></h2><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h2><blockquote><ul><li>ESP32-S3-WROOM-1 Module</li><li>USB-to-UART bridge via micro USB port</li><li>Power LED</li><li>EN and BOOT buttons (BOOT accessible to user)</li><li>SPI FLASH (size varies according to model</li></ul></blockquote><h2 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h2><p>UART0 is, by default, the serial console. It connects to the on-board CP2102 converter and is available on the USB connector USB CON8 (J1).</p><p>It will show up as /dev/ttyUSB[n] where [n] will probably be 0.</p><h2 id="buttons-and-leds" tabindex="-1">Buttons and LEDs <a class="header-anchor" href="#buttons-and-leds" aria-label="Permalink to &quot;Buttons and LEDs&quot;">​</a></h2><h3 id="board-buttons" tabindex="-1">Board Buttons <a class="header-anchor" href="#board-buttons" aria-label="Permalink to &quot;Board Buttons&quot;">​</a></h3><p>There are two buttons labeled Boot and EN. The EN button is not available to software. It pulls the chip enable line that doubles as a reset line.</p><p>The BOOT button is connected to IO0. On reset it is used as a strapping pin to determine whether the chip boots normally or into the serial bootloader. After reset, however, the BOOT button can be used for software input.</p><h3 id="board-leds" tabindex="-1">Board LEDs <a class="header-anchor" href="#board-leds" aria-label="Permalink to &quot;Board LEDs&quot;">​</a></h3><p>There are several on-board LEDs for that indicate the presence of power and USB activity. None of these are available for use by software. Another WS2812 LED is connected to GPIO48 or GPIO38 depending on the boards version.</p><p>Note</p><p>Both the initial and v1.1 versions of ESP32-S3-DevKitC-1 are available on the market. The main difference lies in the GPIO assignment for the RGB LED: the initial version (1.0) uses GPIO48, whereas v1.1 uses GPIO38. The initial version is selected by default, but one can select <code>CONFIG_ESP32S3_DEVKITC_1_V11</code> through <code>make menuconfig</code>.</p><h2 id="i2s" tabindex="-1">I2S <a class="header-anchor" href="#i2s" aria-label="Permalink to &quot;I2S&quot;">​</a></h2><p>ESP32-S3 has two I2S peripherals accessible using either the generic I2S audio driver or a specific audio codec driver (<a href="https://www.cirrus.com/products/cs4344-45-48/" target="_blank" rel="noreferrer">CS4344</a> bindings are available at the moment). The generic I2S audio driver enables the use of both the receiver module (RX) and the transmitter module (TX) without using any specific codec. Also, it&#39;s possible to use the I2S character device driver to bypass the audio subsystem and write directly to the I2S peripheral.</p><p>The following configurations use the I2S peripheral::</p><p>: - <code>platforms/xtensa/esp32s3/boards/esp32s3-devkit/index:audio</code>{.interpreted-text role=&quot;ref&quot;} - <code>platforms/xtensa/esp32s3/boards/esp32s3-devkit/index:nxlooper</code>{.interpreted-text role=&quot;ref&quot;}</p><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><p>All of the configurations presented below can be tested by running the following commands:</p><pre><code> ./tools/configure.sh esp32s3-devkit:&lt;config_name&gt;
 make flash ESPTOOL_PORT=/dev/ttyUSB0 -j
</code></pre><p>Where &lt;config_name&gt; is the name of board configuration you want to use, i.e.: nsh, buttons, wifi... Then use a serial console terminal like <code>picocom</code> configured to 115200 8N1.</p><h3 id="adc" tabindex="-1">adc <a class="header-anchor" href="#adc" aria-label="Permalink to &quot;adc&quot;">​</a></h3><p>The <code>adc</code> configuration enables the ADC driver and the ADC example application. ADC Unit 1 is registered to <code>/dev/adc0</code> with channels 0, 1, 2 and 3 enabled by default. Currently, the ADC operates in oneshot mode.</p><p>More ADC channels can be enabled or disabled in <code>ADC Configuration</code> menu.</p><p>This example shows channels 0 and 1 connected to 3.3 V and channels 2 and 3 to GND (all readings show in units of mV):</p><pre><code>nsh&gt; adc -n 1
adc_main: g_adcstate.count: 1
adc_main: Hardware initialized. Opening the ADC device: /dev/adc0
Sample:
1: channel: 0 value: 3061
2: channel: 1 value: 3061
3: channel: 2 value: 106
4: channel: 3 value: 99
</code></pre><h3 id="audio" tabindex="-1">audio <a class="header-anchor" href="#audio" aria-label="Permalink to &quot;audio&quot;">​</a></h3><p>This configuration uses the I2S0 peripheral and an externally connected audio codec to play an audio file streamed over an HTTP connection while connected to a Wi-Fi network.</p><p><strong>Audio Codec Setup</strong></p><p>The CS4344 audio codec is connected to the following pins:</p><p>ESP32-S3 Pin CS4344 Pin Description</p><hr><p>5 MCLK Master Clock 16 SCLK Serial Clock 7 LRCK Left Right Clock (Word Select) 6 SDIN Serial Data In on CS4344. (DOUT on ESP32-S3)</p><p><strong>Simple HTTP server</strong></p><p>Prepare a PCM-encoded ([.wav]{.title-ref}) audio file with 16 or 24 bits/sample (sampled at 16~48kHz). This file must be placed into a folder in a computer that could be accessed on the same Wi-Fi network the ESP32 will be connecting to.</p><p>Python provides a simple HTTP server. <code>cd</code> to the audio file folder on the PC and run:</p><pre><code> python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/)
</code></pre><p>Look for your PC IP address and test playing the prepared audio on your browser:</p><p><img src="`+o+`" alt="" class="align-center"></p><p>After successfully built and flashed, connect the board to the Wi-Fi network:</p><pre><code>nsh&gt; wapi psk wlan0 mypasswd 3
nsh&gt; wapi essid wlan0 myssid 1
nsh&gt; renew wlan0
</code></pre><p>Once connected, open NuttX&#39;s player and play the file according to the filename and the IP address of the HTTP server:</p><pre><code>nsh&gt; nxplayer
nxplayer&gt; play http://192.168.1.239:8000/tones.wav
</code></pre><h3 id="buttons" tabindex="-1">buttons <a class="header-anchor" href="#buttons" aria-label="Permalink to &quot;buttons&quot;">​</a></h3><p>This configuration shows the use of the buttons subsystem. It can be used by executing the <code>buttons</code> application and pressing on any of the available board buttons:</p><pre><code>nsh&gt; buttons
buttons_main: Starting the button_daemon
buttons_main: button_daemon started
button_daemon: Running
button_daemon: Opening /dev/buttons
button_daemon: Supported BUTTONs 0x01
nsh&gt; Sample = 1
Sample = 0
</code></pre><h3 id="capture" tabindex="-1">capture <a class="header-anchor" href="#capture" aria-label="Permalink to &quot;capture&quot;">​</a></h3><p>The capture configuration enables the capture driver and the capture example, allowing the user to measure duty cycle and frequency of a signal. Default pin is GPIO 12 with an internal pull-up resistor enabled. When connecting a 50 Hz pulse with 50% duty cycle, the following output is expected:</p><pre><code>nsh&gt; cap
cap_main: Hardware initialized. Opening the capture device: /dev/capture0
cap_main: Number of samples: 0
pwm duty cycle: 50 %
pwm frequency: 50 Hz
pwm duty cycle: 50 %
pwm frequency: 50 Hz
</code></pre><h3 id="coremark" tabindex="-1">coremark <a class="header-anchor" href="#coremark" aria-label="Permalink to &quot;coremark&quot;">​</a></h3><p>This configuration sets the CoreMark benchmark up for running on the maximum number of cores for this system. It also enables some optimization flags and disables the NuttShell to get the best possible score.</p><p>Note</p><p>As the NSH is disabled, the application will start as soon as the system is turned on.</p><h3 id="cxx" tabindex="-1">cxx <a class="header-anchor" href="#cxx" aria-label="Permalink to &quot;cxx&quot;">​</a></h3><p>Development environment ready for C++ applications. You can check if the setup was successful by running <code>cxxtest</code>:</p><pre><code>nsh&gt; cxxtest
Test ofstream ================================
printf: Starting test_ostream
printf: Successfully opened /dev/console
cout: Successfully opened /dev/console
Writing this to /dev/console
Test iostream ================================
Hello, this is only a test
Print an int: 190
Print a char: d
Test std::vector =============================
v1=1 2 3
Hello World Good Luck
Test std::map ================================
Test C++17 features ==========================
File /proc/meminfo exists!
Invalid file! /invalid
File /proc/version exists!
</code></pre><h3 id="elf" tabindex="-1">elf <a class="header-anchor" href="#elf" aria-label="Permalink to &quot;elf&quot;">​</a></h3><p>This configuration uses apps/examples/elf in order to test the ELF loader. It can be tested by executing the <code>elf</code> application.</p><h3 id="gpio" tabindex="-1">gpio <a class="header-anchor" href="#gpio" aria-label="Permalink to &quot;gpio&quot;">​</a></h3><p>This is a test for the GPIO driver. Three GPIOS are defined: 1) GPIO15 is set as an output, 2) GPIO18 as input and, 3) GPIO21 as an input triggered by a rising edge.</p><p>This example also builds the <code>EXAMPLES_GPIO</code> application from the <code>nuttx-apps</code>.</p><p>To write to the GPIO (GPIO 15, as defined by the board implementation):</p><pre><code>nsh&gt; gpio -o 1 /dev/gpio0
nsh&gt; gpio -o 0 /dev/gpio0
</code></pre><p>To read from the GPIO (GPIO 18, as defined by the board implementation):</p><pre><code>nsh&gt; gpio /dev/gpio1
Driver: /dev/gpio1
  Input pin:     Value=1
</code></pre><p>Finally, we can use the interrupt pin (GPIO21) to send a signal when the interrupt fires:</p><pre><code>nsh&gt; gpio -w 14 /dev/gpio2
Driver: /dev/gpio2
  Interrupt pin: Value=0
  Verify:        Value=1
</code></pre><p>The pin is configured to trigger an interrupt on the rising edge, so after issuing the above command, connect it to 3.3V.</p><h3 id="i2c" tabindex="-1">i2c <a class="header-anchor" href="#i2c" aria-label="Permalink to &quot;i2c&quot;">​</a></h3><p>This configuration can be used to scan and manipulate I2C devices. You can scan for all I2C devices using the following command:</p><pre><code>nsh&gt; i2c dev 0x00 0x7f
</code></pre><p>To use slave mode, you can enable [ESP32S3_I2S0_ROLE_SLAVE]{.title-ref} or [ESP32S3_I2S1_ROLE_SLAVE]{.title-ref} option. To use slave mode driver following snippet demonstrates how write to i2c bus using slave driver:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#define ESP_I2C_SLAVE_PATH  &quot;/dev/i2cslv0&quot;</span></span>
<span class="line"><span>int main(int argc, char *argv[])</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    int i2c_slave_fd;</span></span>
<span class="line"><span>    int ret;</span></span>
<span class="line"><span>    uint8_t buffer[5] = {0xAA};</span></span>
<span class="line"><span>    i2c_slave_fd = open(ESP_I2C_SLAVE_PATH, O_RDWR);</span></span>
<span class="line"><span>    ret = write(i2c_slave_fd, buffer, 5);</span></span>
<span class="line"><span>    close(i2c_slave_fd);</span></span>
<span class="line"><span> }</span></span></code></pre></div><h3 id="i2schar" tabindex="-1">i2schar <a class="header-anchor" href="#i2schar" aria-label="Permalink to &quot;i2schar&quot;">​</a></h3><p>This configuration enables the I2S character device and the i2schar example app, which provides an easy-to-use way of testing the I2S peripherals (I2S0 and I2S1), enabling both the TX and the RX for those peripherals.</p><p><strong>I2S0 pinout</strong></p><p>ESP32-S3 Pin Signal Pin Description</p><hr><p>0 MCLK Master Clock 4 BCLK Bit Clock (SCLK) 5 WS Word Select (LRCLK) 18 DOUT Data Out 19 DIN Data IN</p><p><strong>I2S1 pinout</strong></p><p>ESP32-S3 Pin Signal Pin Description</p><hr><p>22 BCLK Bit Clock (SCLK) 23 WS Word Select (LRCLK) 25 DOUT Data Out 26 DIN Data IN</p><p>After successfully built and flashed, run on the boards&#39;s terminal:</p><pre><code>i2schar -p /dev/i2schar[0-1]
</code></pre><p>The corresponding output should show related debug information.</p><h3 id="knsh" tabindex="-1">knsh <a class="header-anchor" href="#knsh" aria-label="Permalink to &quot;knsh&quot;">​</a></h3><p>This is identical to the nsh configuration except that (1) NuttX is built as PROTECTED mode, monolithic module and the user applications are built separately and, as a consequence, (2) some features that are only available in the FLAT build are disabled.</p><p>Protected Mode support for ESP32-S3 relies on the World Controller (WC) and Permission Control (PMS) peripherals for implementing isolation between Kernel and Userspace.</p><p>By working together with the MMU and Static MPUs of the ESP32-S3, the WC/PMS is able to restrict the application access to peripherals, on-chip memories (Internal ROM and Internal SRAM) and off-chip memories (External Flash and PSRAM).</p><p>Warning</p><p>The World Controller and Permission Control <strong>do not</strong> prevent the application from accessing CPU System Registers.</p><h3 id="motor" tabindex="-1">motor <a class="header-anchor" href="#motor" aria-label="Permalink to &quot;motor&quot;">​</a></h3><p>The motor configuration enables the MCPWM peripheral with support to brushed DC motor control.</p><p>It creates a <code>/dev/motor0</code> device with speed and direction control capabilities by using two GPIOs (GPIO15 and GPIO16) for PWM output. PWM frequency is configurable from 25 Hz to 3 kHz, however it defaults to 1 kHz. There is also support for an optional fault GPIO (defaults to GPIO10), which can be used for quick motor braking. All GPIOs are configurable in <code>menuconfig</code>.</p><h3 id="mcuboot-nsh" tabindex="-1">mcuboot_nsh <a class="header-anchor" href="#mcuboot-nsh" aria-label="Permalink to &quot;mcuboot\\_nsh&quot;">​</a></h3><p>This configuration is the same as the <code>nsh</code> configuration, but it generates the application image in a format that can be used by MCUboot. It also makes the <code>make bootloader</code> command to build the MCUboot bootloader image using the Espressif HAL.</p><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>Basic NuttShell configuration (console enabled in UART0, exposed via USB connection by means of CP2102 converter, at 115200 bps).</p><h3 id="nxlooper" tabindex="-1">nxlooper <a class="header-anchor" href="#nxlooper" aria-label="Permalink to &quot;nxlooper&quot;">​</a></h3><p>This configuration uses the I2S1 peripheral as an I2S receiver and the I2S0 peripheral as an I2S transmitter. The idea is to capture an I2S data frame using an I2S peripheral and reproduce the captured data on the other.</p><p><strong>Receiving data on I2S1</strong></p><p>The I2S1 will act as a receiver (in slave mode, i.e., waiting for the BCLK and WS signals from the transmitter), capturing data from DIN, which needs to be connected to an external source as follows:</p><p>ESP32-S3 Pin Signal Pin Description</p><hr><p>18 BCLK Bit Clock (SCLK) 17 WS Word Select (LRCLK) 15 DIN Data IN</p><p><strong>Transmitting data on I2S0</strong></p><p>The I2S0 will act as a transmitter (in master mode, i.e., providing the BCLK and WS signals), replicating the data captured on I2S1. The pinout for the transmitter is as follows:</p><p>ESP32 Pin Signal Pin Description</p><hr><p>5 MCLK Master Clock 16 BCLK Bit Clock (SCLK) 7 WS Word Select (LRCLK) 6 DOUT Data Out</p><p>Note</p><p>The audio codec CS4344 can be connected to the transmitter pins to reproduce the captured data if the receiver&#39;s source is a PCM-encoded audio data.</p><p><strong>nxlooper</strong></p><p>The <code>nxlooper</code> application captures data from the audio device with input capabilities (the I2S1 in this example) and forwards the audio data frame to the audio device with output capabilities (the I2S0 in this example).</p><p>After successfully built and flashed, run on the boards&#39; terminal:</p><pre><code>nsh&gt; nxlooper
nxlooper&gt; loopback
</code></pre><p>Note</p><p><code>loopback</code> command default arguments for the channel configuration, data width and sample rate are, respectively, 2 channels, 16 bits/sample and 48KHz. These arguments can be supplied to select different audio formats, for instance:</p><p>nxlooper&gt; loopback 2 16 44100</p><h3 id="oneshot" tabindex="-1">oneshot <a class="header-anchor" href="#oneshot" aria-label="Permalink to &quot;oneshot&quot;">​</a></h3><p>This config demonstrate the use of oneshot timers present on the ESP32-S3. To test it, just run the <code>oneshot</code> example:</p><pre><code>nsh&gt; oneshot
Opening /dev/oneshot
Maximum delay is 4294967295999999
Starting oneshot timer with delay 2000000 microseconds
Waiting...
Finished
</code></pre><p>qencoder ---</p><p>This configuration demonstrates the use of Quadrature Encoder connected to pins GPIO10 and GPIO11. You can start measurement of pulses using the following command (by default, it will open <code>\\dev\\qe0</code> device and print 20 samples using 1 second delay):</p><pre><code>nsh&gt; qe
</code></pre><h3 id="pm" tabindex="-1">pm <a class="header-anchor" href="#pm" aria-label="Permalink to &quot;pm&quot;">​</a></h3><p>This config demonstrate the use of power management present on the ESP32-S3. You can use the <code>pmconfig</code> command to test the power management. Enables PM support. You can define standby mode and sleep mode delay time:</p><pre><code> make menuconfig
-&gt; Board Selection
    -&gt; (15) PM_STANDBY delay (seconds)
       (0)  PM_STANDBY delay (nanoseconds)
       (20) PM_SLEEP delay (seconds)
       (0)  PM_SLEEP delay (nanoseconds)
</code></pre><p>Before switching PM status, you need to query the current PM status:</p><pre><code>nsh&gt; pmconfig
Last state 0, Next state 0

/proc/pm/state0:
DOMAIN0           WAKE         SLEEP         TOTAL
normal          0s 00%        0s 00%        0s 00%
idle            0s 00%        0s 00%        0s 00%
standby         0s 00%        0s 00%        0s 00%
sleep           0s 00%        0s 00%        0s 00%

/proc/pm/wakelock0:
DOMAIN0      STATE     COUNT      TIME
system       normal        2        1s
system       idle          1        1s
system       standby       1        1s
system       sleep         1        1s
</code></pre><p>System switch to the PM idle mode, you need to enter:</p><pre><code>nsh&gt; pmconfig relax normal
nsh&gt; pmconfig relax normal
</code></pre><p>System switch to the PM standby mode, you need to enter:</p><pre><code>nsh&gt; pmconfig relax idle
nsh&gt; pmconfig relax normal
nsh&gt; pmconfig relax normal
</code></pre><p>System switch to the PM sleep mode, you need to enter:</p><pre><code>nsh&gt; pmconfig relax standby
nsh&gt; pmconfig relax idle
nsh&gt; pmconfig relax normal
nsh&gt; pmconfig relax normal
</code></pre><p>Note: When normal mode COUNT is 0, it will switch to the next PM state where COUNT is not 0.</p><h3 id="psram-quad" tabindex="-1">psram_quad <a class="header-anchor" href="#psram-quad" aria-label="Permalink to &quot;psram\\_quad&quot;">​</a></h3><p>This config tests the PSRAM driver over SPIRAM interface in quad mode. You can use the mm command to test the PSRAM memory:</p><pre><code>nsh&gt; mm
    mallinfo:
      Total space allocated from system = 8803232
      Number of non-inuse chunks        = 2
      Largest non-inuse chunk           = 8388592
      Total allocated space             = 9672
      Total non-inuse space             = 8793560
(0)Allocating 5011 bytes

......

(31)Releasing memory at 0x3fc8c088 (size=24 bytes)
    mallinfo:
      Total space allocated from system = 8803232
      Number of non-inuse chunks        = 2
      Largest non-inuse chunk           = 8388592
      Total allocated space             = 9672
      Total non-inuse space             = 8793560
TEST COMPLETE
</code></pre><h3 id="psram-octal" tabindex="-1">psram_octal <a class="header-anchor" href="#psram-octal" aria-label="Permalink to &quot;psram\\_octal&quot;">​</a></h3><p>Similar to the <code>\`psram_quad</code>\` configuration but using the SPIRAM interface in octal mode.</p><h3 id="psram-usrheap" tabindex="-1">psram_usrheap <a class="header-anchor" href="#psram-usrheap" aria-label="Permalink to &quot;psram\\_usrheap&quot;">​</a></h3><p>This configuration enables allocating the userspace heap into SPI RAM and reserves the internal RAM for kernel heap.</p><p>Important: this config defaults to flash QUAD mode, and should be changed if the board runs on OCTAL mode by setting <code>CONFIG_ESP32S3_SPIRAM_MODE_OCT</code>. If wrong, a SPIRAM error will appear during boot.</p><p>To check the flash type, run the following command:</p><pre><code> esptool.py flash_id
esptool.py v4.8.1
Found 33 serial ports
Serial port /dev/ttyUSB0
Connecting....
Detecting chip type... ESP32-S3
Chip is ESP32-S3 (QFN56) (revision v0.1)
Features: WiFi, BLE, Embedded PSRAM 2MB (AP_3v3)
Crystal is 40MHz
MAC: 7c:df:a1:e5:d8:5c
Uploading stub...
Running stub...
Stub running...
Manufacturer: 20
Device: 4017
Detected flash size: 8MB
Flash type set in eFuse: quad (4 data lines)
Flash voltage set by eFuse to 3.3V
Hard resetting via RTS pin...
</code></pre><p>The flash type can be seen on the &quot;Flash type set in eFuse: quad&quot; line.</p><h3 id="pwm" tabindex="-1">pwm <a class="header-anchor" href="#pwm" aria-label="Permalink to &quot;pwm&quot;">​</a></h3><p>This configuration demonstrates the use of PWM through a LED connected to GPIO2. To test it, just execute the <code>pwm</code> application:</p><pre><code>nsh&gt; pwm
pwm_main: starting output with frequency: 10000 duty: 00008000
pwm_main: stopping output
</code></pre><h3 id="python" tabindex="-1">python <a class="header-anchor" href="#python" aria-label="Permalink to &quot;python&quot;">​</a></h3><p>This configuration enables the Python for ESP32-S3. Please refer to the [[Python Interpreter &lt;/application](\`Python Interpreter &lt;/application.md)s/interpreters/python/index&gt;]{.title-ref} page.</p><p>Warning</p><p>Note that this defconfig uses a board with the ESP32-S3-WROOM-2 module with 32MiB of flash and 8MiB of PSRAM. Running Python on ESP32-S3 requires at least 16MiB of flash and 8MiB of PSRAM.</p><h3 id="qemu-debug" tabindex="-1">qemu_debug <a class="header-anchor" href="#qemu-debug" aria-label="Permalink to &quot;qemu\\_debug&quot;">​</a></h3><p>A configuration tailored for the <a href="https://github.com/espressif/qemu" target="_blank" rel="noreferrer">Espressif fork of QEMU</a>.</p><h3 id="qemu-toywasm" tabindex="-1">qemu_toywasm <a class="header-anchor" href="#qemu-toywasm" aria-label="Permalink to &quot;qemu\\_toywasm&quot;">​</a></h3>`,164),e("p",null,[t("Based on "),e("code",null,"qemu_debug"),t(" defconfig, with the addition of WebAssembly support. See "),e("code",{class:"interpreted-text",role:"ref"},"toywasm"),t(" for more further details.")],-1),n(`<h3 id="random" tabindex="-1">random <a class="header-anchor" href="#random" aria-label="Permalink to &quot;random&quot;">​</a></h3><p>This configuration shows the use of the ESP32-S3&#39;s True Random Number Generator with entropy sourced from Wi-Fi and Bluetooth noise. To test it, just run <code>rand</code> to get 32 randomly generated bytes:</p><pre><code>nsh&gt; rand
Reading 8 random numbers
Random values (0x3ffe0b00):
0000  98 b9 66 a2 a2 c0 a2 ae 09 70 93 d1 b5 91 86 c8  ..f......p......
0010  8f 0e 0b 04 29 64 21 72 01 92 7c a2 27 60 6f 90  ....)d!r..|.&#39;\`o.
</code></pre><h3 id="rmt" tabindex="-1">rmt <a class="header-anchor" href="#rmt" aria-label="Permalink to &quot;rmt&quot;">​</a></h3><p>This configuration configures the transmitter and the receiver of the Remote Control Transceiver (RMT) peripheral on the ESP32-S3 using GPIOs 48 (or 38, depending on the board version) and 2, respectively. The RMT peripheral is better explained <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-reference/peripherals/rmt.html" target="_blank" rel="noreferrer">here</a>, in the ESP-IDF documentation. The minimal data unit in the frame is called the RMT symbol, which is represented by <code>rmt_item32_t</code> in the driver:</p><p><img src="`+p+`" alt="" class="align-center"></p><p>The example <code>rmtchar</code> can be used to test the RMT peripheral. Connecting these pins externally to each other will make the transmitter send RMT items and demonstrates the usage of the RMT peripheral:</p><pre><code>nsh&gt; rmtchar
</code></pre><p><strong>WS2812 addressable RGB LEDs</strong></p><p>This same configuration enables the usage of the RMT peripheral and the example <code>ws2812</code> to drive addressable RGB LEDs:</p><pre><code>nsh&gt; ws2812
</code></pre><p>Please note that this board contains an on-board WS2812 LED connected to GPIO48 (or GPIO38, depending on the board version) and, by default, this config configures the RMT transmitter in the same pin.</p><h3 id="rtc" tabindex="-1">rtc <a class="header-anchor" href="#rtc" aria-label="Permalink to &quot;rtc&quot;">​</a></h3><p>This configuration demonstrates the use of the RTC driver through alarms. You can set an alarm, check its progress and receive a notification after it expires:</p><pre><code>nsh&gt; alarm 10
alarm_daemon started
alarm_daemon: Running
Opening /dev/rtc0
Alarm 0 set in 10 seconds
nsh&gt; alarm -r
Opening /dev/rtc0
Alarm 0 is active with 10 seconds to expiration
nsh&gt; alarm_daemon: alarm 0 received
</code></pre><h3 id="sdmmc" tabindex="-1">sdmmc <a class="header-anchor" href="#sdmmc" aria-label="Permalink to &quot;sdmmc&quot;">​</a></h3><p>Based on nsh. Support for sdmmc driver is enabled with following settings:</p><p>Enable sdmmc driver:</p><pre><code>CONFIG_ESP32S3_SDMMC=y
</code></pre><p>Default GPIO definitions:</p><pre><code>CONFIG_ESP32S3_SDMMC_CMD=41
CONFIG_ESP32S3_SDMMC_CLK=39
CONFIG_ESP32S3_SDMMC_D0=40
CONFIG_ESP32S3_SDMMC_D1=16
CONFIG_ESP32S3_SDMMC_D2=8
CONFIG_ESP32S3_SDMMC_D3=42
</code></pre><p>Multiblock limitation due to hardware:</p><pre><code>CONFIG_MMCSD_MULTIBLOCK_LIMIT=128
</code></pre><p>Use sched_yield instead of usleep due to long tick time:</p><pre><code>CONFIG_MMCSD_CHECK_READY_STATUS_WITHOUT_SLEEP=y
</code></pre><p>This configuration has been verified with an adapter (1.27 to 2.54mm T-type adapter, CN10P2) and an <a href="https://semiconductor.samsung.com/jp/estorage/emmc/emmc-5-1/klm8g1getf-b041/" target="_blank" rel="noreferrer">external emmc module</a>.</p><p>Besides the connections to 3v3 and GND of ESP32S3 DevKit, pins of the adapter used in the verification are connected to ESP32S3 DevKit as following:</p><pre><code>adapter pin           ESP32S3 GPIO
    11      ===CMD==&gt;       41
    12      ===CLK==&gt;       39
    1       ===D0===&gt;       40
    2       ===D1===&gt;       16
    3       ===D2===&gt;       8
    4       ===D3===&gt;       42
</code></pre><p>Format and mount the SD/MMC device with following commands:</p><pre><code>mkfatfs -F 32 -r /mnt /dev/mmcsd1
mount -t vfat /dev/mmcsd1 /mnt
</code></pre><p>FAT filesystem is enabled in the default configuration. Other filesystems may also work.</p><h3 id="smp" tabindex="-1">smp <a class="header-anchor" href="#smp" aria-label="Permalink to &quot;smp&quot;">​</a></h3><p>Another NSH configuration, similar to nsh, but also enables SMP operation. It differs from the nsh configuration only in these additional settings:</p><p>SMP is enabled:</p><pre><code>CONFIG_SMP=y
CONFIG_SMP_NCPUS=2
CONFIG_SPINLOCK=y
</code></pre><p>The apps/testing/smp test is included:</p><pre><code>CONFIG_TESTING_SMP=y
CONFIG_TESTING_SMP_NBARRIER_THREADS=8
CONFIG_TESTING_SMP_PRIORITY=100
CONFIG_TESTING_SMP_STACKSIZE=2048
</code></pre><h3 id="spiflash" tabindex="-1">spiflash <a class="header-anchor" href="#spiflash" aria-label="Permalink to &quot;spiflash&quot;">​</a></h3><p>This config tests the external SPI that comes with the ESP32-S3 module connected through SPI1.</p><p>By default a SmartFS file system is selected. Once booted you can use the following commands to mount the file system:</p><pre><code>nsh&gt; mksmartfs /dev/smart0
nsh&gt; mount -t smartfs /dev/smart0 /mnt
</code></pre><p>Note that mksmartfs is only needed the first time.</p><h3 id="sta-softap" tabindex="-1">sta_softap <a class="header-anchor" href="#sta-softap" aria-label="Permalink to &quot;sta\\_softap&quot;">​</a></h3><p>With this configuration you can run these commands to be able to connect your smartphone or laptop to your board:</p><pre><code>nsh&gt; ifup wlan1
nsh&gt; dhcpd_start wlan1
nsh&gt; wapi psk wlan1 mypasswd 3
nsh&gt; wapi essid wlan1 nuttxap 1
</code></pre><p>In this case, you are creating the access point <code>nuttxapp</code> in your board and to connect to it on your smartphone you will be required to type the password <code>mypasswd</code> using WPA2.</p><p>Tip</p><p>Please refer to <code>ESP32 Wi-Fi SoftAP Mode &lt;esp32_wi-fi_softap&gt;</code>{.interpreted-text role=&quot;ref&quot;} for more information.</p><p>The <code>dhcpd_start</code> is necessary to let your board to associate an IP to your smartphone.</p><h3 id="tickless" tabindex="-1">tickless <a class="header-anchor" href="#tickless" aria-label="Permalink to &quot;tickless&quot;">​</a></h3><p>This configuration enables the support for tickless scheduler mode.</p><h3 id="timer" tabindex="-1">timer <a class="header-anchor" href="#timer" aria-label="Permalink to &quot;timer&quot;">​</a></h3><p>This config test the general use purpose timers. It includes the 4 timers, adds driver support, registers the timers as devices and includes the timer example.</p><p>To test it, just run the following:</p><pre><code>nsh&gt; timer -d /dev/timerx
</code></pre><p>Where x in the timer instance.</p><h3 id="toywasm" tabindex="-1">toywasm <a class="header-anchor" href="#toywasm" aria-label="Permalink to &quot;toywasm&quot;">​</a></h3><p>This config is an example to use toywasm.</p><p>This example uses littlefs on the SPI flash to store wasm modules.</p><p>Note: This example assumes a board with 32MB flash. To use a smaller one, tweak the --img-size option and CONFIG_ESP32S3_STORAGE_MTD_SIZE.</p><p>Note: To use flash larger than 4MB, you need to install a custom bootloader. <a href="https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/bootloader.html#spi-flash-configuration" target="_blank" rel="noreferrer">https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/bootloader.html#spi-flash-configuration</a></p><ol><li><p>Create a littlefs image which contains wasm modules.</p><p><a href="https://github.com/jrast/littlefs-python/blob/master/examples/mkfsimg.py" target="_blank" rel="noreferrer">https://github.com/jrast/littlefs-python/blob/master/examples/mkfsimg.py</a> is used in the following example:</p><pre><code>% python3 mkfsimg.py \\
  --img-filename ..../littlefs.bin \\
  --img-size 31981568 \\
  --block-size 4096 \\
  --prog-size 256 \\
  --read-size 256 \\
  --name-max 32 \\
  --disk-version 2.0 \\
  ..../wasm_module_dir
</code></pre></li><li><p>Build a NuttX binary and write it to the board as usual with this config.</p></li><li><p>Write the filesystem image to the board:</p><pre><code>% esptool.py \\
  -c esp32s3 \\
  -p /dev/tty.SLAB_USBtoUART \\
  -b 921600 \\
  write_flash \\
  -fs detect \\
  -fm dio \\
  -ff 40m \\
  0x180000 ..../littlefs.bin
</code></pre></li><li><p>Mount the filesystem and run a wasm module on it:</p><pre><code>nsh&gt; mount -t littlefs /dev/esp32s3flash /mnt
nsh&gt; toywasm --print-stats --wasi /mnt/....
</code></pre></li></ol><h3 id="twai" tabindex="-1">twai <a class="header-anchor" href="#twai" aria-label="Permalink to &quot;twai&quot;">​</a></h3><p>This configuration enables the support for the TWAI (Two-Wire Automotive Interface) driver. You can test it by connecting TWAI RX and TWAI TX pins which are GPIO0 and GPIO2 by default to a external transceiver or connecting TWAI RX to TWAI TX pin by enabling the <code>Device Drivers -&gt; CAN Driver Support -&gt; CAN loopback mode</code> option and running the <code>can</code> example:</p><pre><code>nsh&gt; can
nmsgs: 0
min ID: 1 max ID: 2047
Bit timing:
  Baud: 1000000
  TSEG1: 15
  TSEG2: 4
    SJW: 3
  ID:    1 DLC: 1
</code></pre><h3 id="usbnsh" tabindex="-1">usbnsh <a class="header-anchor" href="#usbnsh" aria-label="Permalink to &quot;usbnsh&quot;">​</a></h3><p>Basic NuttShell configuration console enabled over USB Device (USB CDC/ACM).</p><p>Before using this configuration, please confirm that your computer detected that USB JTAG/serial interface used to flash the board:</p><pre><code>usb 3-5.2.3: New USB device strings: Mfr=1, Product=2, SerialNumber=3
usb 3-5.2.3: Product: USB JTAG/serial debug unit
usb 3-5.2.3: Manufacturer: Espressif
usb 3-5.2.3: SerialNumber: XX:XX:XX:XX:XX:XX
cdc_acm 3-5.2.3:1.0: ttyACM0: USB ACM device
</code></pre><p>Then you can run the configuration and compilation procedure:</p><pre><code> ./tools/configure.sh esp32s3-devkit:usbnsh
 make flash ESPTOOL_PORT=/dev/ttyACM0 -j8
</code></pre><p>Then run the minicom configured to /dev/ttyACM0 115200 8n1 and press &lt;ENTER&gt; three times to force the nsh to show up:</p><pre><code>NuttShell (NSH) NuttX-12.1.0
nsh&gt; ?
help usage:  help [-v] [&lt;cmd&gt;]

    .         break     dd        exit      ls        ps        source    umount
    [         cat       df        false     mkdir     pwd       test      unset
    ?         cd        dmesg     free      mkrd      rm        time      uptime
    alias     cp        echo      help      mount     rmdir     true      usleep
    unalias   cmp       env       hexdump   mv        set       truncate  xd
    basename  dirname   exec      kill      printf    sleep     uname

Builtin Apps:
    nsh  sh
nsh&gt; uname -a
NuttX 12.1.0 38a73cd970 Jun 18 2023 16:58:46 xtensa esp32s3-devkit
nsh&gt;
</code></pre><h3 id="wifi" tabindex="-1">wifi <a class="header-anchor" href="#wifi" aria-label="Permalink to &quot;wifi&quot;">​</a></h3><p>Enables Wi-Fi support. You can define your credentials this way:</p><pre><code> make menuconfig
-&gt; Application Configuration
    -&gt; Network Utilities
        -&gt; Network initialization (NETUTILS_NETINIT [=y])
            -&gt; WAPI Configuration
</code></pre><p>Or if you don&#39;t want to keep it saved in the firmware you can do it at runtime:</p><pre><code>nsh&gt; wapi psk wlan0 mypasswd 3
nsh&gt; wapi essid wlan0 myssid 1
nsh&gt; renew wlan0
</code></pre><p>Tip</p><p>Please refer to <code>ESP32 Wi-Fi Station Mode &lt;esp32_wi-fi_sta&gt;</code>{.interpreted-text role=&quot;ref&quot;} for more information.</p><h3 id="watchdog" tabindex="-1">watchdog <a class="header-anchor" href="#watchdog" aria-label="Permalink to &quot;watchdog&quot;">​</a></h3><p>This config test the watchdog timers. It includes the 2 MWDTS, adds driver support, registers the WDTs as devices and includes the watchdog example.</p><p>To test it, just run the following:</p><pre><code>nsh&gt; wdog -i /dev/watchdogx
</code></pre><p>Where x is the watchdog instance.</p><p>To test the XTWDT(/dev/watchdog3) an interrupt handler needs to be implemented because XTWDT does not have system reset feature. To implement an interrupt handler [WDIOC_CAPTURE]{.title-ref} command can be used. When interrupt rises, XTAL32K clock can be restored with [WDIOC_RSTCLK]{.title-ref} command.</p><h3 id="adb" tabindex="-1">adb <a class="header-anchor" href="#adb" aria-label="Permalink to &quot;adb&quot;">​</a></h3><p>Basic NuttShell configuration console enabled over USB Device (USB ADB).</p><p>You can run the configuration and compilation procedure:</p><pre><code> ./tools/configure.sh esp32s3-devkit:adb
 make -j16
 make flash ESPTOOL_PORT=/dev/ttyACMx
</code></pre><p>Then run the adb command:</p><pre><code> adb -s 1234 shell
nsh&gt; uname -a
NuttX 0.0.0  Nov 22 2024 11:41:43 xtensa esp32s3-devkit
</code></pre><h3 id="txtable" tabindex="-1">txtable <a class="header-anchor" href="#txtable" aria-label="Permalink to &quot;txtable&quot;">​</a></h3><p>Basic TXTABLE(Text based Partition Table) configuration console enabled over USB ADB.</p><p>You can run the configuration and compilation procedure:</p><pre><code> ./tools/configure.sh -l esp32s3-devkit:txtable
 make -j16
 make flash ESPTOOL_PORT=/dev/ttyACMx
</code></pre><p>Then check the partition:</p><pre><code>nsh&gt; ls -l /dev/
/dev:
 dr--r--r--           0 adb0/
 crw-rw-rw-           0 console
 frw-rw-rw-     1044480 data
 frw-rw-rw-     1048576 esp32s3flash
 c-w--w--w-           0 log
 crw-rw-rw-           0 null
 crw-rw-rw-           0 ptmx
 dr--r--r--           0 pts/
 brw-rw-rw-        1024 ram0
 crw-rw-rw-           0 ttyS0
 frw-rw-rw-        4096 txtable
 crw-rw-rw-           0 zero
</code></pre><h3 id="usbmsc" tabindex="-1">usbmsc <a class="header-anchor" href="#usbmsc" aria-label="Permalink to &quot;usbmsc&quot;">​</a></h3><p>Basic USBMSC(USB Mass Storage Class) configuration based on esp32s3-devkit:usb_device</p><p>You can run the configuration and compilation procedure:</p><pre><code> ./tools/configure.sh -l esp32s3-devkit:usbmsc
 make flash ESPTOOL_PORT=/dev/ttyACMx -j16
</code></pre><p>To test it, just run the following:</p><pre><code># Device
nsh&gt; mkrd -m 10 -s 512 640
nsh&gt; msconn

# Host
 sudo mkfs.ext4 /dev/sdx
 sudo mount /dev/sdx ./mnt/
</code></pre><h3 id="fastboot" tabindex="-1">fastboot <a class="header-anchor" href="#fastboot" aria-label="Permalink to &quot;fastboot&quot;">​</a></h3><p>The basic Fastboot configuration is based on esp32s3-devkit:usb_device. More details about usage of fastboot, please refer to <a href="https://nuttx.apache.org/docs/latest/applications/system/fastboot/index.html" target="_blank" rel="noreferrer">fastbootd --- NuttX latest documentation</a>.</p><p>You can run the configuration and compilation procedure:</p><pre><code> ./tools/configure.sh -l esp32s3-devkit:fastboot
 make flash ESPTOOL_PORT=/dev/ttyACMx -j
</code></pre><p>To test it, just run the following (<strong>Default is host side</strong>):</p><ol><li><p>Install fastboot tool:</p><pre><code>sudo apt install fastboot
</code></pre></li><li><p>List devices running fastboot:</p><pre><code>fastboot devices
</code></pre></li></ol><blockquote><p>Example:</p><pre><code> fastboot devices
1234    fastboot
</code></pre></blockquote><ol start="3"><li><p>Display given variable:</p><pre><code>fastboot getvar &lt;NAME&gt;
</code></pre></li></ol><blockquote><p>Example:</p><pre><code># Display the &quot;kernel&quot; variable::
 fastboot -s 1234 getvar kernel
Kernel: NuttX
Finished. Total time: 0.000s
</code></pre></blockquote><ol start="4"><li><p>Flash given partition:</p><pre><code>fastboot flash PARTITION FILENAME
</code></pre></li></ol><blockquote><p>Example (Flash test.img to partition ram10):</p><pre><code># 1. Generate a test image
 dd if=/dev/random of=test.img bs=1 count=128

# 2. Create a RAM disk (Device side)
nsh&gt; mkrd -m 10 -s 512 640
nsh&gt; ls -l /dev/ram10
 brw-rw-rw-      327680 /dev/ram10

# 3. Flash test.img to partition ram10
 fastboot flash ram10 ./test.img
Sending &#39;ram10&#39; (0 KB)                             OKAY [  0.001s]
Writing &#39;ram10&#39;                                    OKAY [  0.001s]
Finished. Total time: 0.003s

# 4. Hexdump the test.img and partition ram10, and compare

## Host side
 hexdump test.img
0000000 b1e8 b297 4ac5 9dfa d170 244e 4f83 0f93
0000010 1bf7 0b19 7bde 5543 0520 9719 746d 54fc
0000020 369d 72b3 f2e6 f463 c8e9 24c8 c876 e820
0000030 384d 07ab 52ca 2b24 dee7 0404 2663 91e4
0000040 6752 3611 aece b543 5194 2224 d1d5 8144
0000050 ff44 3bc9 5155 b393 1efb 9e88 2de9 3669
0000060 d010 2770 9192 2532 ccf5 591f 39ea 2431
0000070 2e3f feb0 87ef 9bdf 7dd4 2e79 64de edf6
0000080

## Device side
nsh&gt; hexdump /dev/ram10 count=128
/dev/ram10 at 00000000:
0000: e8 b1 97 b2 c5 4a fa 9d 70 d1 4e 24 83 4f 93 0f .....J..p.N.O..
0010: f7 1b 19 0b de 7b 43 55 20 05 19 97 6d 74 fc 54 .....{CU ...mt.T
0020: 9d 36 b3 72 e6 f2 63 f4 e9 c8 c8 24 76 c8 20 e8 .6.r..c....v. .
0030: 4d 38 ab 07 ca 52 24 2b e7 de 04 04 63 26 e4 91 M8...R+....c&amp;..
0040: 52 67 11 36 ce ae 43 b5 94 51 24 22 d5 d1 44 81 Rg.6..C..Q&quot;..D.
0050: 44 ff c9 3b 55 51 93 b3 fb 1e 88 9e e9 2d 69 36 D..;UQ.......-i6
0060: 10 d0 70 27 92 91 32 25 f5 cc 1f 59 ea 39 31 24 ..p&#39;..2%...Y.91
0070: 3f 2e b0 fe ef 87 df 9b d4 7d 79 2e de 64 f6 ed ?........}y..d..
</code></pre></blockquote>`,115)]))}const w=s(l,[["render",c]]);export{S as __pageData,w as default};
