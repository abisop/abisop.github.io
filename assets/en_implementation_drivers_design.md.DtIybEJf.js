import{_ as r,c as a,al as i,o as t}from"./chunks/framework.NFAqBSgQ.js";const v=JSON.parse('{"title":"OS Drivers Design","description":"","frontmatter":{},"headers":[],"relativePath":"en/implementation/drivers_design.md","filePath":"en/implementation/drivers_design.md"}'),o={name:"en/implementation/drivers_design.md"};function n(s,e,d,l,h,c){return t(),a("div",null,e[0]||(e[0]=[i('<h1 id="os-drivers-design" tabindex="-1">OS Drivers Design <a class="header-anchor" href="#os-drivers-design" aria-label="Permalink to &quot;OS Drivers Design&quot;">​</a></h1><p>There are three kinds of drivers that are recognized by the OS and are visible to applications. Two are POSIX standard device driver types, one is non-standard. There are also internal OS components that may also be considered to be drivers or, more correctly, lower-half drivers. Details about these are given below.</p><h2 id="character-and-block-drivers" tabindex="-1">Character and Block Drivers <a class="header-anchor" href="#character-and-block-drivers" aria-label="Permalink to &quot;Character and Block Drivers&quot;">​</a></h2><p>The standard driver types include:</p><ul><li><strong>Character Drivers</strong>. First there are the character drivers These are drivers that support user accessibility via <code>read()</code>, <code>write()</code> etc. The others do not naturally. Character drivers implement a stream of incoming or outgoing bytes.</li><li><strong>Block Drivers</strong>. These are used to support files systems that supported block-oriented I/O, not a character stream. The user cannot <em>directly</em> access block drivers.</li></ul><p>The user can, however, access block drivers indirectly through a character driver proxy. Both character and block drivers are represented by device nodes, usually in <code>/dev</code>. But if you try to open the block driver, something very strange happens: A temporary, nameless proxy character driver is automatically instantiated that maps a character driver&#39;s byte stream into blocks and mediates the driver access to the block driver. This is the logic in <code>drivers/bch</code>. BCH stands for block to character. So from the application point of view, the both seem to be character drivers and applications can interact with both in the same way.</p><p>This capability is exploited, for example, by the NuttX file system formatting applications like mkfatfs to format a FAT system on a block driver.</p><p>There is also the complement, the loop device that converts a character driver into a block driver. Loop devices are commonly used to format a file system image in RAM.</p><h2 id="mtd-drivers" tabindex="-1">MTD Drivers <a class="header-anchor" href="#mtd-drivers" aria-label="Permalink to &quot;MTD Drivers&quot;">​</a></h2><p>And the non-standard driver is:</p><ul><li>The <strong>Memory Technology Driver (MTD)</strong>. This naming was borrowed from <code>infradead.org</code>, but does not derive from any of their MTD logic. The MTD driver manages memory-based devices like FLASH or EEPROM. And MTD FLASH memory driver is very similar to a block driver but FLASH has some different properties, most notably that you have to erase FLASH before you write to it.</li></ul><p>MTD has the same conveniences as block drivers: Then can appear as device nodes under <code>/dev</code> and can be proxied to behave like character drivers if the opened as character drivers. Plus they have some additional twists: MTD drivers can be stacked one on top of another to extend the capabilities of the lower level MTD driver. For example, <code>drivers/mtd/sector512.c</code> is an MTD driver that when layered on top of another MTD driver, it changes the apparent page size of the FLASH to 512 bytes.</p><p><code>drivers/mtd/mtd_partitions.c</code> can be used to break up a large FLASH into separate, independent partitions, each of which looks like another MTD driver.</p><p><code>drivers/mtd/ftl.c</code> is also interesting. FTL stands for FLASH Translation Layer. The FTL driver is an MTD driver that when layered on top of another MTD driver, converts the MTD driver to a block driver. The permutations are endless.</p><h2 id="monolithic-drivers" tabindex="-1">Monolithic Drivers <a class="header-anchor" href="#monolithic-drivers" aria-label="Permalink to &quot;Monolithic Drivers&quot;">​</a></h2><p>When one thinks about device drivers in an OS, one thinks of a single thing, a single block in a block diagram with these two primary interfaces:</p><ul><li>The device monolithic driver exposes a single, standard device driver interface. With the <strong>Virtual File System (VFS)</strong>, this provides the application user interface to the driver functionality. And</li><li>A low-level interface to the hardware that is managed by the device driver.</li></ul><h2 id="upper-half-and-lower-half-drivers" tabindex="-1">Upper Half and Lower Half Drivers <a class="header-anchor" href="#upper-half-and-lower-half-drivers" aria-label="Permalink to &quot;Upper Half and Lower Half Drivers&quot;">​</a></h2><p>NuttX supports many, many different MCU platforms, each with many similar but distinct built-in peripherals. Certainly we could imagine a realization where each such peripheral is supported by monolithic driver as described in the preceding paragraph. That would involve a lot code duplication, however. The MCU peripherals may be unique at a low, register-level interface. However, the peripherals are really very similar at a higher level of abstraction.</p><p>NuttX reduces the duplication, both in the code and in driver development, using the notion of <em>Upper Half</em> and <em>Lower Half</em> drivers. Such an implementation results in two things; two blocks in the system block diagram: The upper half driver in a group of common, shared drivers, and the MCU-specific lower half driver.</p><p>As before, each of these two driver components has two functional interfaces. For the upper half driver:</p><ul><li>The upper half device driver exposes a single, standard driver interface. With the <strong>Virtual File System (VFS)</strong>, this, again, provides the application user interface to the driver functionality. And</li><li>The upper-half side of the lower-half interface to the MCU-specific hardware that is managed by the lower-half device driver.</li></ul><p>And for the lower half driver:</p><ul><li>The lower-half side of the interface to the the upper0half driver, and</li><li>The low-level interface to the hardware that is managed by the lower half device driver.</li></ul><h3 id="one-to-many-encapsulation-and-polymorphism" tabindex="-1">One to Many: Encapsulation and Polymorphism <a class="header-anchor" href="#one-to-many-encapsulation-and-polymorphism" aria-label="Permalink to &quot;One to Many: Encapsulation and Polymorphism&quot;">​</a></h3><p>These modular upper- and lower-half drivers have certain properties that you would associate with an object oriented design: Encapsulation, data abstraction, and polymorphism certainly. Because of this encapsulation, the upper-half driver is complete unaware of any implementation details within the lower-half driver. Everything needed for the upper- and lower-half drivers to integrate is provided by the defined interface between between those two things. In fact, a single upper-half driver may service many lower-half driver instances in a one-to-many relationship.</p><p>As an example, some MCUs support UARTs, USARTs functioning as UARTs, Low-Power UARTs (LPUARTs), and other Flexible devices that may function as UARTs. Each of these is managed by a separate lower-half driver that can be found in the appropriate <code>src/</code> directory under <code>arch/</code>. In addition a board could have off-chip, external 16550 UART hardware (which has a common lower-half driver). Yet all of them would be supported by the single, common, serial upper half driver that can be found at <code>drivers/serial/serial.c</code>. This is only possible due to the object-like properties of the lower-half driver implementations.</p>',27)]))}const m=r(o,[["render",n]]);export{v as __pageData,m as default};
