import{_ as a,c as n,al as s,o as i}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Changing the System Clock Configuration","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/changing_systemclockconfig.md","filePath":"en/guides/changing_systemclockconfig.md"}'),t={name:"en/guides/changing_systemclockconfig.md"};function o(l,e,c,r,p,h){return i(),n("div",null,e[0]||(e[0]=[s(`<h1 id="changing-the-system-clock-configuration" tabindex="-1">Changing the System Clock Configuration <a class="header-anchor" href="#changing-the-system-clock-configuration" aria-label="Permalink to &quot;Changing the System Clock Configuration&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Changing+the+System+Clock+Configuration" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Changing+the+System+Clock+Configuration</a></p><h2 id="question" tabindex="-1">Question <a class="header-anchor" href="#question" aria-label="Permalink to &quot;Question&quot;">​</a></h2><p class="title-ref">[Is an STM32 configuration booting with the internal 16 MHz clock, then switching later (on command) to an external 25 MHz xtal doable? I don&#39;t think so, but would you mind confirming that?]</p><h2 id="answer" tabindex="-1">Answer <a class="header-anchor" href="#answer" aria-label="Permalink to &quot;Answer&quot;">​</a></h2><p>Of course, that is what always happens: The STM32 boots using an internal clock and switches to the external crystal source after booting. But I assume that you mean MUCH later on, after initialization.</p><p>Yes that can be done too. There are only a few issues and things to be aware of:</p><h3 id="custom-clock-configuration" tabindex="-1">Custom Clock Configuration <a class="header-anchor" href="#custom-clock-configuration" aria-label="Permalink to &quot;Custom Clock Configuration&quot;">​</a></h3><p>The <code>configs/vsn/</code> configuration does something like you say. It skips the initial clock configuration by defining <code>CONFIG_ARCH_BOARD_STM32_CUSTOM_CLOCKCONFIG=y</code>. Then the normal clock configuration logic in <code>arch/arm/src/stm32/stm32_rcc.c</code> is not executed. Instead, the &quot;custom&quot; clock initialization at <code>configs/vsn/src/sysclock.c</code> is called:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void stm32_clockconfig(void)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  /* Make sure that we are starting in the reset state */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  rcc_reset();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#if defined(CONFIG_ARCH_BOARD_STM32_CUSTOM_CLOCKCONFIG)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Invoke Board Custom Clock Configuration */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  stm32_board_clockconfig();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#else</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Invoke standard, fixed clock configuration based on definitions in board.h */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  stm32_stdclockconfig();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Enable peripheral clocking */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  rcc_enableperipherals();</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Doing things that way, you can have complete control over when the crystal clock source is used. The initial &quot;custom&quot; clock configuration can use an internal source, then other custom clock configuration logic can change the clock source later.</p><p>NOTE: Since this original writing, the VSN configuration has been retired and is no long in at config/vsn. The retired code can still be found in the <a href="https://bitbucket.org/patacongo/obsoleted/src/master/nuttx/configs/vsn" target="_blank" rel="noreferrer">Obsoleted repository</a>.</p><h3 id="peripheral-clocks" tabindex="-1">Peripheral Clocks <a class="header-anchor" href="#peripheral-clocks" aria-label="Permalink to &quot;Peripheral Clocks&quot;">​</a></h3><p>The peripheral clock used by many devices to set up things like the SPI frequency and UART bard rates. Currently, those peripheral clock frequencies are hardcoded in the board.h header file. So you have two options:</p><ol><li><strong>Fixed Peripheral Clocking</strong>. Ideally, you would like to keep the peripheral clock frequencies the same in either case. Then life is simple. You could probably use an internal RC clock source as input to a PLL and set up dividers so that you get the same peripheral clocks. Then, I think, from the standpoint of the peripherals, nothing happened.</li><li><strong>Variable Peripheral Clocking</strong>. You can make the peripheral clocking variable. I had to do this for the SAMA5Dx family. Look at <code>boards/arm/stm32/sama5d4-ek/include/board_sdram.h</code> for example. Notice that the frequencies are not constants, but function calls:</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#define BOARD_MAINCK_FREQUENCY     BOARD_MAINOSC_FREQUENCY</span></span>
<span class="line"><span>#define BOARD_PLLA_FREQUENCY       (sam_pllack_frequency(BOARD_MAINOSC_FREQUENCY))</span></span>
<span class="line"><span>#define BOARD_PLLADIV2_FREQUENCY   (sam_plladiv2_frequency(BOARD_MAINOSC_FREQUENCY))</span></span>
<span class="line"><span>#define BOARD_PCK_FREQUENCY        (sam_pck_frequency(BOARD_MAINOSC_FREQUENCY))</span></span>
<span class="line"><span>#define BOARD_MCK_FREQUENCY        (sam_mck_frequency(BOARD_MAINOSC_FREQUENCY))</span></span></code></pre></div><p>Given that I know that XTAL oscillator frequency I can derive the frequency of other clocks. This turns out to be more work than you would think, however, because there are probably C pre-processor tests that will now fail. Like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#if BOARD_MCK_FREQUENCY &gt; 16000000</span></span>
<span class="line"><span>... do something ...</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><p>Such logic would have to be converted from a compile time decision to a run-time decision, perhaps like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if (BOARD_MCK_FREQUENCY &gt; 16000000)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  ... do something ...</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>The SAMA5D4-EK case was intended for the case where the software is running out of SDRAM and the clocking cannot be reconfigured. Rather, it must derive the clocking as it was left by the bootloader. But you could do something like what was done for the SAMA5D4-EK when you change the frequency too. You could also make the peripheral clocks variable.</p><h3 id="reinitializing-peripherals" tabindex="-1">Reinitializing Peripherals <a class="header-anchor" href="#reinitializing-peripherals" aria-label="Permalink to &quot;Reinitializing Peripherals&quot;">​</a></h3><h3 id="variable-peripheral-clocking" tabindex="-1">Variable Peripheral Clocking <a class="header-anchor" href="#variable-peripheral-clocking" aria-label="Permalink to &quot;Variable Peripheral Clocking&quot;">​</a></h3><p>If you did something like what was done for the SAMA5D4-EK when you change the frequency, then the peripheral clocks would be variable. The main problem would then be that you would have to re-initialize the peripherals when the peripheral clocking changes. If, for example, the UART was initialized at the initial peripheral clock, then you would have to recalculate the BAUD divisor if the peripheral clock changes.</p><p>But this is not really be a big issue. You can force the UARTs to recalculate the BAUD divisor with TERMIOS ioctl calls. You could use the setfrequency() methods to recalculate I2C and SPI BAUD divisors. But there are also memory card frequencies and more.</p><h3 id="systick-timer" tabindex="-1">Systick Timer <a class="header-anchor" href="#systick-timer" aria-label="Permalink to &quot;Systick Timer&quot;">​</a></h3><p>If the CPU frequency changes, you would have to change the Systick timer configuration: It is always driven by the CPU clock</p><h3 id="up-mdelay" tabindex="-1">up_mdelay <a class="header-anchor" href="#up-mdelay" aria-label="Permalink to &quot;up\\_mdelay&quot;">​</a></h3><p>up_mdelay() provides a low level timing loop and must be re-calibrated for anything that causes change in the rate of execution of that timing loop. This calibration is not critical and fairly large errors in the calibration are tolerable. Hopefully, you could keep the execution rate close enough that up_mdelay() would not be grossly in error.</p><h3 id="power-management" tabindex="-1">Power Management <a class="header-anchor" href="#power-management" aria-label="Permalink to &quot;Power Management&quot;">​</a></h3><p>This is also the same kind of thing that you would have to do if you wanted to switch clocking for power management reasons. NuttX does have a power management system and perhaps making use of the power management system to manage system clocking changes might be possible. For example, when the clocking changes, you could force some power management state change. That state change would notify all drivers and, in response, the drivers could recalculate their frequency related settings.</p><p>Here is some Power Management documentation:</p><blockquote><p>/components/drivers/special/power/pm/index.rst</p></blockquote>`,34)]))}const g=a(t,[["render",o]]);export{u as __pageData,g as default};
