import{_ as t,c as o,al as i,o as a}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"sotest Shared Library Module Test","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/examples/sotest/index.md","filePath":"en/applications/examples/sotest/index.md"}'),l={name:"en/applications/examples/sotest/index.md"};function r(s,e,d,n,c,u){return a(),o("div",null,e[0]||(e[0]=[i(`<h1 id="sotest-shared-library-module-test" tabindex="-1"><code>sotest</code> Shared Library Module Test <a class="header-anchor" href="#sotest-shared-library-module-test" aria-label="Permalink to &quot;\`sotest\` Shared Library Module Test&quot;">​</a></h1><p>This example builds a small shared library module test case. The test shared library is built using the relocatable ELF format and installed in a ROMFS file system. At run time, the shared library is installed and exercised. Requires <code>CONFIG_LIBC_DLFCN</code>. Other configuration options:</p><ul><li><code>CONFIG_EXAMPLES_SOTEST_DEVMINOR</code> – The minor device number of the ROMFS block driver. For example, the <code>N</code> in <code>/dev/ramN</code>. Used for registering the RAM block driver that will hold the ROMFS file system containing the ELF executables to be tested. Default: <code>0</code>.</li><li><code>CONFIG_EXAMPLES_SOTEST_DEVPATH</code> – The path to the ROMFS block driver device. This must match <code>EXAMPLES_ELF_DEVMINOR</code>. Used for registering the RAM block driver that will hold the ROMFS file system containing the ELF executables to be tested. Default: <code>/dev/ram0</code>.</li></ul><p><strong>Notes</strong>:</p><ol><li><p><code>CFLAGS</code> should be provided in <code>CMODULEFLAGS</code>. RAM and FLASH memory regions may require long allcs. For ARM, this might be:</p><pre><code>CMODULEFLAGS = (CFLAGS) -mlong-calls
</code></pre><p>Similarly for C++ flags which must be provided in <code>CXXMODULEFLAGS</code>.</p></li><li><p>Your top-level <code>nuttx/Make.defs</code> file must also include an appropriate definition, <code>LDMODULEFLAGS</code>, to generate a relocatable ELF object. With GNU LD, this should include <code>-r</code> and <code>-e &lt;entry point&gt;</code>.:</p><pre><code>LDMODULEFLAGS = -r -e module_initialize
</code></pre><p>If you use GCC to link, you make also need to include <code>-nostdlib</code>.</p></li><li><p>This example also requires <code>genromfs</code>. <code>genromfs</code> can be build as part of the nuttx toolchain. Or can built from the <code>genromfs</code> sources that can be found in the NuttX tools repository (<code>genromfs-0.5.2.tar.gz</code>). In any event, the <code>PATH</code> variable must include the path to the <code>genromfs</code> executable.</p></li><li><p>ELF size: The ELF files in this example are, be default, quite large because they include a lot of build garbage. You can greatly reduce the size of the ELF binaries are using the <code>objcopy --strip-unneeded</code> command to remove un-necessary information from the ELF files.</p></li><li><p>Simulator. You cannot use this example with the NuttX simulator on Cygwin. That is because the Cygwin GCC does not generate ELF file but rather some Windows-native binary format.</p><p>If you really want to do this, you can create a NuttX x86 buildroot toolchain and use that be build the ELF executables for the ROMFS file system.</p></li><li><p>Linker scripts. You might also want to use a linker scripts to combine sections better. An example linker script is at <code>nuttx/libc/elf/gnu-elf.ld</code>. That example might have to be tuned for your particular linker output to position additional sections correctly. The GNU LD <code>LDMODULEFLAGS</code> then might be:</p><pre><code>LDMODULEFLAGS = -r -e module_initialize -T(TOPDIR)/libc/elf/gnu-elf.ld
</code></pre></li></ol>`,5)]))}const m=t(l,[["render",r]]);export{p as __pageData,m as default};
