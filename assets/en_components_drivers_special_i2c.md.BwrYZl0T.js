import{_ as i,c as r,al as c,o as t}from"./chunks/framework.NFAqBSgQ.js";const _=JSON.parse('{"title":"I2C Device Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/special/i2c.md","filePath":"en/components/drivers/special/i2c.md"}'),s={name:"en/components/drivers/special/i2c.md"};function a(o,e,d,n,l,v){return t(),r("div",null,e[0]||(e[0]=[c('<h1 id="i2c-device-drivers" tabindex="-1">I2C Device Drivers <a class="header-anchor" href="#i2c-device-drivers" aria-label="Permalink to &quot;I2C Device Drivers&quot;">â€‹</a></h1><ul><li><code>include/nuttx/i2c/i2c_master.h</code> and <code>include/nuttx/i2c/i2c_slave.h</code>. All structures and APIs needed to work with I2C drivers are provided in this header file.</li><li><code>struct i2c_ops_s</code>. Each I2C device driver must implement an instance of <code>struct i2c_ops_s</code>. That structure defines a call table with the following methods:</li><li><strong>Binding I2C Drivers</strong>. I2C drivers are not normally directly accessed by user code, but are usually bound to another, higher level device driver. In general, the binding sequence is: <ol><li>Get an instance of <code>struct i2c_master_s</code> from the hardware-specific I2C device driver, and</li><li>Provide that instance to the initialization method of the higher level device driver.</li></ol></li><li><strong>Examples</strong>: <code>arch/z80/src/ez80/ez80_i2c.c</code>, <code>arch/z80/src/z8/z8_i2c.c</code>, etc.</li><li><code>struct i2c_slaveops_s</code>. Each I2C slave device driver must implement an instance of <code>struct i2c_slaveops_s</code>. That structure defines a call table with the following methods:</li><li><strong>Binding I2C Slave Drivers</strong>. I2C slave drivers are normally directly accessed by user code, We can read and write to device nodes using posix interfaces.</li></ul>',2)]))}const u=i(s,[["render",a]]);export{_ as __pageData,u as default};
