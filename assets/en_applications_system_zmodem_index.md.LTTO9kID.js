import{_ as t,c as o,al as a,o as r}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"zmodem Zmodem Commands","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/system/zmodem/index.md","filePath":"en/applications/system/zmodem/index.md"}'),n={name:"en/applications/system/zmodem/index.md"};function i(d,e,s,l,c,h){return r(),o("div",null,e[0]||(e[0]=[a(`<h1 id="zmodem-zmodem-commands" tabindex="-1"><code>zmodem</code> Zmodem Commands <a class="header-anchor" href="#zmodem-zmodem-commands" aria-label="Permalink to &quot;\`zmodem\` Zmodem Commands&quot;">​</a></h1><h2 id="contents" tabindex="-1">Contents <a class="header-anchor" href="#contents" aria-label="Permalink to &quot;Contents&quot;">​</a></h2><ul><li>Buffering Notes <ul><li>Hardware Flow Control</li><li>RX Buffer Size</li><li>Buffer Recommendations</li></ul></li><li>Using NuttX ZModem with a Linux Host <ul><li>Sending Files from the Target to the Linux Host PC</li><li>Receiving Files on the Target from the Linux Host PC</li></ul></li><li>Building the ZModem Tools to Run Under Linux</li><li>Status</li></ul><h2 id="buffering-notes" tabindex="-1">Buffering Notes <a class="header-anchor" href="#buffering-notes" aria-label="Permalink to &quot;Buffering Notes&quot;">​</a></h2><h3 id="hardware-flow-control" tabindex="-1">Hardware Flow Control <a class="header-anchor" href="#hardware-flow-control" aria-label="Permalink to &quot;Hardware Flow Control&quot;">​</a></h3><p>Hardware flow control must be enabled in serial drivers in order to prevent data overrun. However, in the most NuttX serial drivers, hardware flow control only protects the hardware RX FIFO: Data will not be lost in the hardware FIFO but can still be lost when it is taken from the FIFO. We can still overflow the serial driver&#39;s RX buffer even with hardware flow control enabled! That is probably a bug. But the workaround solution that I have used is to use lower data rates and a large serial driver RX buffer.</p><p>Those measures should be unnecessary if buffering and hardware flow control are set up and working correctly.</p><h3 id="software-flow-control" tabindex="-1">Software Flow Control <a class="header-anchor" href="#software-flow-control" aria-label="Permalink to &quot;Software Flow Control&quot;">​</a></h3><p>The ZModem protocol has <code>XON/XOFF</code> flow control built into it. The protocol permits <code>XON</code> or <code>XOFF</code> characters placed at certain parts of messages. If software flow control is enabled on the receiving end it will consume the <code>XON</code> s and <code>XOFF</code> s. Otherwise they will be ignored in the data by the ZModem logic.</p><p>NuttX, however, does not implement <code>XON/XOFF</code> flow control so these do nothing. On NuttX you will have to use hardware flow control in most cases.</p><p>The <code>XON</code> / <code>XOFF</code> controls built into ZModem could be used if you enabled software flow control in the host. But that would only work in one direction: If would prevent the host from overrunning the the target Rx buffering. So you should be able to do host-to-target software flow control. But there would still be no target-to-host flow control. That might not be an issue because the host is usually so much faster than that target.</p><h3 id="rx-buffer-size" tabindex="-1">RX Buffer Size <a class="header-anchor" href="#rx-buffer-size" aria-label="Permalink to &quot;RX Buffer Size&quot;">​</a></h3><p>The ZModem protocol supports a message that informs the file sender of the maximum size of data that you can buffer (<code>ZRINIT</code>). However, my experience is that the Linux sz ignores this setting and always sends file data at the maximum size (<code>1024</code>) no matter what size of buffer you report. That is unfortunate because that, combined with the possibilities of data overrun mean that you must use quite large buffering for ZModem file receipt to be reliable (none of these issues effect sending of files).</p><h3 id="buffer-recommendations" tabindex="-1">Buffer Recommendations <a class="header-anchor" href="#buffer-recommendations" aria-label="Permalink to &quot;Buffer Recommendations&quot;">​</a></h3><p>Based on the limitations of NuttX hardware flow control and of the Linux sz behavior, I have been testing with the following configuration (assuming <code>UART1</code> is the ZModem device):</p><ol><li><p>This setting determines that maximum size of a data packet frame:</p><pre><code>CONFIG_SYSTEM_ZMODEM_PKTBUFSIZE=1024
</code></pre></li><li><p>Input Buffering. If the input buffering is set to a full frame, then data overflow is less likely:</p><pre><code>CONFIG_UART1_RXBUFSIZE=1024
</code></pre></li><li><p>With a larger driver input buffer, the ZModem receive I/O buffer can be smaller:</p><pre><code>CONFIG_SYSTEM_ZMODEM_RCVBUFSIZE=256
</code></pre></li><li><p>Output buffering. Overrun cannot occur on output (on the NuttX side) so there is no need to be so careful:</p><pre><code>CONFIG_SYSTEM_ZMODEM_SNDBUFSIZE=512
CONFIG_UART1_TXBUFSIZE=256
</code></pre></li></ol><h2 id="using-nuttx-zmodem-with-a-linux-host" tabindex="-1">Using NuttX ZModem with a Linux Host <a class="header-anchor" href="#using-nuttx-zmodem-with-a-linux-host" aria-label="Permalink to &quot;Using NuttX ZModem with a Linux Host&quot;">​</a></h2><h3 id="sending-files-from-the-target-to-the-linux-host-pc" tabindex="-1">Sending Files from the Target to the Linux Host PC <a class="header-anchor" href="#sending-files-from-the-target-to-the-linux-host-pc" aria-label="Permalink to &quot;Sending Files from the Target to the Linux Host PC&quot;">​</a></h3><p>The NuttX ZModem commands have been verified against the rzsz programs running on a Linux PC. To send a file to the PC, first make sure that the serial port is configured to work with the board (Assuming you are using 9600 baud for the data transfers - high rates may result in data overruns):</p><pre><code> sudo stty -F /dev/ttyS0 9600     # Select 9600 BAUD
 sudo stty -F /dev/ttyS0 crtscts  # Enables CTS/RTS handshaking *
 sudo stty -F /dev/ttyS0 raw      # Puts the TTY in raw mode
 sudo stty -F /dev/ttyS0          # Show the TTY configuration
</code></pre><p>Only if hardware flow control is enabled.</p><p>Start <code>rz</code> on the Linux host (using <code>/dev/ttyS0</code> as an example):</p><pre><code> sudo rz &lt; /dev/ttyS0 &gt; /dev/ttyS0
</code></pre><p>You can add the <code>rz -v</code> option multiple times, each increases the level of debug output. If you want to capture the Linux <code>rz</code> output, then re-direct <code>stderr</code> to a log file by adding <code>2&gt;rz.log</code> to the end of the <code>rz</code> command.</p><p><strong>Note</strong>: The NuttX ZModem does sends <code>rz\\n</code> when it starts in compliance with the ZModem specification. On Linux this, however, seems to start some other, incompatible version of <code>rz</code>. You need to start <code>rz</code> manually to make sure that the correct version is selected. You can tell when this evil <code>rz</code>/<code>sz</code> has inserted itself because you will see the <code>^</code> (<code>0x5e</code>) character replacing the standard ZModem <code>ZDLE</code> character (<code>0x19</code>) in the binary data stream.</p><p>If you don&#39;t have the <code>rz</code> command on your Linux box, the package to install <code>rzsz</code> (or possibly <code>lrzsz</code>).</p><p>Then on the target (using <code>/dev/ttyS1</code> as an example):</p><pre><code>nsh&gt; sz -d /dev/ttyS1 &lt;filename&gt;
</code></pre><p>Where filename is the full path to the file to send (i.e., it begins with the <code>/</code> character). <code>/dev/ttyS1</code> or whatever device you select <strong>must</strong> support Hardware flow control in order to throttle therates of data transfer to fit within the allocated buffers.</p><h3 id="receiving-files-on-the-target-from-the-linux-host-pc" tabindex="-1">Receiving Files on the Target from the Linux Host PC <a class="header-anchor" href="#receiving-files-on-the-target-from-the-linux-host-pc" aria-label="Permalink to &quot;Receiving Files on the Target from the Linux Host PC&quot;">​</a></h3><p><strong>Note</strong>: There are issues with using the Linux <code>sz</code> command with the NuttX <code>rz</code> command. See _<a href="#status">Status</a> below. It is recommended that you use the NuttX <code>sz</code> command on Linux as described in the next paragraph.</p><p>To send a file to the target, first make sure that the serial port on the host is configured to work with the board (Assuming that you are using <code>9600</code> baud for the data transfers - high rates may result in data overruns):</p><pre><code> sudo stty -F /dev/ttyS0 9600     # Select 9600 (or other) BAUD
 sudo stty -F /dev/ttyS0 crtscts  # Enables CTS/RTS handshaking *
 sudo stty -F /dev/ttyS0 raw      # Puts the TTY in raw mode
 sudo stty -F /dev/ttyS0          # Show the TTY configuration
</code></pre><p>Only is hardware flow control is enabled.</p><p>Start <code>rz</code> on the on the target. Here, in this example, we are using <code>/dev/ttyS1</code> to perform the transfer:</p><pre><code>nsh&gt; rz -d /dev/ttyS1
</code></pre><p><code>/dev/ttyS1</code> or whatever device you select <strong>must</strong> support Hardware flow control in order to throttle therates of data transfer to fit within the allocated buffers.</p><p>Then use the <code>sz</code> command on Linux to send the file to the target:</p><pre><code> sudo sz &lt;filename&gt; [-l nnnn] [-w nnnn] &lt;/dev/ttyS0 &gt;/dev/ttyS0
</code></pre><p>Where <code>&lt;filename&gt;</code> is the file that you want to send. If <code>-l nnnn</code> and <code>-w nnnn</code> is not specified, then there will likely be packet buffer overflow errors. <code>nnnn</code> should be set to a value less than or equal to <code>CONFIG_SYSTEM_ZMODEM_PKTBUFSIZE</code>.</p><p>The resulting file will be found where you have configured the ZModem <strong>sandbox</strong> via <code>CONFIG_SYSTEM_ZMODEM_MOUNTPOINT</code>.</p><p>You can add the <code>sz -v</code> option multiple times, each increases the level of debug output. If you want to capture the Linux <code>sz</code> output, then re-direct <code>stderr</code> to a log file by adding <code>2&gt;sz.log</code> to the end of the <code>sz</code> command.</p><p>If you don&#39;t have the sz command on your Linux box, the package to install <code>rzsz</code> (or possibly <code>lrzsz</code>).</p><h2 id="building-the-zmodem-tools-to-run-under-linux" tabindex="-1">Building the ZModem Tools to Run Under Linux <a class="header-anchor" href="#building-the-zmodem-tools-to-run-under-linux" aria-label="Permalink to &quot;Building the ZModem Tools to Run Under Linux&quot;">​</a></h2><p>Build support has been added so that the NuttX ZModem implementation can be executed on a Linux host PC. This can be done by</p><ul><li>Change to the <code>apps/systems/zmodem</code> directory</li><li>Make using the special makefile, <code>Makefile.host</code></li></ul><p><strong>Notes</strong>:</p><ol><li><p><code>TOPDIR</code> and <code>APPDIR</code> must be defined on the make command line: <code>TOPDIR</code> is the full path to the <code>nuttx/</code> directory; <code>APPDIR</code> is the full path to the <code>apps/</code> directory. For example, if you installed nuttx at <code>/home/me/projects/nuttx</code> and apps at <code>/home/me/projects/apps</code>, then the correct make command line would be:</p><pre><code>make -f Makefile.host TOPDIR=/home/me/projects/nuttx APPDIR=/home/me/projects/apps
</code></pre></li><li><p>Add <code>CONFIG_DEBUG_FEATURES=1</code> to the make command line to enable debug output</p></li><li><p>Make sure to clean old target <code>.o</code> files before making new host <code>.o</code> files.</p></li></ol><p>This build is has been verified as of <code>2013-7-16</code> using Linux to transfer files with an Olimex LPC1766STK board. It works great and seems to solve all of the problems found with the Linux <code>sz</code>/<code>rz</code> implementation.</p><h2 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h2><ul><li><p><code>2013-7-15</code>: Testing against the Linux <code>rz</code>/<code>sz</code> commands.</p><p>I have tested with the <code>boards/arm/lpc17xx_40xx/olimex-lpc1766stk</code> configuration. I have been able to send large and small files with the target <code>sz</code> command. I have been able to receive small files, but there are problems receiving large files using the Linux <code>sz</code> command: The Linux <code>sz</code> does not obey the buffering limits and continues to send data while <code>rz</code> is writing the previously received data to the file and the serial driver&#39;s RX buffer is overrun by a few bytes while the write is in progress. As a result, when it reads the next buffer of data, a few bytes may be missing. The symptom of this missing data is a CRC check failure.</p><p>Either (1) we need a more courteous host application, or (2) we need to greatly improve the target side buffering capability!</p><p>My thought now is to implement the NuttX <code>sz</code> and <code>rz</code> commands as PC side applications as well. Matching both sides and obeying the handshaking will solve the issues. Another option might be to fix the serial driver hardware flow control somehow.</p></li><li><p><code>2013-7-16</code>. More Testing against the Linux <code>rz</code>/<code>sz</code> commands.</p><p>I have verified that with debug off and at lower serial BAUD (<code>2400</code>), the transfers of large files succeed without errors. I do not consider this a _<a href="./.html">solution</a> to the problem. I also found that the LPC17xx hardware flow control caused strange hangs; ZModem works better with hardware flow control disabled on the LPC17xx.</p><p>At this lower BAUD, RX buffer sizes could probably be reduced; Or perhaps the BAUD could be increased. My thought, however, is that tuning in such an unhealthy situation is not the approach: The best thing to do would be to use the matching NuttX sz on the Linux host side.</p></li><li><p><code>2013-7-16</code>. More Testing against the NuttX <code>rz</code>/<code>sz</code> on Both Ends.</p><p>The NuttX <code>sz</code>/<code>rz</code> commands have been modified so that they can be built and executed under Linux. In this case, there are no transfer problems at all in either direction and with large or small files. This configuration could probably run at much higher serial speeds and with much smaller buffers (although that has not been verified as of this writing).</p></li><li><p><code>2018-5-27</code></p><p>Updates to checksum calculations. Verified correct operation with hardware flow control using the <code>olimex-stm32-p407/zmodem</code> configuration. Only the host-to-target transfer was verified.</p><p>This was using the Linux <code>sz</code> utility. There appears to still be a problem using the NuttX <code>sz</code> utility running on Linux.</p></li><li><p><code>2018-5-27</code></p><p>Verified correct operation with hardware flow control using the <code>olimex-stm32-p407/zmodem</code> configuration with target-to-host transfers was verified. Again, there are issues remaining if I tried the NuttX <code>rz</code> utility running on Linux.</p></li><li><p><code>2018-6-26</code></p><p>With <code>-w nnnn</code> option, the host-to-target transfer can work reliably without hardware flow control.</p></li></ul>`,51)]))}const m=t(n,[["render",i]]);export{f as __pageData,m as default};
