import{_ as i,c as s,al as r,j as e,a as t,o as a}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"Counting Semaphore Interfaces","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/user/05_counting_semaphore.md","filePath":"en/reference/user/05_counting_semaphore.md"}'),n={name:"en/reference/user/05_counting_semaphore.md"};function l(c,o,h,p,m,d){return a(),s("div",null,o[0]||(o[0]=[r('<h1 id="counting-semaphore-interfaces" tabindex="-1">Counting Semaphore Interfaces <a class="header-anchor" href="#counting-semaphore-interfaces" aria-label="Permalink to &quot;Counting Semaphore Interfaces&quot;">â€‹</a></h1><p><strong>Semaphores</strong>. Semaphores are the basis for synchronization and mutual exclusion in NuttX. NuttX supports POSIX semaphores.</p><p>Semaphores are the preferred mechanism for gaining exclusive access to a resource. sched_lock() and sched_unlock() can also be used for this purpose. However, sched_lock() and sched_unlock() have other undesirable side-effects in the operation of the system: sched_lock() also prevents higher-priority tasks from running that do not depend upon the semaphore-managed resource and, as a result, can adversely affect system response times.</p><p>Priority Inversion. Proper use of semaphores avoids the issues of <code>sched_lock()</code>. However, consider the following example:</p><blockquote><ol><li>Some low-priority task, <em>Task C</em>, acquires a semaphore in order to get exclusive access to a protected resource.</li><li><em>Task C</em> is suspended to allow some high-priority task,</li><li><em>Task A</em> attempts to acquire the semaphore held by <em>Task C</em> and gets blocked until <em>Task C</em> relinquishes the semaphore.</li><li><em>Task C</em> is allowed to execute again, but gets suspended by some medium-priority <em>Task B</em>.</li></ol></blockquote><p>At this point, the high-priority <em>Task A</em> cannot execute until <em>Task B</em> (and possibly other medium-priority tasks) completes and until <em>Task C</em> relinquishes the semaphore. In effect, the high-priority task, <em>Task A</em> behaves as though it were lower in priority than the low-priority task, <em>Task C</em>! This phenomenon is called <em>priority inversion</em>.</p><p>Some operating systems avoid priority inversion by <em>automatically</em> increasing the priority of the low-priority <em>Task C</em> (the operable buzz-word for this behavior is <em>priority inheritance</em>). NuttX supports this behavior, but only if <code>CONFIG_PRIORITY_INHERITANCE</code> is defined in your OS configuration file. If <code>CONFIG_PRIORITY_INHERITANCE</code> is not defined, then it is left to the designer to provide implementations that will not suffer from priority inversion. The designer may, as examples:</p><blockquote><ul><li>Implement all tasks that need the semaphore-managed resources at the same priority level,</li><li>Boost the priority of the low-priority task before the semaphore is acquired, or</li><li>Use sched_lock() in the low-priority task.</li></ul></blockquote><p>Priority Inheritance. As mentioned, NuttX does support <em>priority inheritance</em> provided that <code>CONFIG_PRIORITY_INHERITANCE</code> is defined in your OS configuration file. However, the implementation and configuration of the priority inheritance feature is sufficiently complex that more needs to be said. How can a feature that can be described by a single, simple sentence require such a complex implementation:</p><blockquote><ul><li><p><code>CONFIG_SEM_PREALLOCHOLDERS</code>. First of all, in NuttX priority inheritance is implement on POSIX counting semaphores. The reason for this is that these semaphores are the most primitive waiting mechanism in NuttX; Most other waiting facilities are based on semaphores. So if priority inheritance is implemented for POSIX counting semaphores, then most NuttX waiting mechanisms will have this capability.</p><p>Complexity arises because counting semaphores can have numerous holders of semaphore counts. Therefore, in order to implement priority inheritance across all holders, then internal data structures must be allocated to manage the various holders associated with a semaphore. The setting <code>CONFIG_SEM_PREALLOCHOLDERS</code> defines the maximum number of different threads (minus one per semaphore instance) that can take counts on a semaphore with priority inheritance support. This setting defines the size of a single pool of pre-allocated structures. It may be set to zero if priority inheritance is disabled OR if you are only using semaphores as mutexes (only one holder) OR if no more than two threads participate using a counting semaphore.</p><p>The cost associated with setting <code>CONFIG_SEM_PREALLOCHOLDERS</code> is slightly increased code size and around 6-12 bytes times the value of <code>CONFIG_SEM_PREALLOCHOLDERS</code>.</p></li><li><p><strong>Increased Susceptibility to Bad Thread Behavior</strong>. These various structures tie the semaphore implementation more tightly to the behavior of the implementation. For examples, if a thread executes while holding counts on a semaphore, or if a thread exits without call <code>sem_destroy()</code> then. Or what if the thread with the boosted priority re-prioritizes itself? The NuttX implement of priority inheritance attempts to handle all of these types of corner cases, but it is very likely that some are missed. The worst case result is that memory could by stranded within the priority inheritance logic.</p></li></ul></blockquote><p>Locking versus Signaling Semaphores. Semaphores (and mutexes) may be used for many different purposes. One typical use is for mutual exclusion and locking of resources: In this usage, the thread that needs exclusive access to a resources takes the semaphore to get access to the resource. The same thread subsequently releases the semaphore count when it no longer needs exclusive access. Priority inheritance is intended just for this usage case.</p><p>In a different usage case, a semaphore may to be used to signal an event: One thread A waits on a semaphore for an event to occur. When the event occurs, another thread B will post the semaphore waking the waiting thread A. This is a completely different usage model; notice that in the mutual exclusion case, the same thread takes and posts the semaphore. In the signaling case, one thread takes the semaphore and a different thread posts the semaphore. Priority inheritance should <em>never</em> be used in this signaling case. Subtle, strange behaviors may result.</p><p>Semaphore does not support priority inheritance by default. If you need to use a semaphore as a mutex you need to change its default behavior.</p><p>In user space, it is recommended to use pthread_mutex instead of semaphore for resource protection</p><p>When priority inheritance is enabled with <code>CONFIG_PRIORITY_INHERITANCE</code>, the default <em>protocol</em> for the semaphore will be to use priority inheritance. For signaling semaphores, priority inheritance must be explicitly disabled by calling <code>`sem_setprotocol</code> &lt;#semsetprotocol&gt;[__ with ]{.title-ref}[SEM_PRIO_NONE]{.title-ref}[. For the case of pthread mutexes, ]{.title-ref}<code>pthread_mutexattr_setprotocol</code> &lt;#pthreadmutexattrsetprotocol&gt;[__ with ]{.title-ref}[PTHREAD_PRIO_NONE]{.title-ref}`.</p><p>This is discussed in much more detail on this <a href="https://cwiki.apache.org/confluence/display/NUTTX/Signaling+Semaphores+and+Priority+Inheritance" target="_blank" rel="noreferrer">Wiki page</a>.</p><p><strong>POSIX semaphore interfaces:</strong></p>',17),e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_init")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_destroy")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_open")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_close")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_unlink")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_wait")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_timedwait")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_trywait")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_post")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_getvalue")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_getprotocol")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sem_setprotocol")])],-1)]))}const g=i(n,[["render",l]]);export{f as __pageData,g as default};
