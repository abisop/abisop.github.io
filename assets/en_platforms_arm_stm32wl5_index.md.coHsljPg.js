import{_ as o,c as s,al as r,j as e,a,o as i}from"./chunks/framework.NFAqBSgQ.js";const b=JSON.parse('{"title":"ST STM32WL5","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/stm32wl5/index.md","filePath":"en/platforms/arm/stm32wl5/index.md"}'),n={name:"en/platforms/arm/stm32wl5/index.md"};function l(d,t,c,h,p,u){return i(),s("div",null,t[0]||(t[0]=[r('<h1 id="st-stm32wl5" tabindex="-1">ST STM32WL5 <a class="header-anchor" href="#st-stm32wl5" aria-label="Permalink to &quot;ST STM32WL5&quot;">​</a></h1><p>The STM32WL5 is a dual CPU (not core!) chip based on ARM Cortex-M4 and Cortex-M0 with integrated sub-GHz radio for LoRa (G)FSK, (G)MSK and BPSK modulations.</p><p>Only Cortex-M0 has access to radio peripheral. Pipe between CPUs exists so that radio packets can be exchanged between CPUs. Chip was designed so that Cortex-M0 cpu handles radio traffic while Cortex-M4 cpu handles actions based on traffic received. All other peripherals are shared (like uart, spi, i2c) and both CPUs can initiate them, but it&#39;s required to be done only by one of them.</p><h2 id="supported-mcus" tabindex="-1">Supported MCUs <a class="header-anchor" href="#supported-mcus" aria-label="Permalink to &quot;Supported MCUs&quot;">​</a></h2><p>STM32WL5 has only two chips in family. STM32WL55 and STM32WL54. Only difference between them is that STM32WL55 has support for LoRa while Stm32WL54 does not.</p><h2 id="peripheral-support" tabindex="-1">Peripheral Support <a class="header-anchor" href="#peripheral-support" aria-label="Permalink to &quot;Peripheral Support&quot;">​</a></h2><p>The following list indicates peripherals supported in NuttX:</p><p>Peripheral Support Notes</p><hr><p>IRQs GPIO EXTI HSE Yes Yes Yes Yes<br> PLL Yes Tested @ 48MHz HSI Yes Not tested MSI Yes Not tested LSE Yes Not tested RCC Yes All registers defined, not all peripherals enabled SYSCFG USART Yes Yes All registers defined, GPIO EXTI works, remapping not tested LPUART Yes full speed with HSE works, low power mode with LSE not implemented FLASH DMA SRAM2 SPI I2C RTC Timers PM AES RNG CRC WWDG IWDG ADC DAC IPCC <a href="mailto:Radio@CPU0" target="_blank" rel="noreferrer">Radio@CPU0</a> Yes No No No No No No No No No No No No No No No No Progmem implementation - mtd filesystems like smartfs or nxffs work</p><h3 id="pll" tabindex="-1">PLL <a class="header-anchor" href="#pll" aria-label="Permalink to &quot;PLL&quot;">​</a></h3><p>PLL is a module that allows MCU to generate higher (or lower) clocks than provided by the source. For example it can be used to drive system clock with 48MHz when 8MHz HSE crystal is installed.</p><h3 id="lse" tabindex="-1">LSE <a class="header-anchor" href="#lse" aria-label="Permalink to &quot;LSE&quot;">​</a></h3><p>Low speed external crystal. Can be used to clock RTC and/or independent watchdog (IWDG). LSE is usually 32768Hz high precision crystal.</p><h3 id="hsi" tabindex="-1">HSI <a class="header-anchor" href="#hsi" aria-label="Permalink to &quot;HSI&quot;">​</a></h3><p>High speed internal clock. Can be used as a source for sysclk and internal buses (APB, AHB). This clock source is not as precise or as stable as HSE, but it cuts down costs by avoiding external hardware (crystal and capacitors) and is usually good enough if operating temperatures are stable. It&#39;s clock is fixed at 16MHz.</p><h3 id="msi" tabindex="-1">MSI <a class="header-anchor" href="#msi" aria-label="Permalink to &quot;MSI&quot;">​</a></h3><p>Adjustable internal clock. Can be adjusted by software, but it&#39;s accuracy and stability is even lower than HSI.</p><h3 id="hse" tabindex="-1">HSE <a class="header-anchor" href="#hse" aria-label="Permalink to &quot;HSE&quot;">​</a></h3><p>High speed external crystal. Can be used to clock sysclk and internal buses (APB, AHB). External crystal is more precise and more stable than HSI.</p><h3 id="rcc" tabindex="-1">RCC <a class="header-anchor" href="#rcc" aria-label="Permalink to &quot;RCC&quot;">​</a></h3><p>Reset and clock control. Enables or disables specific peripherals.</p><h3 id="syscfg" tabindex="-1">SYSCFG <a class="header-anchor" href="#syscfg" aria-label="Permalink to &quot;SYSCFG&quot;">​</a></h3><p>System configuration controller. Can be used to remap memory or manage GPIO multiplexer for EXTI.</p><h3 id="gpio" tabindex="-1">GPIO <a class="header-anchor" href="#gpio" aria-label="Permalink to &quot;GPIO&quot;">​</a></h3>',25),e("p",null,[a("Pins can be configured using :c"),e("code",null,"stm32wl5_configgpio"),a('{.interpreted-text role="func"} function. Writing to pins is done by :c'),e("code",{class:"interpreted-text",role:"func"},"stm32wl5_gpiowrite"),a(" function and reading is done by :c"),e("code",{class:"interpreted-text",role:"func"},"stm32wl5_gpioread"),a(".")],-1),r('<h3 id="uart" tabindex="-1">UART <a class="header-anchor" href="#uart" aria-label="Permalink to &quot;UART&quot;">​</a></h3><p>Universal Asynchronous Receiver/Transmitter module. UART is initialized automatically during MCU boot.</p><h3 id="ipcc" tabindex="-1">IPCC <a class="header-anchor" href="#ipcc" aria-label="Permalink to &quot;IPCC&quot;">​</a></h3><p>Inter-processor communication controller. IPCC is used to exchange data between Cortex-M4 and Cortex-M0 CPUs.</p><h3 id="exti" tabindex="-1">EXTI <a class="header-anchor" href="#exti" aria-label="Permalink to &quot;EXTI&quot;">​</a></h3><p>Extended interrupts and event controller. Extends interrupts not provided by NVIC. For example, there is only one interrupt for GPIO5..9 in NVIC, but thanks to EXTI we can differentiate which GPIO caused interrupt. Such interrupt first goes through EXTI and is then forwarded to main NVIC.</p><p>EXTI for gpio can be enabled via [stm32wl5_gpiosetevent]{.title-ref} function.</p><h3 id="flash" tabindex="-1">FLASH <a class="header-anchor" href="#flash" aria-label="Permalink to &quot;FLASH&quot;">​</a></h3><p>Place where program code lives. Part of flash can also be used to create small filesystems like nxffs or smartfs to hold persistent data between reboots without the need of attaching external flash or mmc card. Since flash has limited number of erases (writes) it&#39;s best to hold there only data that is no frequently updated (so, configuration is ok, logs are not).</p><h2 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h2><blockquote><p>boards/<em>/</em></p></blockquote>',11)]))}const f=o(n,[["render",l]]);export{b as __pageData,f as default};
