import{_ as a,c as n,al as t,o as s}from"./chunks/framework.NFAqBSgQ.js";const g=JSON.parse('{"title":"Debugging / flashing NuttX on ARM with hardware debugger (JTAG/SWD)","description":"","frontmatter":{},"headers":[],"relativePath":"en/debugging/debuggingflash_nuttxonarm.md","filePath":"en/debugging/debuggingflash_nuttxonarm.md"}'),i={name:"en/debugging/debuggingflash_nuttxonarm.md"};function o(l,e,p,r,c,d){return s(),n("div",null,e[0]||(e[0]=[t(`<h1 id="debugging-flashing-nuttx-on-arm-with-hardware-debugger-jtag-swd" tabindex="-1">Debugging / flashing NuttX on ARM with hardware debugger (JTAG/SWD) <a class="header-anchor" href="#debugging-flashing-nuttx-on-arm-with-hardware-debugger-jtag-swd" aria-label="Permalink to &quot;Debugging / flashing NuttX on ARM with hardware debugger (JTAG/SWD)&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629444" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629444</a></p><p>NOTE: If you experience the issues described on this page, you can enable the configuration option below to resolve it.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CONFIG_STM32_DISABLE_IDLE_SLEEP_DURING_DEBUG=y</span></span></code></pre></div><h2 id="what-s-the-problem" tabindex="-1">What&#39;s the problem? <a class="header-anchor" href="#what-s-the-problem" aria-label="Permalink to &quot;What\\&#39;s the problem?&quot;">​</a></h2><p>On some architectures (like ARM Cortex-M3) Idle thread causes the core to stop using WFI (Wait For Interrupt) assembly instruction. This effectively stops clocking of the core, which is resumed only by some enabled interrupt. This causes hardware debuggers to believe that they were disconnected from the target, as they lose connection with the now stopped core. For example OpenOCD shows errors like these the moment you start the target:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Error: jtag status contains invalid mode value - communication failure</span></span>
<span class="line"><span>Polling target failed, GDB will be halted. Polling again in 100ms</span></span>
<span class="line"><span>Error: jtag status contains invalid mode value - communication failure</span></span>
<span class="line"><span>Polling target failed, GDB will be halted. Polling again in 300ms</span></span>
<span class="line"><span>Error: jtag status contains invalid mode value - communication failure</span></span>
<span class="line"><span>Polling target failed, GDB will be halted. Polling again in 700ms</span></span>
<span class="line"><span>Error: jtag status contains invalid mode value - communication failure</span></span>
<span class="line"><span>Polling target failed, GDB will be halted. Polling again in 1500ms</span></span>
<span class="line"><span>Error: jtag status contains invalid mode value - communication failure</span></span>
<span class="line"><span>Polling target failed, GDB will be halted. Polling again in 3100ms</span></span>
<span class="line"><span>Error: jtag status contains invalid mode value - communication failure</span></span>
<span class="line"><span>Polling target failed, GDB will be halted. Polling again in 6300ms</span></span>
<span class="line"><span>Error: jtag status contains invalid mode value - communication failure</span></span>
<span class="line"><span>Polling target failed, GDB will be halted. Polling again in 6300ms</span></span></code></pre></div><p>This makes debugging the code impossible and flashing the chip is much harder -you have to connect to the chip at the right moment (when it&#39;s not disabled due to WFI) - the chances of doing that are inverse proportional to the load of your system (if your chip spends 99% of time in Idle mode, you have 1% chance of connecting and halting it).</p><h2 id="solution" tabindex="-1">Solution <a class="header-anchor" href="#solution" aria-label="Permalink to &quot;Solution&quot;">​</a></h2><p>Some ARM cores that support disabling of clocking after WFI instruction have special configuration options to make debugging possible. One example is STM32 family - with it&#39;s <code>DBGMCU-&gt;CR</code> register it&#39;s possible to keep the core clocked during power-down modes. If your chip supports such configuration you should put it in some early stage of initialization, like in <code>stm32_boardinitialize()</code> function. The following code demonstrates the change for STM32:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uint32_t cr = getreg32(STM32_DBGMCU_CR);</span></span>
<span class="line"><span>cr |= DBGMCU_CR_STANDBY | DBGMCU_CR_STOP | DBGMCU_CR_SLEEP;</span></span>
<span class="line"><span>putreg32(cr, STM32_DBGMCU_CR);</span></span></code></pre></div><p>If your chip doesn&#39;t provide such options there is no other way than not using WFI instruction in up_idle() function.</p><p>It should be noted that such modification should be done only for development stage, as keeping the core clocked during power-down modes contradicts the major purpose of using them - reducing power usage.</p><p>In rare cases that you still have problems with connecting to the target (especially after power cycle), you should try connecting and halting the chip under reset (this is supported by new versions of OpenOCD), by holding the reset button while starting OpenOCD or by configuring OpenOCD to do that for you.</p><h3 id="work-around" tabindex="-1">Work-around <a class="header-anchor" href="#work-around" aria-label="Permalink to &quot;Work-around&quot;">​</a></h3><p>If you keep the RESET button pressed and run OpenOCD command to connected to it, then it will connect successful. After connecting you need to keep the reset button pressed until you open the telnet connection (telnet 127.0.0.1 4444) and execute &quot;reset halt&quot;:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&gt; reset halt</span></span>
<span class="line"><span>timed out while waiting for target halted</span></span>
<span class="line"><span>TARGET: stm32f1x.cpu - Not halted</span></span>
<span class="line"><span></span></span>
<span class="line"><span>in procedure &#39;reset&#39;</span></span>
<span class="line"><span>target state: halted</span></span>
<span class="line"><span>target halted due to debug-request, current mode: Thread</span></span>
<span class="line"><span>xPSR: 0x01000000 pc: 0x080003d0 msp: 0x20001278</span></span></code></pre></div><p>Then release the RESET boot and it will reset correctly.</p><p>This work-around was tested on viewtool-stm32f107 board and bypassed the above error reported by OpenOCD. The SWD programmer was a STLink-V2 and this was the command to connect:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>openocd -f interface/stlink-v2.cfg -f target/stm32f1x_stlink.cfg</span></span></code></pre></div><p>The OpenOCD version used was: Open On-Chip Debugger 0.8.0-dev-00307-g215c41c (git commit 215c41c)</p>`,22)]))}const u=a(i,[["render",o]]);export{g as __pageData,u as default};
