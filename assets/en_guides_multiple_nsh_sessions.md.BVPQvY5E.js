import{_ as s,c as n,al as t,o as a}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Multiple NSH Sessions","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/multiple_nsh_sessions.md","filePath":"en/guides/multiple_nsh_sessions.md"}'),i={name:"en/guides/multiple_nsh_sessions.md"};function o(l,e,p,d,r,c){return a(),n("div",null,e[0]||(e[0]=[t(`<h1 id="multiple-nsh-sessions" tabindex="-1">Multiple NSH Sessions <a class="header-anchor" href="#multiple-nsh-sessions" aria-label="Permalink to &quot;Multiple NSH Sessions&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Multiple+NSH+Sessions" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Multiple+NSH+Sessions</a></p><p>Q:</p><p>: I would like to run the NuttShell on multiple serial ports, but haven&#39;t figured it out yet; can you point me in the right direction?</p><p>A:</p><p>: Easy. Don&#39;t use <code>apps/examples/nsh_main.c</code>. Create your own main function something like this (with all error handling omitted for simplicity). By the way, this is all standard POSIX stuff that you can get detailed information about by just Googling [dup2]{.title-ref} or maybe \`I/O redirection\`:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int my_main(int argc, char **argv)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  const char *tty = argv[1];</span></span>
<span class="line"><span>  int fd = open(tty, O_RDWR);</span></span>
<span class="line"><span>  (void)dup2(fd, 0);</span></span>
<span class="line"><span>  (void)dup2(fd, 1);</span></span>
<span class="line"><span>  (void)dup2(fd, 2);</span></span>
<span class="line"><span>  close(fd);</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>And the rest is just like the original <code>nsh_main()</code> function (in fact, perhaps the existing <code>nsh_main()</code> function could be optionally extended to accept a console device string?). Then you can start a new NSH session on any TTY like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nsh&gt; mynsh /dev/ttyS2 &amp;</span></span></code></pre></div><p>This should cause a new NSH session to appear on <code>ttyS2</code>. That session will persist until you do the following from the new session:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nsh&gt; exit</span></span></code></pre></div><p>Then the new session, i.e., <code>my_main()</code> will exit.</p><p>If you were to do something like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nsh&gt; mynsh /dev/console</span></span></code></pre></div><p>then you would get nested NSH sessions on the same console. The first session would halt and wait for the second session to take control of the console until it exits. Then the first session will take over console again.</p><h2 id="nutty" tabindex="-1">NuTTY <a class="header-anchor" href="#nutty" aria-label="Permalink to &quot;NuTTY&quot;">​</a></h2><p>In a previous discussion, there was talk about implementing the moral equivalent of getty in NuttX (of course, it would be called &quot;nutty&quot;). A simple implementation of nutty would work like this:</p><ol><li>It would wait on <code>poll()</code> on every (configured) serial device.</li><li>Whenever it is awakened, it would start something like <code>my_main()</code> above on the active serial port.</li><li>NSH has an option to enable logins, but it would be better to remove the existing login information from NSH and centralize it in nutty.</li></ol><p>That way, you could connect to any TTY, hit enter, and you would get an NSH session. Hmm... it is not clear how nutty would get the TTY back after the session is closed. That part may require some additional thought.</p><h2 id="other-ideas" tabindex="-1">Other Ideas <a class="header-anchor" href="#other-ideas" aria-label="Permalink to &quot;Other Ideas&quot;">​</a></h2><p>There are other ways to get multiple NSH sessions:</p><ul><li>Telnet already supports multiple sessions.</li><li>Implement the existing NSH as an ELF program, then you can get multiple NSH sessions with <code>posix_spawn</code> by simply redirecting I/O.</li><li>Using the tiny NxWM window managers, multiple NSH windows are already supported.</li></ul>`,23)]))}const m=s(i,[["render",o]]);export{u as __pageData,m as default};
