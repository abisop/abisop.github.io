import{_ as t,c as r,al as i,o as n}from"./chunks/framework.NFAqBSgQ.js";const d=JSON.parse('{"title":"High Performance: Zero Latency Interrupts, Maskable Nested Interrupts","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/zerolatencyinterrupts.md","filePath":"en/guides/zerolatencyinterrupts.md"}'),a={name:"en/guides/zerolatencyinterrupts.md"};function s(o,e,p,h,l,c){return n(),r("div",null,e[0]||(e[0]=[i(`<h1 id="high-performance-zero-latency-interrupts-maskable-nested-interrupts" tabindex="-1">High Performance: Zero Latency Interrupts, Maskable Nested Interrupts <a class="header-anchor" href="#high-performance-zero-latency-interrupts-maskable-nested-interrupts" aria-label="Permalink to &quot;High Performance: Zero Latency Interrupts, Maskable Nested Interrupts&quot;">​</a></h1><h2 id="generic-interrupt-handling" tabindex="-1">Generic Interrupt Handling <a class="header-anchor" href="#generic-interrupt-handling" aria-label="Permalink to &quot;Generic Interrupt Handling&quot;">​</a></h2><p>NuttX includes a generic interrupt handling subsystem that makes it convenient to deal with interrupts using only IRQ numbers. In order to integrate with this generic interrupt handling system, the platform specific code is expected to collect all thread state into a container, <code>struct xcptcontext</code>. This container represents the full state of the thread and can be saved, restored, and exchanged as a <em>unit of thread</em>.</p><p>While this state saving has many useful benefits, it does require processing time. It was reported to me that this state saving required about two microseconds on an STM32F4Discovery board. That added interrupt latency might be an issue in some circumstances.</p><p>In addition, critical sections that are required in various places throughout the RTOS can pause interrupt handling momentarily. This increases the latency for those interrupts which become pending during a critical section. As this is likely to occur for some instances of an interrupt and not others, the interrupt latency varies from time to time (experiences <em>jitter</em>). Like the added latency discussed above, that jitter might be an issue in some circumstances.</p><p><strong>Terminology:</strong> The concepts discussed in this guide are not unique to NuttX. Other RTOSes have similar concepts but will use different terminology. The <a href="https://www.embedded.com/design/operating-systems/4461604/Interrupts-in-the-Nucleus-SE-RTOS" target="_blank" rel="noreferrer">Nucleus</a> RTOS, for example, uses the terms <em>Native</em> and <em>Managed</em> interrupts.</p><h2 id="bypassing-the-generic-interrupt-handling" tabindex="-1">Bypassing the Generic Interrupt Handling <a class="header-anchor" href="#bypassing-the-generic-interrupt-handling" aria-label="Permalink to &quot;Bypassing the Generic Interrupt Handling&quot;">​</a></h2><p>Most modern MCUs (such as the ARM Cortex-M family) receive and dispatch interrupts through a <em>vector table</em>. The vector table is a table in memory. Each entry in the table holds the address of an interrupt handler corresponding to different interrupts. When the interrupt occurs, the hardware fetches the corresponding interrupt handler address and gives control to the interrupt handler.</p><p>In the implementation of the generic interrupt handler, these vectored interrupts are not used as intended by the hardware designer. Rather, they are used to obtain an IRQ number and then to transfer control to the common, generic interrupt handling logic.</p><p>One way to achieve higher performance interrupts and still retain the benefits of the generic interrupt handling logic is to simply replace an interrupt handler address in the vector table with a different interrupt handler; one that does not vector to the generic interrupt handling logic logic, but rather to your custom code.</p><p>Often, the vector table is in ROM. So you can hard-code a special interrupt vector by modifying the ROM vector table so that the specific entry points to your custom interrupt handler. Or, if the architecture permits, you can use a vector table in RAM. Then you can freely attach and detach custom vector handlers by writing directly to the vector table. The ARM Cortex-M port provides interfaces to support this mode when the <code>CONFIG_ARCH_RAMVECTORS</code> option is enabled.</p><p>So what is the downside? There are two:</p><ul><li>Your custom interrupt handler will not have collected its state into the <code>struct xcptcontext</code> container. Therefore, it cannot communicate with operating system. Your custom interrupt handler has been taken &quot;out of the game&quot; and can no longer work with the system.</li><li>If your custom interrupt is truly going to be <em>high performance</em> then you will also have to support nested interrupts! The custom interrupt must have a high priority and must be able interrupt the generic interrupt handling logic. Otherwise, it will be occasionally delayed when there is a collision between your custom interrupt and other, lower priority interrupts.</li></ul><h2 id="getting-back-into-the-game" tabindex="-1">Getting Back into the Game <a class="header-anchor" href="#getting-back-into-the-game" aria-label="Permalink to &quot;Getting Back into the Game&quot;">​</a></h2><p>As mentioned, the custom interrupt handler cannot use most of the services of the OS since it has not created a <code>struct xcptcontext</code> container. So it needs a mechanism to &quot;get back into the game&quot; when it needs to interact with the operating system to, for example, post a semaphore, signal a thread, or send a message.</p><p>The ARM Cortex-M family supports a special way to do this using the <em>PendSV</em> interrupt:</p><ul><li>The custom logic would connect with the <em>PendSV</em> interrupt using the standard <code>irq_attach()</code> interface.</li><li>In the custom interrupt handler, it would schedule the <em>PendSV</em> interrupt when it needs to communicate with the OS.</li><li>The <em>PendSV</em> interrupt is dispatched through the generic interrupt system so when the attached <em>PendSV</em> interrupt is handled, it will be in a context where it can perform any necessary OS interactions.</li></ul><p>With the ARMv7_M architecture, the <em>PendSV</em> interrupt can be generated with:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>up_trigger_irq(NVIC_IRQ_PENDSV);</span></span></code></pre></div><p>On other architectures, it may be possible to do something like a software interrupt from the custom interrupt handler to accomplish the same thing.</p><p>The custom logic would be needed to communicate the events of interest between the high priority interrupt handler and <em>PendSV</em> interrupt handler. A detailed discussion of that custom logic is beyond the scope of this Wiki page.</p><p>The following table shows the priority levels of the Cortex-M family:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>IRQ type               Priority</span></span>
<span class="line"><span>Dataabort              0x00</span></span>
<span class="line"><span>High prio IRQ1         0x20   (Zero-latency interrupt)</span></span>
<span class="line"><span>High prio IRQ2         0x30   (Can&#39;t call OS API in ISR)</span></span>
<span class="line"><span>SVC                    0x70</span></span>
<span class="line"><span>Disable IRQ            0x80</span></span>
<span class="line"><span>(critical-section)</span></span>
<span class="line"><span>Low  prio IRQ          0xB0</span></span>
<span class="line"><span>PendSV                 0xE0</span></span></code></pre></div><p>Lower priority <em>numbers</em> mean a higher priority on this architecture.</p><p>As you can see, the zero-latency interrupts have higher priority than the critical section and SVC, but with the tradeoff that High prio IRQ can&#39;t call OS APIs in ISR.</p><h2 id="maskable-nested-interrupts" tabindex="-1">Maskable Nested Interrupts <a class="header-anchor" href="#maskable-nested-interrupts" aria-label="Permalink to &quot;Maskable Nested Interrupts&quot;">​</a></h2><p>The ARM Cortex-M family supports a feature called <em>BASEPRI</em> that can be used to disable interrupts at a priority level below a certain level. This feature can be used to support maskable nested interrupts.</p><p>Maskable nested interrupts differ from zero-latency interrupts in that they obey the interrupt masking mechanisms of the system. For example, setting the BASEPRI register to a specific threshold will block all interrupts of a lower or equal priority. However, high-priority interrupts (such as Non-Maskable Interrupts or zero-latency interrupts) are unaffected by these masks.</p><p>This is useful when you have a high-priority interrupt that needs to be able to interrupt the system, but you also have lower-priority interrupts that you want to be able to mask.</p><p>The following table shows the priority levels of the Cortex-M family:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>IRQ type                Priority</span></span>
<span class="line"><span>Dataabort               0x00</span></span>
<span class="line"><span>SVC                     0x70</span></span>
<span class="line"><span>Disable IRQ             0x80</span></span>
<span class="line"><span>(critical-section)</span></span>
<span class="line"><span>High prio IRQ1          0x90    (Maskable nested interrupt)</span></span>
<span class="line"><span>High prio IRQ2          0xA0    (Can call OS API in ISR)</span></span>
<span class="line"><span>Low  prio IRQ           0xB0</span></span>
<span class="line"><span>PendSV                  0xE0</span></span></code></pre></div><p>Lower priority <em>numbers</em> mean a higher priority on this architecture.</p><p>As you can see, the priority levels of the maskable nested interrupts are between the critical section and the low-priority interrupts. In this case, High prio IRQ can call OS APIs in ISR.</p><h2 id="nested-interrupt-handling" tabindex="-1">Nested Interrupt Handling <a class="header-anchor" href="#nested-interrupt-handling" aria-label="Permalink to &quot;Nested Interrupt Handling&quot;">​</a></h2><p>Some general notes about nested interrupt handling are provided in [[ne](\`ne.md)stedinterrupts]{.title-ref}. In this case, handling the nested custom interrupt is simpler because the generic interrupt handler is not re-entered. Rather, the generic interrupt handler must simply be made to co-exist with the custom interrupt interrupt handler.</p><p>Modifications may be required to the generic interrupt handling logic to accomplish. A few points need to be made here:</p><ul><li>The MCU should support interrupt prioritization so that the custom interrupt can be scheduled with a higher priority.</li><li>The generic interrupt handlers currently disable interrupts during interrupts. Instead, they must be able to keep the custom interrupt enabled throughout interrupt process but still prevent re-entrancy by other standard interrupts (This can be done by setting an interrupt base priority level in the Cortex-M family).</li><li>The custom interrupt handler can now interrupt the generic interrupt handler at any place. Is the logic safe in all cases to be interrupted? Sometimes interrupt handlers place the MCU in momentarily perverse states while registers are being manipulated. Make sure that it is safe to take interrupts at any time (or else keep the interrupts disabled in the critical times).</li><li>Will the custom interrupt handler have all of the resources it needs in place when it occurs? Will it have a valid stack pointer? (In the Cortex-M implementation, for example, the MSP may not be valid when the custom interrupt handler is entered).</li></ul><p>Some of these issues are complex and so you should expect some complexity in getting the nested interrupt handler to work.</p><h2 id="cortex-m3-4-implementation" tabindex="-1">Cortex-M3/4 Implementation <a class="header-anchor" href="#cortex-m3-4-implementation" aria-label="Permalink to &quot;Cortex-M3/4 Implementation&quot;">​</a></h2><p>Such high priority, nested interrupt handler has been implemented for the Cortex-M3/4 families.</p><p>The following paragraphs will summarize that implementation.</p><h3 id="configuration-options" tabindex="-1">Configuration Options <a class="header-anchor" href="#configuration-options" aria-label="Permalink to &quot;Configuration Options&quot;">​</a></h3><p><code>CONFIG_ARCH_HIPRI_INTERRUPT</code></p><p>The OS disables interrupts by setting the <em>BASEPRI</em> register to <code>NVIC_SYSH_DISABLE_PRIORITY</code> so that most interrupts will not have execution priority. <em>SVCall</em> must have execution priority in all cases.</p><p>In the normal cases, interrupts are not nest-able and all interrupts run at an execution priority between <code>NVIC_SYSH_PRIORITY_MIN</code> and <code>NVIC_SYSH_PRIORITY_MAX</code> (with <code>NVIC_SYSH_PRIORITY_MAX</code> reserved for <em>SVCall</em>).</p><p>If, in addition, <code>CONFIG_ARCH_HIPRI_INTERRUPT</code> is defined, then special high priority interrupts are supported. These are not &quot;nested&quot; in the normal sense of the word. These high priority interrupts can interrupt normal processing but execute outside of OS (although they can &quot;get back into the game&quot; via a <em>PendSV</em> interrupt).</p><h3 id="disabling-the-high-priority-interrupt" tabindex="-1">Disabling the High Priority Interrupt <a class="header-anchor" href="#disabling-the-high-priority-interrupt" aria-label="Permalink to &quot;Disabling the High Priority Interrupt&quot;">​</a></h3><p>In the normal course of things, interrupts must occasionally be disabled using the <code>up_irq_save()</code> inline function to prevent contention in use of resources that may be shared between interrupt level and non-interrupt level logic. Now the question arises, if we are using the <em>BASEPRI</em> to disable interrupts and have high priority interrupts enabled (<code>CONFIG_ARCH_HIPRI_INTERRUPT=y</code>), do we disable all interrupts except <em>SVCall</em> (we cannot disable <em>SVCall</em> interrupts)? Or do we only disable the &quot;normal&quot; interrupts?</p><p>If we are using the <em>BASEPRI</em> register to disable interrupts, then the answer is that we must disable <em>ONLY</em> the normal interrupts. That is because we cannot disable <em>SVCall</em> interrupts and we cannot permit <em>SVCall</em> interrupts running at a higher priority than the high priority interrupts. Otherwise, they will introduce jitter in the high priority interrupt response time.</p><p>Hence, if you need to disable the high priority interrupt, you will have to disable the interrupt either at the peripheral that generates the interrupt or at the interrupt controller, the <em>NVIC</em>. Disabling global interrupts via the <em>BASEPRI</em> register must not be allowed to affect high priority interrupts.</p><h3 id="dependencies" tabindex="-1">Dependencies <a class="header-anchor" href="#dependencies" aria-label="Permalink to &quot;Dependencies&quot;">​</a></h3><ul><li><code>CONFIG_ARCH_HAVE_IRQPRIO</code>. Support for prioritized interrupt support must be enabled.</li><li>Floating Point Registers. If used with a Cortex-M4 that supports hardware floating point, you cannot use hardware floating point in the high priority interrupt handler UNLESS you use the common vector logic that supports saving of floating point registers on all interrupts.</li></ul><h3 id="configuring-high-priority-interrupts" tabindex="-1">Configuring High Priority Interrupts <a class="header-anchor" href="#configuring-high-priority-interrupts" aria-label="Permalink to &quot;Configuring High Priority Interrupts&quot;">​</a></h3><p>How do you specify a high priority interrupt? You need to do two things:</p><p>First, You need to change the address in the vector table so that the high priority interrupt vectors to your special C interrupt handler. There are two ways to do this:</p><ul><li>If you select <code>CONFIG_ARCH_RAMVECTORS</code>, then vectors will be kept in RAM and the system will support the interface: <code>int up_ramvec_attach(int irq, up_vector_t vector)</code>. That interface can be used to attach your C interrupt handler to the vector at run time.</li><li>Alternatively, you could keep your vectors in FLASH but in order to this, you would have to develop your own custom vector table.</li></ul><p>Second, you need to set the priority of your interrupt in <em>NVIC</em> to <code>NVIC_SYSH_HIGH_PRIORITY</code> using the standard interface: <code>int up_prioritize_irq(int irq, int priority);</code></p><h3 id="example-code" tabindex="-1">Example Code <a class="header-anchor" href="#example-code" aria-label="Permalink to &quot;Example Code&quot;">​</a></h3><p>You can find an example that tests the high priority, nested interrupts in the NuttX source:</p><ul><li>[[/platform](]{.title-ref}/platform.md)s/arm/stm32f1/boards/viewtool-stm32f107/index\` Description of the configuration</li><li><code>nuttx/boards/arm/stm32/viewtool-stm32f107/highpri</code> Test configuration</li><li><code>nuttx/boards/arm/stm32/viewtool-stm32f107/src/stm32_highpri</code> Test driver.</li></ul>`,60)]))}const m=t(a,[["render",s]]);export{d as __pageData,m as default};
