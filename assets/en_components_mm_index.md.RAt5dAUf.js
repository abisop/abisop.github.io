import{_ as a,c as n,al as o,o as l}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"Memory Management","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/mm/index.md","filePath":"en/components/mm/index.md"}'),t={name:"en/components/mm/index.md"};function s(i,e,r,c,d,m){return l(),n("div",null,e[0]||(e[0]=[o(`<h1 id="memory-management" tabindex="-1">Memory Management <a class="header-anchor" href="#memory-management" aria-label="Permalink to &quot;Memory Management&quot;">​</a></h1><p>This page discusses the NuttX memory management logic.</p><blockquote><p>shm.rst</p></blockquote><h2 id="standard-memory-management-functions" tabindex="-1">Standard Memory Management Functions <a class="header-anchor" href="#standard-memory-management-functions" aria-label="Permalink to &quot;Standard Memory Management Functions&quot;">​</a></h2><h3 id="standard-functions" tabindex="-1">Standard Functions <a class="header-anchor" href="#standard-functions" aria-label="Permalink to &quot;Standard Functions&quot;">​</a></h3><p>The standard memory management functions as prototyped in stdlib.h as specified in the Base definitions volume of IEEE Std 1003.1-2001. This include the files:</p><ul><li>Standard Interfaces: <code>mm_malloc.c</code>, <code>mm_calloc.c</code>, <code>mm_realloc.c</code>, <code>mm_memalign.c</code>, <code>mm_free.c</code></li><li>Less-Standard Interfaces: <code>mm_zalloc.c</code>, <code>mm_mallinfo.c</code></li><li>Internal Implementation: <code>mm_initialize.c</code> <code>mm_sem.c</code><code>mm_addfreechunk.c</code> <code>mm_size2ndx.c</code> <code>mm_shrinkchunk.c</code></li><li>Build and Configuration files: <code>Kconfig</code>, <code>Makefile</code></li></ul><h3 id="memory-models" tabindex="-1">Memory Models <a class="header-anchor" href="#memory-models" aria-label="Permalink to &quot;Memory Models&quot;">​</a></h3><ul><li><p>Small Memory Model. If the MCU supports only 16-bit data addressing then the small memory model is automatically used. The maximum size of the heap is then 64K. The small memory model can also be forced MCUs with wider addressing by defining CONFIG_SMALL_MEMORY in the NuttX configuration file.</p></li><li><p>Large Memory Model. Otherwise, the allocator uses a model that supports a heap of up to 4G.</p><p>This implementation uses a variable length allocator with the following properties:</p><blockquote><ul><li>Overhead: Either 8- or 4-bytes per allocation for large and small models, respectively.</li><li>Alignment: All allocations are aligned to 8- or 4-bytes for large and small models, respectively.</li></ul></blockquote></li></ul><h3 id="multiple-heaps" tabindex="-1">Multiple Heaps <a class="header-anchor" href="#multiple-heaps" aria-label="Permalink to &quot;Multiple Heaps&quot;">​</a></h3><p>This allocator can be used to manage multiple heaps (albeit with some non-standard interfaces). A heap is represented by <code>struct mm_heap_s</code> as defined in the file <code>include/nuttx/mm/mm.h</code>. To create another heap instance, you would allocate a heap structure, most likely statically in memory:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>include &lt;nuttx/mm/mm.h&gt;</span></span>
<span class="line"><span>static struct mm_heap_s *g_myheap;</span></span></code></pre></div><p>Then initialize the heap using:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>g_myheap = mm_initialize(myheap_start, myheap_size);</span></span></code></pre></div><p>Where <code>mm_initialize()</code> and all related interfaces are prototyped in the header file <code>include/nuttx/mm/mm.h</code>.</p><p>After the new heap instance has been initialized, it can then be used with these almost familiar interfaces: <code>mm_malloc()</code>, <code>mm_realloc()</code>, <code>mm_free()</code>, etc. These are &#39;almost familiar&#39; because they are analogous of the standard <code>malloc()</code>, <code>realloc()</code>, <code>free()</code>, etc. except that they expect a reference to the initialized heap structure as the first parameter.</p><p>In fact, the standard <code>malloc()</code>, <code>realloc()</code>, <code>free()</code> use this same mechanism, but with a global heap structure called <code>g_mmheap</code>.</p><h3 id="user-kernel-heaps" tabindex="-1">User/Kernel Heaps <a class="header-anchor" href="#user-kernel-heaps" aria-label="Permalink to &quot;User/Kernel Heaps&quot;">​</a></h3><p>This multiple heap capability is exploited in some of the more complex NuttX build configurations to provide separate kernel-mode and user-mode heaps.</p><h3 id="sub-directories" tabindex="-1">Sub-Directories <a class="header-anchor" href="#sub-directories" aria-label="Permalink to &quot;Sub-Directories&quot;">​</a></h3><ul><li><code>mm/mm_heap</code> - Holds the common base logic for all heap allocators</li><li><code>mm/umm_heap</code> - Holds the user-mode memory allocation interfaces</li><li><code>mm/kmm_heap</code> - Holds the kernel-mode memory allocation interfaces</li></ul><h3 id="debugging" tabindex="-1">Debugging <a class="header-anchor" href="#debugging" aria-label="Permalink to &quot;Debugging&quot;">​</a></h3><p>Please follow these steps to hook all memory related routines:</p><ol><li><p>Add a new header file(e.g. <code>xxx_malloc.h</code>):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>...</span></span>
<span class="line"><span>#include &lt;malloc.h&gt;</span></span>
<span class="line"><span>#include &lt;stdlib.h&gt;</span></span>
<span class="line"><span>#include &lt;string.h&gt;</span></span>
<span class="line"><span>#include &lt;strings.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifndef __ASSEMBLY__</span></span>
<span class="line"><span>FAR void *xxx_malloc(FAR const char *file, int line, size_t size);</span></span>
<span class="line"><span>void xxx_free(FAR const char *file, int line, FAR const void *ptr);</span></span>
<span class="line"><span>FAR void *xxx_memcpy(FAR const char *file, int line,</span></span>
<span class="line"><span>                      FAR void *dst, FAR const void *src, size_t len);</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>#define malloc(s) xxx_malloc(__FILE__, __LINE__, s)</span></span>
<span class="line"><span>#define free(p) xxx_free(__FILE__, __LINE__, p)</span></span>
<span class="line"><span>#define memcpy(d, s, l) xxx_memcpy(__FILE__, __LINE__, d, s, l)</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>...</span></span></code></pre></div></li><li><p>Implement <code>xxx_malloc</code>, <code>xxx_free</code>, <code>xxx_memcpy</code>... in source code, you can:</p><ul><li>Modify some arguments(e.g. extend the allocation size for redzone)</li><li>Check the critical arguments(e.g. pointer and length) in the range</li><li>Forward to the original implementation(call malloc/free/memcpy)</li><li>Attach the context info(e.g. file and line) before return</li></ul></li><li><p>Enable the hook by either:</p><ul><li>Include <code>xxx_malloc.h</code> in your source code to hook one file</li><li>Add <code>-include xxx_malloc.h</code> to <code>CFLAGS</code> to hook all source code</li></ul></li></ol><h2 id="granule-allocator" tabindex="-1">Granule Allocator <a class="header-anchor" href="#granule-allocator" aria-label="Permalink to &quot;Granule Allocator&quot;">​</a></h2><p>A non-standard granule allocator is also available in this directory The granule allocator allocates memory in units of a fixed sized block (&quot;granule&quot;). Allocations may be aligned to a user-provided address boundary.</p><p>The granule allocator interfaces are defined in <code>nuttx/include/nuttx/mm/gran.h</code>. The granule allocator consists of these files in this directory: <code>mm_gran.h</code>, <code>mm_granalloc.c</code>, <code>mm_grancritical.c</code>, <code>mm_granfree.c</code> <code>mm_graninit.c</code></p><p>The granule allocator is not used anywhere within the base NuttX code as of this writing. The intent of the granule allocator is to provide a tool to support platform-specific management of aligned DMA memory.</p><p>NOTE: Because each granule may be aligned and each allocation is in units of the granule size, selection of the granule size is important: Larger granules will give better performance and less overhead but more losses of memory due to quantization waste. Additional memory waste can occur from alignment; Of course, heap alignment should no be used unless (a) you are using the granule allocator to manage DMA memory and (b) your hardware has specific memory alignment requirements.</p><p>The current implementation also restricts the maximum allocation size to 32 granules. That restriction could be eliminated with some additional coding effort, but currently requires larger granule sizes for larger allocations.</p><h3 id="general-usage-example" tabindex="-1">General Usage Example <a class="header-anchor" href="#general-usage-example" aria-label="Permalink to &quot;General Usage Example&quot;">​</a></h3><p>This is an example using the GCC section attribute to position a DMA heap in memory (logic in the linker script would assign the section .dmaheap to the DMA memory:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>FAR uint32_t g_dmaheap[DMAHEAP_SIZE] locate_data(.dmaheap);</span></span></code></pre></div><p>The heap is created by calling gran_initialize. Here the granule size is set to 64 bytes and the alignment to 16 bytes:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GRAN_HANDLE handle = gran_initialize(g_dmaheap, DMAHEAP_SIZE, 6, 4);</span></span></code></pre></div><p>Then the <code>GRAN_HANDLE</code> can be used to allocate memory:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>FAR uint8_t *dma_memory = (FAR uint8_t *)gran_alloc(handle, 47);</span></span></code></pre></div><p>The actual memory allocates will be 64 byte (wasting 17 bytes) and will be aligned at least to (<code>1 &lt;&lt; log2align</code>).</p><p>Sub-Directories:</p><ul><li><code>mm/mm_gran</code> - Holds the granule allocation logic</li></ul><h2 id="page-allocator" tabindex="-1">Page Allocator <a class="header-anchor" href="#page-allocator" aria-label="Permalink to &quot;Page Allocator&quot;">​</a></h2><p>The page allocator is an application of the granule allocator. It is a special purpose memory allocator intended to allocate physical memory pages for use with systems that have a memory management unit (MMU).</p><p>Sub-Directories:</p><ul><li><code>mm/mm_gran</code> - The page allocator cohabits the same directory as the granule allocator.</li></ul><h2 id="shared-memory-management" tabindex="-1">Shared Memory Management <a class="header-anchor" href="#shared-memory-management" aria-label="Permalink to &quot;Shared Memory Management&quot;">​</a></h2><p>When NuttX is build in kernel mode with a separate, privileged, kernel-mode address space and multiple, unprivileged, user-mode address spaces, then shared memory regions must also be managed. Shared memory regions are user-accessible memory regions that can be attached into the user process address space for sharing between user process.</p><p>Sub-Directories:</p><ul><li><code>mm/shm</code> - The shared memory logic</li></ul><p>The shared memory management logic has its own page that can be found at [[](]{.title-ref}.md)shm\`.</p><h2 id="i-o-buffers" tabindex="-1">I/O Buffers <a class="header-anchor" href="#i-o-buffers" aria-label="Permalink to &quot;I/O Buffers&quot;">​</a></h2><p>The iob subdirectory contains a simple allocator of I/O buffers. These I/O buffers, IOBs, are used extensively for networking but are generally available for usage by drivers. The I/O buffers have these properties:</p><ol><li>Uses a pool of a fixed number of fixed fixed size buffers.</li><li>Free buffers are retained in free list: When a buffer is allocated it is removed from the free list; when a buffer is freed it is returned to the free list.</li><li>The calling application will wait if there are not free buffers.</li></ol>`,52)]))}const u=a(t,[["render",s]]);export{h as __pageData,u as default};
