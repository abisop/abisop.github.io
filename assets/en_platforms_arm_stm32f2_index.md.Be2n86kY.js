import{_ as a,c as l,al as i,j as t,o as s}from"./chunks/framework.NFAqBSgQ.js";const T=JSON.parse('{"title":"ST STM32F2","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/stm32f2/index.md","filePath":"en/platforms/arm/stm32f2/index.md"}'),r={name:"en/platforms/arm/stm32f2/index.md"};function o(n,e,d,_,S,h){return s(),l("div",null,e[0]||(e[0]=[i(`<h1 id="st-stm32f2" tabindex="-1">ST STM32F2 <a class="header-anchor" href="#st-stm32f2" aria-label="Permalink to &quot;ST STM32F2&quot;">​</a></h1><h2 id="supported-mcus" tabindex="-1">Supported MCUs <a class="header-anchor" href="#supported-mcus" aria-label="Permalink to &quot;Supported MCUs&quot;">​</a></h2><p>TODO</p><h2 id="peripheral-support" tabindex="-1">Peripheral Support <a class="header-anchor" href="#peripheral-support" aria-label="Permalink to &quot;Peripheral Support&quot;">​</a></h2><p>The following list indicates peripherals supported in NuttX:</p><p>Peripheral Support Notes</p><hr><p>FLASH CRC PM RCC GPIO SYSCFG EXTI DMA ADC DAC DCMI TIM IWDG WWDG CRYP RNG HASH RTC I2C USART SPI SDIO CAN ETH OTG_FS OTG_HS FSMC Yes Yes ? Yes Yes Yes Yes Yes Yes Yes No Yes Yes Yes Yes Yes ? Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes</p><h3 id="memory" tabindex="-1">Memory <a class="header-anchor" href="#memory" aria-label="Permalink to &quot;Memory&quot;">​</a></h3><ul><li>CONFIG_RAM_SIZE - Describes the installed DRAM (SRAM in this case)</li><li>CONFIG_RAM_START - The start address of installed DRAM</li></ul><p>In addition to internal SRAM, SRAM may also be available through the FSMC. In order to use FSMC SRAM, the following additional things need to be present in the NuttX configuration file:</p><ul><li>CONFIG_STM32_EXTERNAL_RAM - Indicates that SRAM is available via the FSMC (as opposed to an LCD or FLASH).</li><li>CONFIG_HEAP2_BASE - The base address of the SRAM in the FSMC address space (hex)</li><li>CONFIG_HEAP2_SIZE - The size of the SRAM in the FSMC address space (decimal)</li><li>CONFIG_ARCH_LEDS - Use LEDs to show state. Unique to boards that have LEDs</li><li>CONFIG_ARCH_INTERRUPTSTACK - This architecture supports an interrupt stack. If defined, this symbol is the size of the interrupt stack in bytes. If not defined, the user task stacks will be used during interrupt handling.</li><li>CONFIG_ARCH_STACKDUMP - Do stack dumps after assertions</li><li>CONFIG_ARCH_LEDS - Use LEDs to show state. Unique to board architecture.</li></ul><h3 id="clock" tabindex="-1">Clock <a class="header-anchor" href="#clock" aria-label="Permalink to &quot;Clock&quot;">​</a></h3><ul><li><p>CONFIG_ARCH_BOARD_STM32_CUSTOM_CLOCKCONFIG - Enables special STM32 clock configuration features.:</p><pre><code>CONFIG_ARCH_BOARD_STM32_CUSTOM_CLOCKCONFIG=n
</code></pre></li><li><p>CONFIG_ARCH_LOOPSPERMSEC - Must be calibrated for correct operation of delay loops</p></li></ul><h3 id="can" tabindex="-1">CAN <a class="header-anchor" href="#can" aria-label="Permalink to &quot;CAN&quot;">​</a></h3><ul><li>CONFIG_CAN - Enables CAN support (one or both of CONFIG_STM32_CAN1 or CONFIG_STM32_CAN2 must also be defined)</li><li>CONFIG_CAN_EXTID - Enables support for the 29-bit extended ID. Default Standard 11-bit IDs.</li><li>CONFIG_CAN_TXFIFOSIZE - The size of the circular tx buffer of CAN messages. Default: 8</li><li>CONFIG_CAN_RXFIFOSIZE - The size of the circular rx buffer of CAN messages. Default: 8</li><li>CONFIG_CAN_NPENDINGRTR - The size of the list of pending RTR requests. Default: 4</li><li>CONFIG_STM32_CAN1 - Enable support for CAN1</li><li>CONFIG_STM32_CAN2 - Enable support for CAN2</li><li>CONFIG_STM32_CAN1_BAUD - CAN1 BAUD rate. Required if CONFIG_STM32_CAN1 is defined.</li><li>CONFIG_STM32_CAN2_BAUD - CAN1 BAUD rate. Required if CONFIG_STM32_CAN2 is defined.</li><li>CONFIG_STM32_CAN_TSEG1 - The number of CAN time quanta in segment <ol><li>Default: 6</li></ol></li><li>CONFIG_STM32_CAN_TSEG2 - the number of CAN time quanta in segment 2. Default: 7</li><li>CONFIG_STM32_CAN_REGDEBUG - If CONFIG_DEBUG_FEATURES is set, this will generate an dump of all CAN registers.</li></ul><h3 id="fsmc-sram" tabindex="-1">FSMC SRAM <a class="header-anchor" href="#fsmc-sram" aria-label="Permalink to &quot;FSMC SRAM&quot;">​</a></h3><p>Internal SRAM is available in all members of the STM32 family. In addition to internal SRAM, SRAM may also be available through the FSMC. In order to use FSMC SRAM, the following additional things need to be present in the NuttX configuration file:</p><ul><li>CONFIG_STM32_FSMC=y - Enables the FSMC</li><li>CONFIG_STM32_EXTERNAL_RAM=y - Indicates that SRAM is available via the FSMC (as opposed to an LCD or FLASH).</li><li>CONFIG_HEAP2_BASE - The base address of the SRAM in the FSMC address space</li><li>CONFIG_HEAP2_SIZE - The size of the SRAM in the FSMC address space</li><li>CONFIG_MM_REGIONS - Must be set to a large enough value to include the FSMC SRAM</li></ul><h3 id="timers" tabindex="-1">Timers <a class="header-anchor" href="#timers" aria-label="Permalink to &quot;Timers&quot;">​</a></h3><p>Timer devices may be used for different purposes. One special purpose is to generate modulated outputs for such things as motor control. If CONFIG_STM32_TIMn is defined (as above) then the following may also be defined to indicate that the timer is intended to be used for pulsed output modulation, ADC conversion, or DAC conversion. Note that ADC/DAC require two definition: Not only do you have to assign the timer (n) for used by the ADC or DAC, but then you also have to configure which ADC or DAC (m) it is assigned to.:</p><ul><li>CONFIG_STM32_TIMn_PWM Reserve timer n for use by PWM, n=1,..,14</li><li>CONFIG_STM32_TIMn_ADC Reserve timer n for use by ADC, n=1,..,14</li><li>CONFIG_STM32_TIMn_ADCm Reserve timer n to trigger ADCm, n=1,..,14, m=1,..,3</li><li>CONFIG_STM32_TIMn_DAC Reserve timer n for use by DAC, n=1,..,14</li><li>CONFIG_STM32_TIMn_DACm Reserve timer n to trigger DACm, n=1,..,14, m=1,..,2</li></ul><p>For each timer that is enabled for PWM usage, we need the following additional configuration settings:</p>`,23),t("ul",{"1,..,4":""},[t("li",null,"CONFIG_STM32_TIMx_CHANNEL - Specifies the timer output channel")],-1),i('<p>NOTE: The STM32 timers are each capable of generating different signals on each of the four channels with different duty cycles. That capability is not supported by this driver: Only one output channel per timer.</p><h3 id="jtag" tabindex="-1">JTAG <a class="header-anchor" href="#jtag" aria-label="Permalink to &quot;JTAG&quot;">​</a></h3><p>JTAG Enable settings (by default JTAG-DP and SW-DP are disabled):</p><ul><li>CONFIG_STM32_JTAG_FULL_ENABLE - Enables full SWJ (JTAG-DP + SW-DP)</li><li>CONFIG_STM32_JTAG_NOJNTRST_ENABLE - Enables full SWJ (JTAG-DP + SW-DP) but without JNTRST.</li><li>CONFIG_STM32_JTAG_SW_ENABLE - Set JTAG-DP disabled and SW-DP enabled</li></ul><h3 id="usart" tabindex="-1">USART <a class="header-anchor" href="#usart" aria-label="Permalink to &quot;USART&quot;">​</a></h3><p>Options:</p><ul><li>CONFIG_U[S]ARTn_SERIAL_CONSOLE - selects the USARTn (n=1,2,3) or UARTm (m=4,5) for the console and ttys0 (default is the USART1).</li><li>CONFIG_U[S]ARTn_RXBUFSIZE - Characters are buffered as received. This specific the size of the receive buffer</li><li>CONFIG_U[S]ARTn_TXBUFSIZE - Characters are buffered before being sent. This specific the size of the transmit buffer</li><li>CONFIG_U[S]ARTn_BAUD - The configure BAUD of the UART. Must be</li><li>CONFIG_U[S]ARTn_BITS - The number of bits. Must be either 7 or 8.</li><li>CONFIG_U[S]ARTn_PARTIY - 0=no parity, 1=odd parity, 2=even parity</li><li>CONFIG_U[S]ARTn_2STOP - Two stop bits</li></ul><h3 id="spi" tabindex="-1">SPI <a class="header-anchor" href="#spi" aria-label="Permalink to &quot;SPI&quot;">​</a></h3><ul><li>CONFIG_STM32_SPI_INTERRUPTS - Select to enable interrupt driven SPI support. Non-interrupt-driven, poll-waiting is recommended if the interrupt rate would be to high in the interrupt driven case.</li><li>CONFIG_STM32_SPIx_DMA - Use DMA to improve SPIx transfer performance. Cannot be used with CONFIG_STM32_SPI_INTERRUPT.</li></ul><h3 id="sdio" tabindex="-1">SDIO <a class="header-anchor" href="#sdio" aria-label="Permalink to &quot;SDIO&quot;">​</a></h3><p>Options:</p><ul><li>CONFIG_SDIO_DMA - Support DMA data transfers. Requires CONFIG_STM32_SDIO and CONFIG_STM32_DMA2.</li><li>CONFIG_STM32_SDIO_PRI - Select SDIO interrupt priority. Default: 128</li><li>CONFIG_STM32_SDIO_DMAPRIO - Select SDIO DMA interrupt priority. Default: Medium</li><li>CONFIG_STM32_SDIO_WIDTH_D1_ONLY - Select 1-bit transfer mode. Default: 4-bit transfer mode.</li></ul><h3 id="eth" tabindex="-1">ETH <a class="header-anchor" href="#eth" aria-label="Permalink to &quot;ETH&quot;">​</a></h3><p>Options:</p><ul><li>CONFIG_STM32_PHYADDR - The 5-bit address of the PHY on the board</li><li>CONFIG_STM32_MII - Support Ethernet MII interface</li><li>CONFIG_STM32_MII_MCO1 - Use MCO1 to clock the MII interface</li><li>CONFIG_STM32_MII_MCO2 - Use MCO2 to clock the MII interface</li><li>CONFIG_STM32_RMII - Support Ethernet RMII interface</li><li>CONFIG_STM32_AUTONEG - Use PHY autonegotiation to determine speed and mode</li><li>CONFIG_STM32_ETHFD - If CONFIG_STM32_AUTONEG is not defined, then this may be defined to select full duplex mode. Default: half-duplex</li><li>CONFIG_STM32_ETH100MBPS - If CONFIG_STM32_AUTONEG is not defined, then this may be defined to select 100 MBps speed. Default: 10 Mbps</li><li>CONFIG_STM32_PHYSR - This must be provided if CONFIG_STM32_AUTONEG is defined. The PHY status register address may diff from PHY to PHY. This configuration sets the address of the PHY status register.</li><li>CONFIG_STM32_PHYSR_SPEED - This must be provided if CONFIG_STM32_AUTONEG is defined. This provides bit mask indicating 10 or 100MBps speed.</li><li>CONFIG_STM32_PHYSR_100MBPS - This must be provided if CONFIG_STM32_AUTONEG is defined. This provides the value of the speed bit(s) indicating 100MBps speed.</li><li>CONFIG_STM32_PHYSR_MODE - This must be provided if CONFIG_STM32_AUTONEG is defined. This provide bit mask indicating full or half duplex modes.</li><li>CONFIG_STM32_PHYSR_FULLDUPLEX - This must be provided if CONFIG_STM32_AUTONEG is defined. This provides the value of the mode bits indicating full duplex mode.</li><li>CONFIG_STM32_ETH_PTP - Precision Time Protocol (PTP). Not supported but some hooks are indicated with this condition.</li></ul><h3 id="usb-otg-fs" tabindex="-1">USB OTG FS <a class="header-anchor" href="#usb-otg-fs" aria-label="Permalink to &quot;USB OTG FS&quot;">​</a></h3><p>STM32 USB OTG FS Host Driver Support</p><p>Pre-requisites:</p><ul><li>CONFIG_USBHOST - Enable general USB host support</li><li>CONFIG_STM32_OTGFS - Enable the STM32 USB OTG FS block</li><li>CONFIG_STM32_SYSCFG - Needed</li><li>CONFIG_STM32_OTGFS_RXFIFO_SIZE - Size of the RX FIFO in 32-bit words. Default 128 (512 bytes)</li><li>CONFIG_STM32_OTGFS_NPTXFIFO_SIZE - Size of the non-periodic Tx FIFO in 32-bit words. Default 96 (384 bytes)</li><li>CONFIG_STM32_OTGFS_PTXFIFO_SIZE - Size of the periodic Tx FIFO in 32-bit words. Default 96 (384 bytes)</li><li>CONFIG_STM32_OTGFS_DESCSIZE - Maximum size of a descriptor. Default: 128</li><li>CONFIG_STM32_OTGFS_SOFINTR - Enable SOF interrupts. Why would you ever want to do that?</li><li>CONFIG_STM32_USBHOST_REGDEBUG - Enable very low-level register access debug. Depends on CONFIG_DEBUG_FEATURES.</li><li>CONFIG_STM32_USBHOST_PKTDUMP - Dump all incoming and outgoing USB packets. Depends on CONFIG_DEBUG_FEATURES.</li></ul><h2 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h2><blockquote><p>boards/<em>/</em></p></blockquote>',21)]))}const C=a(r,[["render",o]]);export{T as __pageData,C as default};
