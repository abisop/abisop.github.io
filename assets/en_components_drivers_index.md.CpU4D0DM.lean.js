import{_ as t,c as n,al as i,j as e,a as l,o}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"Device Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/index.md","filePath":"en/components/drivers/index.md"}'),a={name:"en/components/drivers/index.md"};function s(c,r,d,u,p,m){return o(),n("div",null,r[0]||(r[0]=[i("",7),e("blockquote",null,[e("ul",null,[e("li",null,[l("An "),e("em",null,"upper half"),l(" which registers itself to NuttX using a call such as :c"),e("code",{class:"interpreted-text",role:"func"},"register_driver"),l(" or :c"),e("code",{class:"interpreted-text",role:"func"},"register_blockdriver"),l(" and implements the corresponding high-level interface ([read]{.title-ref}, [write]{.title-ref}, [close]{.title-ref}, etc.). implements the interface. This "),e("em",null,"upper half"),l(" calls into the "),e("em",null,"lower half"),l(" via callbacks.")]),e("li",null,'A "lower half" which is typically hardware-specific. This is usually implemented at the architecture or board level.')])],-1),e("p",null,"Details about drivers implementation can be found in [[../../implementation/driver](]{.title-ref}../../implementation/driver.md)s_design` and [[../../implementation/device_driver](]{.title-ref}../../implementation/device_driver.md)s`.",-1),e("h2",{id:"subdirectories-of-nuttx-drivers",tabindex:"-1"},[l("Subdirectories of "),e("code",null,"nuttx/drivers"),l(),e("a",{class:"header-anchor",href:"#subdirectories-of-nuttx-drivers","aria-label":'Permalink to "Subdirectories of `nuttx/drivers`"'},"â€‹")],-1),e("ul",null,[e("li",null,[e("p",null,[e("code",null,"1wire/"),l(" [[character/1wire]{.title-ref}]([character/1wire]{.title-ref}.md)")]),e("p",null,"1wire device drivers.")]),e("li",null,[e("p",null,[e("code",null,"analog/"),l(" [[character/analog/index]{.title-ref}]([character/analog/index]{.title-ref}.md)")]),e("p",null,"This directory holds implementations of analog device drivers. This includes drivers for Analog to Digital Conversion (ADC) as well as drivers for Digital to Analog Conversion (DAC).")]),e("li",null,[e("p",null,[e("code",null,"audio/"),l(" [[](]{.title-ref}.md)special/audio`")]),e("p",null,"Audio device drivers.")]),e("li",null,[e("p",null,[e("code",null,"bch/"),l(" [[character/bch]{.title-ref}]([character/bch]{.title-ref}.md)")]),e("p",null,"Contains logic that may be used to convert a block driver into a character driver. This is the complementary conversion as that performed by loop.c.")]),e("li",null,[e("p",null,[e("code",null,"can/"),l(" [[character/can]{.title-ref}]([character/can]{.title-ref}.md)")]),e("p",null,"This is the CAN drivers and logic support.")]),e("li",null,[e("p",null,[e("code",null,"clk/"),l("[[](]{.title-ref}.md)special/clk`")]),e("p",null,"Clock management (CLK) device drivers.")]),e("li",{class:"title-ref"},[e("p",null,[e("code",null,"contactless/"),l(" [[character/contactle](`character/contactle.md)ss]")]),e("p",null,"Contactless devices are related to wireless devices. They are not communication devices with other similar peers, but couplers/interfaces to contactless cards and tags.")]),e("li",null,[e("p",null,[e("code",null,"crypto/"),l(" [[character/crypto/index]{.title-ref}]([character/crypto/index]{.title-ref}.md)")]),e("p",null,[l("Contains crypto drivers and support logic, including the "),e("code",null,"/dev/urandom"),l(" device.")])]),e("li",null,[e("p",null,[e("code",null,"devicetree/"),l(" [[](]{.title-ref}.md)special/devicetree`")]),e("p",null,"Device Tree support.")]),e("li",null,[e("p",null,[e("code",null,"dma/"),l(" [[](]{.title-ref}.md)special/dma`")]),e("p",null,"DMA drivers support.")]),e("li",null,[e("p",null,[e("code",null,"eeprom/"),l(" [[block/eeprom]{.title-ref}]([block/eeprom]{.title-ref}.md)")]),e("p",null,[l("An EEPROM is a form of Memory Technology Device (see "),e("code",null,"drivers/mtd"),l("). EEPROMs are non-volatile memory like FLASH, but differ in underlying memory technology and differ in usage in many respects: They may not be organized into blocks (at least from the standpoint of the user) and it is not necessary to erase the EEPROM memory before re-writing it. In addition, EEPROMs tend to be much smaller than FLASH parts, usually only a few kilobytes vs megabytes for FLASH. EEPROM tends to be used to retain a small amount of device configuration information; FLASH tends to be used for program or massive data storage. For these reasons, it may not be convenient to use the more complex MTD interface but instead use the simple character interface provided by the EEPROM drivers.")])]),e("li",{class:"title-ref"},[e("p",null,[e("code",null,"efuse/"),l(" [[character/efu](`character/efu.md)se]")]),e("p",null,"EFUSE drivers support.")]),e("li",null,[e("p",null,[e("code",null,"i2c/"),l(" [[](]{.title-ref}.md)special/i2c`")]),e("p",null,"I2C drivers and support logic.")]),e("li",{class:"title-ref"},[e("p",null,[e("code",null,"i2s/"),l(" [[character/i2](`character/i2.md)s]")]),e("p",null,"I2S drivers and support logic.")]),e("li",null,[e("p",null,[e("code",null,"i3c/"),l(" [[](]{.title-ref}.md)special/i3c`")]),e("p",null,"I3C drivers and support logic.")]),e("li",null,[e("p",null,[e("code",null,"input/"),l(" [[character/input/index]{.title-ref}]([character/input/index]{.title-ref}.md)")]),e("p",null,"This directory holds implementations of human input device (HID) drivers. This includes such things as mouse, touchscreen, joystick, keyboard and keypad drivers."),e("p",null,[l("Note that USB HID devices are treated differently. These can be found under "),e("code",null,"usbdev/"),l(" or "),e("code",null,"usbhost/"),l(".")])]),e("li",null,[e("p",null,[e("code",null,"ioexpander/"),l(" [[](]{.title-ref}.md)special/ioexpander`")]),e("p",null,"IO Expander drivers.")]),e("li",null,[e("p",null,[e("code",null,"ipcc/"),l(" [[character/ipcc]{.title-ref}]([character/ipcc]{.title-ref}.md)")]),e("p",null,"IPCC (Inter Processor Communication Controller) driver.")]),e("li",null,[e("p",null,[e("code",null,"lcd/"),l(" [[](]{.title-ref}.md)special/lcd`")]),e("p",null,"Drivers for parallel and serial LCD and OLED type devices.")]),e("li",{class:"title-ref"},[e("p",null,[e("code",null,"leds/"),l(" [[character/led](`character/led.md)s/index]")]),e("p",null,"Various LED-related drivers including discrete as well as PWM- driven LEDs.")]),e("li",null,[e("p",null,[e("code",null,"loop/"),l(" [[character/loop]{.title-ref}]([character/loop]{.title-ref}.md)")]),e("p",null,"Supports the standard loop device that can be used to export a file (or character device) as a block device."),e("p",null,[l("See "),e("code",null,"losetup()"),l(" and "),e("code",null,"loteardown()"),l(" in "),e("code",null,"include/nuttx/fs/fs.h"),l(".")])]),e("li",null,[e("p",null,[e("code",null,"math/"),l(" [[character/math]{.title-ref}]([character/math]{.title-ref}.md)")]),e("p",null,"MATH Acceleration drivers.")]),e("li",{class:"title-ref"},[e("p",null,[e("code",null,"misc/"),l(" [[character/nullzero]{.title-ref} "),e("code",{class:"interpreted-text",role:"doc"},"](`character/nullzero"),e("code",{class:"interpreted-text",role:"doc"},".md)special/rwbuffer"),l(" [[block/ramdi](`block/ramdi.md)sk]")]),e("p",null,"Various drivers that don't fit elsewhere.")]),e("li",null,[e("p",null,[e("code",null,"mmcsd/"),l(" [[](]{.title-ref}.md)special/sdio` [[](]{.title-ref}.md)special/mmcsd`")]),e("p",null,"Support for MMC/SD block drivers. MMC/SD block drivers based on SPI and SDIO/MCI interfaces are supported.")]),e("li",null,[e("p",null,[e("code",null,"modem/"),l(" [[character/modem]{.title-ref}]([character/modem]{.title-ref}.md)")]),e("p",null,"Modem Support.")]),e("li",null,[e("p",null,[e("code",null,"motor/"),l(" [[character/motor/index]{.title-ref}]([character/motor/index]{.title-ref}.md)")]),e("p",null,"Motor control drivers.")]),e("li",null,[e("p",null,[e("code",null,"mtd/"),l(" [[](]{.title-ref}.md)special/mtd`")]),e("p",null,"Memory Technology Device (MTD) drivers. Some simple drivers for memory technologies like FLASH, EEPROM, NVRAM, etc."),e("p",null,'(Note: This is a simple memory interface and should not be confused with the "real" MTD developed at infradead.org. This logic is unrelated; I just used the name MTD because I am not aware of any other common way to refer to this class of devices).')]),e("li",null,[e("p",null,[e("code",null,"net/"),l(" [[](]{.title-ref}.md)special/net/index`")]),e("p",null,"Network interface drivers.")]),e("li",null,[e("p",null,[e("code",null,"notes/"),l(" [[character/note]{.title-ref}]([character/note]{.title-ref}.md)")]),e("p",null,"Note Driver Support.")]),e("li",null,[e("p",null,[e("code",null,"pinctrl/"),l(" [[](]{.title-ref}.md)special/pinctrl`")]),e("p",null,"Configure and manage pin.")]),e("li",null,[e("p",null,[e("code",null,"pipes/"),l(" [[](]{.title-ref}.md)special/pipes`")]),e("p",null,[l("FIFO and named pipe drivers. Standard interfaces are declared in "),e("code",null,"include/unistd.h")])]),e("li",null,[e("p",null,[e("code",null,"power/"),l(" [[](]{.title-ref}.md)special/power/index`")]),e("p",null,"Various drivers related to power management.")]),e("li",null,[e("p",null,[e("code",null,"rc/"),l(" [[character/rc]{.title-ref}]([character/rc]{.title-ref}.md)")]),e("p",null,"Remote Control Device Support.")]),e("li",null,[e("p",null,[e("code",null,"regmap/"),l(" [[](]{.title-ref}.md)special/regmap`")]),e("p",null,"Regmap Subsystems Support.")]),e("li",null,[e("p",null,[e("code",null,"reset/"),l(" [[](]{.title-ref}.md)special/reset`")]),e("p",null,"Reset Driver Support.")]),e("li",null,[e("p",null,[e("code",null,"rf/"),l(" [[character/rf]{.title-ref}]([character/rf]{.title-ref}.md)")]),e("p",null,"RF Device Support.")]),e("li",null,[e("p",null,[e("code",null,"rptun/"),l(" [[](]{.title-ref}.md)special/rptun`")]),e("p",null,"Remote Proc Tunnel Driver Support.")]),e("li",null,[e("p",null,[e("code",null,"segger/"),l(" [[](]{.title-ref}.md)special/segger`")]),e("p",null,"Segger RTT drivers.")]),e("li",null,[e("p",null,[e("code",null,"sensors/"),l(" [[](]{.title-ref}.md)special/sensors`")]),e("p",null,"Drivers for various sensors. A sensor driver differs little from other types of drivers other than they are use to provide measurements of things in environment like temperature, orientation, acceleration, altitude, direction, position, etc."),e("p",null,[l("DACs might fit this definition of a sensor driver as well since they measure and convert voltage levels. DACs, however, are retained in the "),e("code",null,"analog/"),l(" sub-directory.")])]),e("li",{class:"title-ref"},[e("p",null,[e("code",null,"serial/"),l("[[character/](`character/.md)serial]")]),e("p",null,"Front-end character drivers for chip-specific UARTs. This provide some TTY-like functionality and are commonly used (but not required for) the NuttX system console.")]),e("li",null,[e("p",null,[e("code",null,"spi/"),l(" [[](]{.title-ref}.md)special/spi`")]),e("p",null,"SPI drivers and support logic.")]),e("li",null,[e("p",null,[e("code",null,"syslog/"),l(" [[](]{.title-ref}.md)special/syslog`")]),e("p",null,"System logging devices.")]),e("li",{class:"title-ref"},[e("p",null,[e("code",null,"timers/"),l(" [[character/timer](`character/timer.md)s/index]")]),e("p",null,"Includes support for various timer devices.")]),e("li",null,[e("p",null,[e("code",null,"usbdev/"),l(" [[](]{.title-ref}.md)special/usbdev`")]),e("p",null,"USB device drivers.")]),e("li",null,[e("p",null,[e("code",null,"usbhost/"),l(" [[](]{.title-ref}.md)special/usbhost`")]),e("p",null,"USB host drivers.")]),e("li",null,[e("p",null,[e("code",null,"usbmisc/"),l(" [[](]{.title-ref}.md)special/usbmisc`")]),e("p",null,"USB Miscellaneous drivers.")]),e("li",null,[e("p",null,[e("code",null,"usbmonitor/"),l(" [[](]{.title-ref}.md)special/usbmonitor`")]),e("p",null,"USB Monitor support.")]),e("li",null,[e("p",null,[e("code",null,"usrsock/"),l(" [[](]{.title-ref}.md)special/usrsock`")]),e("p",null,"Usrsock Driver Support.")]),e("li",null,[e("p",null,[e("code",null,"video/"),l(" [[](]{.title-ref}.md)special/video`")]),e("p",null,"Video-related drivers.")]),e("li",null,[e("p",null,[e("code",null,"virtio/"),l(" [[](]{.title-ref}.md)special/virtio`")]),e("p",null,"Virtio Device Support.")]),e("li",null,[e("p",null,[e("code",null,"wireless/"),l(" [[](]{.title-ref}.md)special/wireless`")]),e("p",null,"Drivers for various wireless devices.")])],-1),i("",4),e("p",null,[l("To initialize drivers early in the boot process, the :c"),e("code",{class:"interpreted-text",role:"func"},"drivers_early_initialize"),l(" function is introduced. This is particularly beneficial for certain drivers, such as SEGGER SystemView, or others that require initialization before the system is fully operational.")],-1),e("p",null,"It is important to note that during this early initialization phase, system resources are not yet available for use. This includes memory allocation, file systems, and any other system resources.",-1)]))}const v=t(a,[["render",s]]);export{f as __pageData,v as default};
