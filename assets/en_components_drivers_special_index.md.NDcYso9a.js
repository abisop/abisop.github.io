import{_ as s,c as r,al as t,o as i}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"Specialized Device Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/special/index.md","filePath":"en/components/drivers/special/index.md"}'),a={name:"en/components/drivers/special/index.md"};function c(o,e,d,n,p,l){return i(),r("div",null,e[0]||(e[0]=[t('<h1 id="specialized-device-drivers" tabindex="-1">Specialized Device Drivers <a class="header-anchor" href="#specialized-device-drivers" aria-label="Permalink to &quot;Specialized Device Drivers&quot;">â€‹</a></h1><p>All device drivers that are accessible to application logic are either: (1) Character device drivers that can be accessed via the standard driver operations (<code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, etc.), or (2) block drivers that can be accessing only as part of mounting a file system or other special use cases as described in the preceding paragraph.</p><p>In addition to this, there are also specialized &quot;drivers&quot; that can be used only within the OS logic itself and are not accessible to application logic. These specialized drivers are discussed in the following section.</p><p>Note</p><p>While special drivers are <em>internal</em>, in some cases there are also character/block drivers that sit on top of these special drivers and thus expose them to applications.</p><p>audio.rst clk.rst devicetree.rst devmem.rst dma.rst framebuffer.rst i2c.rst i3c.rst ioexpander.rst lcd.rst mtd.rst regmap.rst reset.rst rptun.rst rwbuffer.rst sensors.rst segger.rst spi.rst syslog.rst sdio.rst usbdev.rst usbhost.rst usbmisc.rst usbmonitor.rst usrsock.rst mmcsd.rst net/index.rst pci/index.rst pinctrl.rst pipes.rst power/index.rst virtio.rst video.rst wireless.rst</p>',6)]))}const m=s(a,[["render",c]]);export{h as __pageData,m as default};
