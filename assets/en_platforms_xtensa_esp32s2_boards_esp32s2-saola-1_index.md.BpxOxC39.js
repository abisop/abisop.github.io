import{_ as a,c as t,al as n,o}from"./chunks/framework.NFAqBSgQ.js";const s="/assets/esp32-s2-saola-1-v1.2-isometric.B-aKt6HE.png",r="data:image/png;base64,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",m=JSON.parse('{"title":"ESP32-S2-Saola-1","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/xtensa/esp32s2/boards/esp32s2-saola-1/index.md","filePath":"en/platforms/xtensa/esp32s2/boards/esp32s2-saola-1/index.md"}'),i={name:"en/platforms/xtensa/esp32s2/boards/esp32s2-saola-1/index.md"};function d(l,e,c,p,h,A){return o(),t("div",null,e[0]||(e[0]=[n('<h1 id="esp32-s2-saola-1" tabindex="-1">ESP32-S2-Saola-1 <a class="header-anchor" href="#esp32-s2-saola-1" aria-label="Permalink to &quot;ESP32-S2-Saola-1&quot;">​</a></h1><p>chip:esp32, chip:esp32s2</p><p>The <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32s2/hw-reference/esp32s2/user-guide-saola-1-v1.2.html" target="_blank" rel="noreferrer">ESP32-S2-Saola-1</a> is a development board for the ESP32-S2 SoC from Espressif, based on the following modules:</p><blockquote><ul><li>ESP32-S2-WROVER</li><li>ESP32-S2-WROVER-I</li><li>ESP32-S2-WROOM</li><li>ESP32-S2-WROOM-I</li></ul></blockquote><p>In this guide, we take ESP32-S2-Saola-1 equipped with ESP32-S2-WROVER as an example.</p><p><img src="'+s+`" alt="ESP32-S2-Saola-1" class="align-center"></p><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h2><blockquote><ul><li>ESP32-S2-WROVER <ul><li>4 MB external SPI flash + 2 MB PSRAM</li></ul></li><li>USB-to-UART bridge via micro USB port</li><li>Power LED</li><li>EN and BOOT buttons</li><li>RGB LED (Addressable RGB LED (WS2812), driven by GPIO18)</li></ul></blockquote><h2 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h2><p>UART0 is, by default, the serial console. It connects to the on-board CP2102 converter and is available on the micro-USB connector (J1).</p><p>It will show up as /dev/ttyUSB[n] where [n] will probably be 0.</p><h2 id="buttons-and-leds" tabindex="-1">Buttons and LEDs <a class="header-anchor" href="#buttons-and-leds" aria-label="Permalink to &quot;Buttons and LEDs&quot;">​</a></h2><h3 id="board-buttons" tabindex="-1">Board Buttons <a class="header-anchor" href="#board-buttons" aria-label="Permalink to &quot;Board Buttons&quot;">​</a></h3><p>There are two buttons labeled Boot and EN. The EN button is not available to the software. It pulls the chip enable line that doubles as a reset line.</p><p>The BOOT button is connected to IO0. On reset, it is used as a strapping pin to determine whether the chip boots normally or into the serial bootloader. After resetting, however, the BOOT button can be used for software input.</p><h3 id="board-leds" tabindex="-1">Board LEDs <a class="header-anchor" href="#board-leds" aria-label="Permalink to &quot;Board LEDs&quot;">​</a></h3><p>There are two on-board LEDs. RED_LED (D5) indicates the presence of 3.3V power and is not controlled by software. RGB LED (U6) is a WS2812 addressable LED and is driven by GPIO18.</p><h2 id="i2s" tabindex="-1">I2S <a class="header-anchor" href="#i2s" aria-label="Permalink to &quot;I2S&quot;">​</a></h2><p>ESP32-S2 has an I2S peripheral accessible using either the generic I2S audio driver or a specific audio codec driver (<a href="https://www.cirrus.com/products/cs4344-45-48/" target="_blank" rel="noreferrer">CS4344</a> bindings are available at the moment). The generic I2S audio driver enables using both the receiver module (RX) and the transmitter module (TX) without using any specific codec. Also, it&#39;s possible to use the I2S character device driver to bypass the audio subsystem and write directly to the I2S peripheral.</p><p>Note</p><p>When using the audio system, sample rate and data width are automatically set by the upper half audio driver.</p><p>Note</p><p>The above statement is not valid when using the I2S character device driver. It&#39;s possible to use 8, 16, 24, and 32-bit-widths writing directly to the I2S character device. Just make sure to set the bit-width:</p><pre><code> make menuconfig
</code></pre><p>-&gt; System Type</p><p>:</p><pre><code>-\\&gt; ESP32-S2 Peripheral Selection

:   

    -\\&gt; I2S

    :   -\\&gt; Bit Width
</code></pre><p>The following configurations use the I2S peripheral::</p><p>: - <code>platforms/xtensa/esp32s2/boards/esp32s2-saola-1/index:audio</code>{.interpreted-text role=&quot;ref&quot;} - <code>platforms/xtensa/esp32s2/boards/esp32s2-saola-1/index:i2schar</code>{.interpreted-text role=&quot;ref&quot;} - <code>platforms/xtensa/esp32s2/boards/esp32s2-saola-1/index:nxlooper</code>{.interpreted-text role=&quot;ref&quot;}</p><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><p>All of the configurations presented below can be tested by running the following commands:</p><pre><code> ./tools/configure.sh esp32s2-saola-1:&lt;config_name&gt;
 make flash ESPTOOL_PORT=/dev/ttyUSB0 -j
</code></pre><p>Where &lt;config_name&gt; is the name of board configuration you want to use, i.e.: nsh, buttons, wifi... Then use a serial console terminal like <code>picocom</code> configured to 115200 8N1.</p><h3 id="adc" tabindex="-1">adc <a class="header-anchor" href="#adc" aria-label="Permalink to &quot;adc&quot;">​</a></h3><p>The <code>adc</code> configuration enables the ADC driver and the ADC example application. ADC Unit 1 is registered to <code>/dev/adc0</code> with channels 0, 1, 2 and 3 enabled by default. Currently, the ADC operates in oneshot mode.</p><p>More ADC channels can be enabled or disabled in <code>ADC Configuration</code> menu.</p><p>This example shows channels 0 and 1 connected to 3.3 V and channels 2 and 3 to GND (all readings show in units of mV):</p><pre><code>nsh&gt; adc -n 1
adc_main: g_adcstate.count: 1
adc_main: Hardware initialized. Opening the ADC device: /dev/adc0
Sample:
1: channel: 0 value: 3061
2: channel: 1 value: 3061
3: channel: 2 value: 106
4: channel: 3 value: 99
</code></pre><h3 id="audio" tabindex="-1">audio <a class="header-anchor" href="#audio" aria-label="Permalink to &quot;audio&quot;">​</a></h3><p>This configuration uses the I2S peripheral and an externally connected audio codec to play an audio file. The easiest way of playing an uncompressed file is embedding into the firmware. This configuration selects <a href="https://github.com/apache/nuttx-apps/tree/master/examples/romfs" target="_blank" rel="noreferrer">romfs example</a> to allow that.</p><p><strong>Audio Codec Setup</strong></p><p>The CS4344 audio codec is connected to the following pins:</p><p>ESP32-S2 Pin CS4344 Pin Description</p><hr><p>33 MCLK Master Clock 35 SCLK Serial Clock 34 LRCK Left Right Clock (Word Select) 36 SDIN Serial Data In on CS4344. (DOUT on ESP32)</p><p><strong>ROMFS example</strong></p><p>Prepare and build the <code>audio</code> defconfig:</p><pre><code> make -j distclean &amp;&amp; ./tools/configure.sh esp32s2-saola-1:audio &amp;&amp; make
</code></pre><p>This will create a temporary folder in <code>apps/examples/romfs/testdir</code>. Move a PCM-encoded (<code>.wav</code>) audio file with 16 or 24 bits/sample (sampled at 16~48kHz) to this folder.</p><p>Note</p><p>You can use <code>this 440 Hz sinusoidal tone &lt;tone.wav&gt;</code>{.interpreted-text role=&quot;download&quot;}. The audio file should be located at <code>apps/examples/romfs/testdir/tone.wav</code></p><p>Build the project again and flash it (make sure not to clean it, just build)</p><p>After successfully built and flashed, load the romfs and play it:</p><pre><code>nsh&gt; romfs
nsh&gt; nxplayer
nxplayer&gt; play /usr/share/local/tone.wav
</code></pre><h3 id="buttons" tabindex="-1">buttons <a class="header-anchor" href="#buttons" aria-label="Permalink to &quot;buttons&quot;">​</a></h3><p>This configuration shows the use of the buttons subsystem. It can be used by executing the <code>buttons</code> application and pressing on any of the available board buttons:</p><pre><code>nsh&gt; buttons
buttons_main: Starting the button_daemon
buttons_main: button_daemon started
button_daemon: Running
button_daemon: Opening /dev/buttons
button_daemon: Supported BUTTONs 0x01
nsh&gt; Sample = 1
Sample = 0
</code></pre><h3 id="coremark" tabindex="-1">coremark <a class="header-anchor" href="#coremark" aria-label="Permalink to &quot;coremark&quot;">​</a></h3><p>This configuration sets the CoreMark benchmark up for running on the maximum number of cores for this system. It also enables some optimization flags and disables the NuttShell to get the best possible score.</p><p>Note</p><p>As the NSH is disabled, the application will start as soon as the system is turned on.</p><h3 id="cxx" tabindex="-1">cxx <a class="header-anchor" href="#cxx" aria-label="Permalink to &quot;cxx&quot;">​</a></h3><p>Development environment ready for C++ applications. You can check if the setup was successful by running <code>cxxtest</code>:</p><pre><code>nsh&gt; cxxtest
Test ofstream ================================
printf: Starting test_ostream
printf: Successfully opened /dev/console
cout: Successfully opened /dev/console
Writing this to /dev/console
Test iostream ================================
Hello, this is only a test
Print an int: 190
Print a char: d
Test std::vector =============================
v1=1 2 3
Hello World Good Luck
Test std::map ================================
Test C++17 features ==========================
File /proc/meminfo exists!
Invalid file! /invalid
File /proc/version exists!
</code></pre><h3 id="gpio" tabindex="-1">gpio <a class="header-anchor" href="#gpio" aria-label="Permalink to &quot;gpio&quot;">​</a></h3><p>This is a test for the GPIO driver. It includes one arbitrary GPIO. For this example, GPIO1 was used (defined by the board implementation). At the nsh, we can turn the GPIO output on and off with the following:</p><pre><code>nsh&gt; gpio -o 1 /dev/gpio0
nsh&gt; gpio -o 0 /dev/gpio0
</code></pre><h3 id="i2c" tabindex="-1">i2c <a class="header-anchor" href="#i2c" aria-label="Permalink to &quot;i2c&quot;">​</a></h3><p>This configuration can be used to scan and manipulate I2C devices. You can scan for all I2C devices using the following command:</p><pre><code>nsh&gt; i2c dev 0x00 0x7f
</code></pre><p>To use slave mode, you can enable [ESP32S2_I2S_ROLE_SLAVE]{.title-ref} option. To use slave mode driver following snippet demonstrates how write to i2c bus using slave driver:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#define ESP_I2C_SLAVE_PATH  &quot;/dev/i2cslv0&quot;</span></span>
<span class="line"><span>int main(int argc, char *argv[])</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    int i2c_slave_fd;</span></span>
<span class="line"><span>    int ret;</span></span>
<span class="line"><span>    uint8_t buffer[5] = {0xAA};</span></span>
<span class="line"><span>    i2c_slave_fd = open(ESP_I2C_SLAVE_PATH, O_RDWR);</span></span>
<span class="line"><span>    ret = write(i2c_slave_fd, buffer, 5);</span></span>
<span class="line"><span>    close(i2c_slave_fd);</span></span>
<span class="line"><span> }</span></span></code></pre></div><h3 id="i2schar" tabindex="-1">i2schar <a class="header-anchor" href="#i2schar" aria-label="Permalink to &quot;i2schar&quot;">​</a></h3><p>This configuration enables the I2S character device and the i2schar example app, which provides an easy-to-use way of testing the I2S peripheral, enabling both the TX and the RX for those peripherals.</p><p><strong>I2S pinout</strong></p><p>ESP32-S2 Pin Signal Pin Description</p><hr><p>33 MCLK Master Clock 35 SCLK Bit Clock (SCLK) 34 LRCK Word Select (LRCLK) 36 DOUT Data Out 37 DIN Data In</p><p>After successfully built and flashed, run on the boards&#39;s terminal:</p><pre><code>nsh&gt; i2schar
</code></pre><p>The corresponding output should show related debug information.</p><h3 id="mcuboot-nsh" tabindex="-1">mcuboot_nsh <a class="header-anchor" href="#mcuboot-nsh" aria-label="Permalink to &quot;mcuboot\\_nsh&quot;">​</a></h3><p>This configuration is the same as the <code>nsh</code> configuration, but it generates the application image in a format that can be used by MCUboot. It also makes the <code>make bootloader</code> command to build the MCUboot bootloader image using the Espressif HAL.</p><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>Basic NuttShell configuration (console enabled in UART0, exposed via USB connection by means of CP2102 converter, at 115200 bps).</p><h3 id="nxlooper" tabindex="-1">nxlooper <a class="header-anchor" href="#nxlooper" aria-label="Permalink to &quot;nxlooper&quot;">​</a></h3><p>This configuration uses the I2S peripheral as an I2S receiver and transmitter at the same time. The idea is to capture an I2S data frame using the RX module and reproduce the captured data on the TX module.</p><p><strong>Receiving and transmitting data on I2S</strong></p><p>The I2S will act as a receiver (master mode), capturing data from DIN, which needs to be connected to an external source as follows:</p><p>ESP32-S2 Pin Signal Pin Description</p><hr><p>33 MCLK Master Clock 35 SCLK Bit Clock (SCLK) Output 34 LRCK Word Select (LRCLK) Output 36 DOUT Data Out 37 DIN Data In</p><p>The DOUT pin will output the captured data frame.</p><p>Note</p><p>The ESP32-S2 contains a single I2S peripheral, so the peripheral works on &quot;full-duplex&quot; mode. The [SCLK]{.title-ref} and [LRCK]{.title-ref} signals are connected internally and the TX module is set-up as slave and the RX as master.</p><p><strong>nxlooper</strong></p><p>The <code>nxlooper</code> application captures data from the audio device with receiving capabilities and forwards the audio data frame to the audio device with transmitting capabilities.</p><p>After successfully built and flashed, run on the boards&#39;s terminal:</p><pre><code>nsh&gt; nxlooper
nxlooper&gt; loopback
</code></pre><p>Note</p><p><code>loopback</code> command default arguments for the channel configuration, the data width and the sample rate are, respectively, 2 channels, 16 bits/sample and 48KHz. These arguments can be supplied to select different audio formats, for instance:</p><p>nxlooper&gt; loopback 2 8 44100</p><h3 id="oneshot" tabindex="-1">oneshot <a class="header-anchor" href="#oneshot" aria-label="Permalink to &quot;oneshot&quot;">​</a></h3><p>This config demonstrate the use of oneshot timers present on the ESP32-S2. To test it, just run the <code>oneshot</code> example:</p><pre><code>nsh&gt; oneshot
Opening /dev/oneshot
Maximum delay is 4294967295999999
Starting oneshot timer with delay 2000000 microseconds
Waiting...
Finished
</code></pre><h3 id="ostest" tabindex="-1">ostest <a class="header-anchor" href="#ostest" aria-label="Permalink to &quot;ostest&quot;">​</a></h3><p>This is the NuttX test at apps/testing/ostest that is run against all new architecture ports to assure a correct implementation of the OS.</p><p>qencoder ---</p><p>This configuration demonstrates the use of Quadrature Encoder connected to pins GPIO10 and GPIO11. You can start measurement of pulses using the following command (by default, it will open <code>\\dev\\qe0</code> device and print 20 samples using 1 second delay):</p><pre><code>nsh&gt; qe
</code></pre><h3 id="pwm" tabindex="-1">pwm <a class="header-anchor" href="#pwm" aria-label="Permalink to &quot;pwm&quot;">​</a></h3><p>This configuration demonstrates the use of PWM through a LED connected to GPIO2. To test it, just execute the <code>pwm</code> application:</p><pre><code>nsh&gt; pwm
pwm_main: starting output with frequency: 10000 duty: 00008000
pwm_main: stopping output
</code></pre><h3 id="random" tabindex="-1">random <a class="header-anchor" href="#random" aria-label="Permalink to &quot;random&quot;">​</a></h3><p>This configuration shows the use of the ESP32-S2&#39;s True Random Number Generator with entropy sourced from Wi-Fi and Bluetooth noise. To test it, just run <code>rand</code> to get 32 randomly generated bytes:</p><pre><code>nsh&gt; rand
Reading 8 random numbers
Random values (0x3ffe0b00):
0000  98 b9 66 a2 a2 c0 a2 ae 09 70 93 d1 b5 91 86 c8  ..f......p......
0010  8f 0e 0b 04 29 64 21 72 01 92 7c a2 27 60 6f 90  ....)d!r..|.&#39;\`o.
</code></pre><h3 id="rmt" tabindex="-1">rmt <a class="header-anchor" href="#rmt" aria-label="Permalink to &quot;rmt&quot;">​</a></h3><p>This configuration configures the transmitter and the receiver of the Remote Control Transceiver (RMT) peripheral on the ESP32-S2 using GPIOs 18 and 2, respectively. The RMT peripheral is better explained <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32s2/api-reference/peripherals/rmt.html" target="_blank" rel="noreferrer">here</a>, in the ESP-IDF documentation. The minimal data unit in the frame is called the RMT symbol, which is represented by <code>rmt_item32_t</code> in the driver:</p><p><img src="`+r+`" alt="" class="align-center"></p><p>The example <code>rmtchar</code> can be used to test the RMT peripheral. Connecting these pins externally to each other will make the transmitter send RMT items and demonstrates the usage of the RMT peripheral:</p><pre><code>nsh&gt; rmtchar
</code></pre><p><strong>WS2812 addressable RGB LEDs</strong></p><p>This same configuration enables the usage of the RMT peripheral and the example <code>ws2812</code> to drive addressable RGB LEDs:</p><pre><code>nsh&gt; ws2812
</code></pre><p>Please note that this board contains an on-board WS2812 LED connected to GPIO18 and, by default, this config configures the RMT transmitter in the same pin.</p><h3 id="rtc" tabindex="-1">rtc <a class="header-anchor" href="#rtc" aria-label="Permalink to &quot;rtc&quot;">​</a></h3><p>This configuration demonstrates the use of the RTC driver through alarms. You can set an alarm, check its progress and receive a notification after it expires:</p><pre><code>nsh&gt; alarm 10
alarm_daemon started
alarm_daemon: Running
Opening /dev/rtc0
Alarm 0 set in 10 seconds
nsh&gt; alarm -r
Opening /dev/rtc0
Alarm 0 is active with 10 seconds to expiration
nsh&gt; alarm_daemon: alarm 0 received
</code></pre><h3 id="timer" tabindex="-1">timer <a class="header-anchor" href="#timer" aria-label="Permalink to &quot;timer&quot;">​</a></h3><p>This config tests the general-use purpose timers. It includes the 4 timers, adds driver support, registers the timers as devices and includes the timer example.</p><p>To test it, just run the following:</p><pre><code>nsh&gt; timer -d /dev/timerx
</code></pre><p>Where x in the timer instance.</p><h3 id="twai" tabindex="-1">twai <a class="header-anchor" href="#twai" aria-label="Permalink to &quot;twai&quot;">​</a></h3><p>This configuration enables the support for the TWAI (Two-Wire Automotive Interface) driver. You can test it by connecting TWAI RX and TWAI TX pins which are GPIO0 and GPIO2 by default to a external transceiver or connecting TWAI RX to TWAI TX pin by enabling the <code>Device Drivers -&gt; CAN Driver Support -&gt; CAN loopback mode</code> option and running the <code>can</code> example:</p><pre><code>nsh&gt; can
nmsgs: 0
min ID: 1 max ID: 2047
Bit timing:
  Baud: 1000000
  TSEG1: 15
  TSEG2: 4
    SJW: 3
  ID:    1 DLC: 1
</code></pre><h3 id="watchdog" tabindex="-1">watchdog <a class="header-anchor" href="#watchdog" aria-label="Permalink to &quot;watchdog&quot;">​</a></h3><p>This config test the watchdog timers. It includes the 2 MWDTs, adds driver support, registers the WDTs as devices and includes the watchdog example.</p><p>To test it, just run the following:</p><pre><code>nsh&gt; wdog -i /dev/watchdogx
</code></pre><p>Where x is the watchdog instance.</p><p>To test the XTWDT(/dev/watchdog3) an interrupt handler needs to be implemented because XTWDT does not have system reset feature. To implement an interrupt handler [WDIOC_CAPTURE]{.title-ref} command can be used. When interrupt rises, XTAL32K clock can be restored with [WDIOC_RSTCLK]{.title-ref} command.</p>`,142)]))}const g=a(i,[["render",d]]);export{m as __pageData,g as default};
