import{_ as a,c as s,al as t,o as n}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Analyzing Cortex-M Hardfaults","description":"","frontmatter":{},"headers":[],"relativePath":"en/debugging/cortexmhardfaults.md","filePath":"en/debugging/cortexmhardfaults.md"}'),i={name:"en/debugging/cortexmhardfaults.md"};function o(l,e,p,r,c,h){return n(),s("div",null,e[0]||(e[0]=[t(`<h1 id="analyzing-cortex-m-hardfaults" tabindex="-1">Analyzing Cortex-M Hardfaults <a class="header-anchor" href="#analyzing-cortex-m-hardfaults" aria-label="Permalink to &quot;Analyzing Cortex-M Hardfaults&quot;">​</a></h1><blockquote><p>&gt; I have a build of PX4 (NuttX 6.29 with some patches) with new &gt; lpc43xx chip files on 4337 chip running from FLASH (master &gt; vanilla NuttX has no such problem). This gives me a hardfault &gt; below if I stress NSH console (UART2) with some big output. &gt; &gt; I read some threads but can&#39;t get a clue how to analyze the &gt; dump and where to look first: &gt; &gt; 1bXXX and 1aXXX addresses are FLASH. 100XXX addresses are RAM</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Assertion failed at file:armv7-m/up_hardfault.c line: 184 task: hpwork</span></span>
<span class="line"><span>sp:     10001eb4</span></span>
<span class="line"><span>IRQ stack:</span></span>
<span class="line"><span>  base: 10001f00</span></span>
<span class="line"><span>  size: 000003fc</span></span>
<span class="line"><span>10001ea0: 1b02d961 1b03f07e 10001eb4 10005ed8 1a0312ab 1b03f600 000000b8 1b02d961</span></span>
<span class="line"><span>10001ec0: 00000010 10001f40 00000003 00000000 1a03721d 1a037209 1b02d93b 00000000</span></span>
<span class="line"><span>10001ee0: 1a0371f5 00000000 00000000 00000000 00000000 00000000 1a0314a5 10005d7c</span></span>
<span class="line"><span>sp:     10005e50</span></span>
<span class="line"><span>User stack:</span></span>
<span class="line"><span>  base: 10005ed8</span></span>
<span class="line"><span>  size: 00000f9c</span></span>
<span class="line"><span>10005e40: 00000000 00000000 00000000 1b02d587 10004900 00000000 005b8d7f 00000000</span></span>
<span class="line"><span>10005e60: 1a030f2e 00000000 00000000 00001388 00000000 00000005 10001994 00000000</span></span>
<span class="line"><span>10005e80: 00000000 00000000 00000000 1b02c359 00000000 00000000 00000000 004c4b40</span></span>
<span class="line"><span>10005ea0: 000002ff 00000000 00000000 1a030f2f 00000000 00000000 00000000 00000000</span></span>
<span class="line"><span>10005ec0: 00000000 1a030f41 00000000 1b02c2a5 00000000 00000000 ffffffff 00bdeb39</span></span>
<span class="line"><span>R0: ffffffff 00000000 00000016 00000000 00000000 00000000 00000000 00000000</span></span>
<span class="line"><span>R8: 100036d8 00000000 00000000 004c4b40 10001370 10005e50 1b02b20b 1b02d596</span></span>
<span class="line"><span>xPSR: 41000000 BASEPRI: 00000000 CONTROL: 00000000</span></span>
<span class="line"><span>EXC_RETURN: ffffffe9</span></span></code></pre></div><p>This question was asked in the old Yahoo! Group for NuttX, before the project joined the Apache Software Foundation. The old forum no longer exists, but the thread has been archived at <a href="https://nuttx.yahoogroups.narkive.com/QNbG3r5l/hardfault-help-analysing-where-to-start" target="_blank" rel="noreferrer">Narkive</a> (third party external link).</p><h2 id="analyzing-the-register-dump" tabindex="-1">Analyzing the Register Dump <a class="header-anchor" href="#analyzing-the-register-dump" aria-label="Permalink to &quot;Analyzing the Register Dump&quot;">​</a></h2><p>First, in the register dump:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>R0: ffffffff 00000000 00000016 00000000 00000000 00000000 00000000 00000000</span></span>
<span class="line"><span>R8: 100036d8 00000000 00000000 004c4b40 10001370 10005e50 1b02b20b 1b02d596</span></span>
<span class="line"><span>xPSR: 41000000 BASEPRI: 00000000 CONTROL: 00000000</span></span></code></pre></div><p><code>R15</code> is the PC at the time of the crash (<code>1b02d596</code>). In order to see where this is, I do this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>arm-none-eabi-objdump -d nuttx | vi -</span></span></code></pre></div><p>Of course, you can use any editor you prefer. In any case, this will provide a full assembly language listing of your FLASH content along with complete symbolic information.</p><p><strong>TIP:</strong> Not comfortable with ARM assembly language? Try the <code>objdump --source</code> (or just <code>-S</code>) option. That will intermix the C and the assembly language code so that you can see which C statements the assembly language is implementing.</p><p>Once you have the FLASH image in the editor, it is then a simple thing to do the search in order to find the instruction at <code>1b02d596</code>. The symbolic information will show you exactly which function the address is in and also the context of the instruction that can be used to associate it to the exact line of code in the original C source file.</p><p>You also have all of the register contents so it is pretty easy to see what happened (assuming you have some basic knowledge of Thumb2 assembly language and the ARM EABI). But it is usually not so easy to see why it happened.</p><p>The rest of the instructions apply to finding out why the fault happened.</p><p><code>R14</code> often contains the return address to the caller of the offending functions. Bit one is set in this return address, but ignore that (I.e., use <code>1b02b20a</code> instead of <code>1b02b20b</code>). Use the objdump command above to see where that is.</p><p>Sometimes, however, <code>R14</code> is not the caller of the offending function. If the offending functions calls some other function then <code>R14</code> will be overwritten. But no problem, it will also then have pushed the return address on the stack where we can find it by analyzing the stack dump.</p><h2 id="analyzing-the-stack-dump" tabindex="-1">Analyzing the Stack Dump <a class="header-anchor" href="#analyzing-the-stack-dump" aria-label="Permalink to &quot;Analyzing the Stack Dump&quot;">​</a></h2><h3 id="the-task-stack" tabindex="-1">The Task Stack <a class="header-anchor" href="#the-task-stack" aria-label="Permalink to &quot;The Task Stack&quot;">​</a></h3><p>To go further back in the time, you have to analyze the stack. It is a push down stack so older events are at higher stack addresses; the most recent things that happened will be at lower stack addresses.</p><p>Analyzing the stack is done in basically the same way:</p><ol><li>Start at the highest stack addresses (oldest) and work forward in time (lower addresses)</li><li>Find interesting addresses,</li><li>Use <code>arm-none-eabi-objdump</code> to determine where those addresses are in the code.</li></ol><p>An interesting address has these properties:</p><ol><li>It lies in FLASH in your architecture. In your case these are the addresses that begin with <code>0x1a</code> and <code>0x1b</code>. Other architectures may have different FLASH addresses or even addresses in RAM.</li><li>The interesting addresses are all odd for Cortex-M, that is, bit 0 will be set. This is because as the code progresses, the return address (<code>R14</code>) will be pushed on the stack. All of the return addresses will lie in FLASH and will be odd.</li></ol><p>Even FLASH addresses in the stack dump usually are references to <code>.rodata</code> in FLASH but are sometimes of interest as well. Below are examples of interesting addresses (in brackets):</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sp:     10005e50</span></span>
<span class="line"><span>User stack:</span></span>
<span class="line"><span>  base: 10005ed8</span></span>
<span class="line"><span>  size: 00000f9c</span></span>
<span class="line"><span>10005e40: 00000000  00000000  00000000 [1b02d587] 10004900 00000000 005b8d7f 00000000</span></span>
<span class="line"><span>10005e60: 1a030f2e  00000000  00000000  00001388  00000000 00000005 10001994 00000000</span></span>
<span class="line"><span>10005e80: 00000000  00000000  00000000 [1b02c359] 00000000 00000000 00000000 004c4b40</span></span>
<span class="line"><span>10005ea0: 000002ff  00000000  00000000 [1a030f2f] 00000000 00000000 00000000 00000000</span></span>
<span class="line"><span>10005ec0: 00000000 [1a030f41] 00000000 [1b02c2a5] 00000000 00000000 ffffffff 00bdeb39</span></span></code></pre></div><p>That will give the full backtrace up to the point of the failure.</p><h3 id="the-interrupt-stack" tabindex="-1">The Interrupt Stack <a class="header-anchor" href="#the-interrupt-stack" aria-label="Permalink to &quot;The Interrupt Stack&quot;">​</a></h3><p>Note that in some cases there are two stacks listed. The interrupt stack will be present if (1) the interrupt stack is enabled, and (2) you are in an interrupt handler at the time that the failure occurred:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Assertion failed at file:armv7-m/up_hardfault.c line: 184 task: hpwork</span></span>
<span class="line"><span>sp:     10001eb4</span></span>
<span class="line"><span>IRQ stack:</span></span>
<span class="line"><span> base: 10001f00</span></span>
<span class="line"><span> size: 000003fc</span></span>
<span class="line"><span>10001ea0: [1b02d961] 1b03f07e 10001eb4 10005ed8  1a0312ab   1b03f600   000000b8 [1b02d961]</span></span>
<span class="line"><span>10001ec0:  00000010  10001f40 00000003 00000000 [1a03721d] [1a037209] [1b02d93b] 00000000</span></span>
<span class="line"><span>10001ee0: [1a0371f5] 00000000 00000000 00000000  00000000   00000000  [1a0314a5] 10005d7c</span></span></code></pre></div><p>(Interesting addresses again in brackets).</p><p>The interrupt stack is sometimes interesting, for example when the interrupt was caused by logic operating at the interrupt level. In this case, it is probably not so interesting since fault was probably caused by normal task code and the interrupt stack probably just shows the normal operation of the interrupt handling logic.</p><h3 id="full-stack-analysis" tabindex="-1">Full Stack Analysis <a class="header-anchor" href="#full-stack-analysis" aria-label="Permalink to &quot;Full Stack Analysis&quot;">​</a></h3><p>What I have proposed here is just skimming through the stack, finding and interpreting interesting addresses. Sometimes you need more information and you need to analyze the stack in more detail. That is also possible because every word on the stack is there because of an explicit push instruction in the code (usually a push instruction on Cortex-M or an stmdb instruction in other ARM architectures). This is painstaking work but can also be done to provide a more detailed answer to &quot;what happened?&quot;</p><h2 id="recovering-state-at-the-time-of-the-hardfault" tabindex="-1">Recovering State at the Time of the Hardfault <a class="header-anchor" href="#recovering-state-at-the-time-of-the-hardfault" aria-label="Permalink to &quot;Recovering State at the Time of the Hardfault&quot;">​</a></h2><p>Here is another tip from Mike Smith:</p><blockquote><p>&quot;... for systems like NuttX where catching hardfaults is difficult, you can recover the faulting PC, LR and SP (by examining the exception stack), then write these values back into the appropriate processor registers (adjust the PC as necessary for the fault).</p><p>&quot;This will put you back in the application code at the point at which the fault occurred. Some local variables will show as having invalid values (because at the time of the fault they were live in registers and have been overwritten by the exception handler), but the stack frame, function arguments etc. should all show correctly.&quot;</p></blockquote>`,36)]))}const f=a(i,[["render",o]]);export{u as __pageData,f as default};
