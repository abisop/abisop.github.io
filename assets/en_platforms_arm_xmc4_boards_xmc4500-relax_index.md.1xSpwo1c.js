import{_ as o,c as t,al as n,o as a}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"XMC4500 Relax","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/xmc4/boards/xmc4500-relax/index.md","filePath":"en/platforms/arm/xmc4/boards/xmc4500-relax/index.md"}'),i={name:"en/platforms/arm/xmc4/boards/xmc4500-relax/index.md"};function r(s,e,l,h,d,c){return a(),t("div",null,e[0]||(e[0]=[n(`<h1 id="xmc4500-relax" tabindex="-1">XMC4500 Relax <a class="header-anchor" href="#xmc4500-relax" aria-label="Permalink to &quot;XMC4500 Relax&quot;">​</a></h1><p>There are to variants of this board: There is a Lite version that has fewer features, for example, no 32.768KHz crystal.</p><p>The current configurations support only the Lite version of the board.</p><h2 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h2><p>2017-03-21: The XMC4500 Relax boots into NSH, provides the NSH prompt, and the LEDs are working. But there is a problem with serial input. The most likely reason for this is there are no serial RX interrupts.</p><h2 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h2><p>Be default, UART0 (aka, USIC0, channel 0) is used as the serial console. The RX and TX pins is available:</p><pre><code>RX     - P1.4, Connector X2, pin 17
TX     - P1.5, Connector X2, pin 16
GND    -       Available on pins 1-4 of either connector X1 or X2
VDD3.3 -       Available on pins 37-38 of either connector X1 or X2
VDD5   -       Available on pins 39-40 of either connector X1 or X2
</code></pre><p>A TTL to RS-232 converter or a USB TTL-to-USB serial adaptor is required. The notion of what is TX and what is RX depends on your point of view. With the TTL to RS-232 converter, I connect pin 17 to the pin labeled TX on the converter and pin 16 to the RX pin on the converter.</p><h2 id="leds" tabindex="-1">LEDs <a class="header-anchor" href="#leds" aria-label="Permalink to &quot;LEDs&quot;">​</a></h2><p>The XMC4500 Relax Lite v1 board has two LEDs:</p><pre><code>LED1 P1.1 High output illuminates
LED2 P1.0 High output illuminates
</code></pre><p>If CONFIG_ARCH_LEDS is not defined, then the user can control the LEDs in any way. The definitions provided in the board.h header file can be used to access individual LEDs.</p><p>These LEDs are not used by the board port unless CONFIG_ARCH_LEDS is defined. In that case, the usage by the board port is defined in include/board.h and src/sam_autoleds.c. The LEDs are used to encode OS-related events as follows:</p><blockquote><p>SYMBOL Meaning LED1 LED2</p><hr><p>LED_STARTED NuttX has been started OFF OFF LED_HEAPALLOCATE Heap has been allocated OFF OFF LED_IRQSENABLED Interrupts enabled OFF OFF LED_STACKCREATED Idle stack created ON OFF LED_INIRQ In an interrupt N/C N/C LED_SIGNAL In a signal handler N/C N/C LED_ASSERTION An assertion failed N/C N/C LED_PANIC The system has crashed N/C Blinking LED_IDLE MCU is is sleep mode N/C N/C</p></blockquote><p>Thus if LED1 is statically on, NuttX has successfully booted and is, apparently, running normally. If LED2 is flashing at approximately 2Hz, then a fatal error has been detected and the system has halted.</p><h2 id="buttons" tabindex="-1">Buttons <a class="header-anchor" href="#buttons" aria-label="Permalink to &quot;Buttons&quot;">​</a></h2><p>The XMC4500 Relax Lite v1 board has two buttons:</p><pre><code>BUTTON1 P1.14 Low input sensed when button pressed
BUTTON2 P1.15 Low input sensed when button pressed
</code></pre><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><h3 id="information-common-to-all-configurations" tabindex="-1">Information Common to All Configurations <a class="header-anchor" href="#information-common-to-all-configurations" aria-label="Permalink to &quot;Information Common to All Configurations&quot;">​</a></h3><p>Each XMC4500 Relax configuration is maintained in a sub-directory and can be selected as follow:</p><pre><code>.tools/configure.sh xmc4500-relax:&lt;subdir&gt;
</code></pre><p>See &#39;.tools/configure.sh -h&#39; for a list of all options. The most typical are -l to select the Linux host or -c to select the Windows Cygwin host.</p><p>Before starting the build, make sure that your PATH environment variable includes the correct path to your toolchain.</p><p>And then build NuttX by simply typing the following. At the conclusion of the make, the nuttx binary will reside in an ELF file called, simply, nuttx:</p><pre><code>make
</code></pre><p>The &lt;subdir&gt; that is provided above as an argument to the tools/configure.sh must be is one of the following.</p><p>NOTES:</p><ol><li><p>These configurations use the mconf-based configuration tool. To change any of these configurations using that tool, you should:</p><p>a. Build and install the kconfig-mconf tool. See nuttx/README.txt see additional README.txt files in the NuttX tools repository. b. Execute &#39;make menuconfig&#39; in nuttx/ in order to start the reconfiguration process.</p></li><li><p>Unless stated otherwise, all configurations generate console output on UART0 (aka USIC0, channel 0) as described above under &quot;Serial Console&quot;. The relevant configuration settings are listed below:</p><pre><code>CONFIG_XMC4_USIC0=y
CONFIG_XMC4_USIC0_CHAN0_ISUART=y
CONFIG_XMC4_USIC0_CHAN1_NONE=y

CONFIG_UART0_SERIALDRIVER=y
CONFIG_UART0_SERIAL_CONSOLE=y

CONFIG_UART0_RXBUFSIZE=256
CONFIG_UART0_TXBUFSIZE=256
CONFIG_UART0_BAUD=115200
CONFIG_UART0_BITS=8
CONFIG_UART0_PARITY=0
CONFIG_UART0_2STOP=0
</code></pre></li><li><p>All of these configurations are set up to build under Windows using the &quot;GNU Tools for ARM Embedded Processors&quot; that is maintained by ARM (unless stated otherwise in the description of the configuration).</p><blockquote><p><a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm" target="_blank" rel="noreferrer">https://developer.arm.com/open-source/gnu-toolchain/gnu-rm</a></p></blockquote></li></ol><p>That toolchain selection can easily be reconfigured using &#39;make menuconfig&#39;. Here are the relevant current settings:</p><p>Build Setup:</p><pre><code>CONFIG_HOST_WINDOWS=y               : Window environment
CONFIG_WINDOWS_CYGWIN=y             : Cywin under Windows
</code></pre><p>System Type -&gt; Toolchain:</p><pre><code>CONFIG_ARM_TOOLCHAIN_GNU_EABI=y  : GNU ARM EABI toolchain
</code></pre><h3 id="configuration-sub-directories" tabindex="-1">Configuration sub-directories <a class="header-anchor" href="#configuration-sub-directories" aria-label="Permalink to &quot;Configuration sub-directories&quot;">​</a></h3><h3 id="nsh" tabindex="-1">nsh: <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh:&quot;">​</a></h3><p>Configures the NuttShell (nsh) located at examples/nsh. This configuration is focused on low level, command-line driver testing. It has no network.</p><p>NOTES:</p><ol><li>NSH built-in applications are supported.</li></ol><p>Binary Formats:</p><pre><code>CONFIG_BUILTIN=y           : Enable support for built-in programs
</code></pre><p>Application Configuration:</p><pre><code>CONFIG_NSH_BUILTIN_APPS=y  : Enable starting apps from NSH command line
</code></pre><h2 id="spi" tabindex="-1">SPI <a class="header-anchor" href="#spi" aria-label="Permalink to &quot;SPI&quot;">​</a></h2><h3 id="using-max6675-thermocouple" tabindex="-1">Using MAX6675 Thermocouple <a class="header-anchor" href="#using-max6675-thermocouple" aria-label="Permalink to &quot;Using MAX6675 Thermocouple&quot;">​</a></h3><p>There is a board support to use a MAX6675 connected to SPI2. In other to use it you need to enable these options:</p><pre><code>CONFIG_XMC4_USIC=y
CONFIG_XMC4_USCI_UART=y
CONFIG_XMC4_USCI_SPI=y
CONFIG_XMC4_SPI2=y
CONFIG_XMC4_USIC1=y
CONFIG_XMC4_USIC1_CHAN0_ISSPI=y
CONFIG_XMC4_USIC1_CHAN1_ISUART=y
CONFIG_UART3_SERIAL_CONSOLE=y
CONFIG_SENSORS_MAX6675=y
</code></pre><p>These are the used SPI pins: SCLK = P0.11, MISO = P0.4 and CS = P0.2</p>`,49)]))}const f=o(i,[["render",r]]);export{u as __pageData,f as default};
