import{_ as t,c as o,al as a,o as n}from"./chunks/framework.NFAqBSgQ.js";const r="/assets/esp32-ethernet-kit-v1.2-overview.Bh5N_IAY.png",i="/assets/esp32-ethernet-kit-v1.2.CkBtjQdQ.jpg",s="/assets/esp32-ethernet-kit-v1.1-block-diagram.jq1SwysZ.png",l="/assets/esp32-ethernet-kit-a-v1.2-layout.BvpoUDqg.jpg",h="/assets/esp32-ethernet-kit-b-v1.0-layout.BiPPMSar.png",c="/assets/esp32-ethernet-kit-rmii-clk-from-phy.C7b1lFRE.png",d="/assets/esp32-ethernet-kit-rmii-clk-to-phy.FLc_4ZFv.png",I=JSON.parse('{"title":"ESP32-Ethernet-Kit V1.2","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/xtensa/esp32/boards/esp32-ethernet-kit/index.md","filePath":"en/platforms/xtensa/esp32/boards/esp32-ethernet-kit/index.md"}'),p={name:"en/platforms/xtensa/esp32/boards/esp32-ethernet-kit/index.md"};function u(b,e,m,f,g,P){return n(),o("div",null,e[0]||(e[0]=[a('<h1 id="esp32-ethernet-kit-v1-2" tabindex="-1">ESP32-Ethernet-Kit V1.2 <a class="header-anchor" href="#esp32-ethernet-kit-v1-2" aria-label="Permalink to &quot;ESP32-Ethernet-Kit V1.2&quot;">​</a></h1><p>chip:esp32, chip:esp32wrover32</p><p>The ESP32-Ethernet-Kit is an Ethernet-to-Wi-Fi development board that enables Ethernet devices to be interconnected over Wi-Fi. At the same time, to provide more flexible power supply options, the ESP32-Ethernet-Kit also supports power over Ethernet (PoE). You can find the board schematic <a href="https://dl.espressif.com/dl/schematics/SCH_ESP32-Ethernet-Kit_A_V1.2_20200528.pdf" target="_blank" rel="noreferrer">here</a>.</p><p><img src="'+r+`" alt="ESP32-Ethernet-Kit V1.2 Board
Layout" class="align-center"></p><p>It consists of two development boards, the Ethernet board A and the PoE board B. The Ethernet board (A) contains Bluetooth/Wi-Fi dual-mode ESP32-WROVER-E module and IP101GRI, a Single Port 10/100 Fast Ethernet Transceiver (PHY). The PoE board (B) provides power over Ethernet functionality. The A board can work independently, without the board B installed.</p><p><img src="`+i+'" alt="ESP32-Ethernet-Kit V1.2" class="align-center"></p><p>For the application loading and monitoring, the Ethernet board (A) also features FTDI FT2232H chip - an advanced multi-interface USB bridge. This chip enables to use JTAG for direct debugging of ESP32 through the USB interface without a separate JTAG debugger.</p><p>The block diagram below presents main components of the ESP32-Ethernet-Kit.</p><p><img src="'+s+`" alt="ESP32-Ethernet-Kit V1.2 Electrical Block
Diagram" class="align-center"></p><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h2><blockquote><ul><li>ESP32-WROVER-E Module</li><li>JTAG through USB</li><li>Ethernet</li><li>Power over Ethernet (PoE)</li><li>USB-to-UART bridge via micro USB port</li></ul></blockquote><h2 id="functional-description" tabindex="-1">Functional Description <a class="header-anchor" href="#functional-description" aria-label="Permalink to &quot;Functional Description&quot;">​</a></h2><p>The following figures describe the key components, interfaces, and controls of the ESP32-Ethernet-Kit.</p><h3 id="ethernet-board-a" tabindex="-1">Ethernet Board (A) <a class="header-anchor" href="#ethernet-board-a" aria-label="Permalink to &quot;Ethernet Board (A)&quot;">​</a></h3><p><img src="`+l+`" alt="ESP32-Ethernet-Kit - Ethernet board (A)
layout" class="align-center"></p><h3 id="poe-board-b" tabindex="-1">PoE Board (B) <a class="header-anchor" href="#poe-board-b" aria-label="Permalink to &quot;PoE Board (B)&quot;">​</a></h3><p>This board converts power delivered over the Ethernet cable (PoE) to provide a power supply for the Ethernet board (A). The main components of the PoE board (B) are shown on the image below.</p><p><img src="`+h+`" alt="ESP32-Ethernet-Kit - PoE board (B)
layout" class="align-center"></p><p>The PoE board (B) has the following features:</p><blockquote><ul><li>Support for IEEE 802.3at</li><li>Power output: 5 V, 1.4 A</li></ul></blockquote><p>To take advantage of the PoE functionality the RJ45 Port of the Ethernet board (A) should be connected with an Ethernet cable to a switch that supports PoE. When the Ethernet board (A) detects 5 V power output from the PoE board (B), the USB power will be automatically cut off.</p><h2 id="function-switch" tabindex="-1">Function Switch <a class="header-anchor" href="#function-switch" aria-label="Permalink to &quot;Function Switch&quot;">​</a></h2><p>When in On position, this DIP switch is routing listed GPIOs to FT2232H to provide JTAG functionality. When in Off position, the GPIOs may be used for other purposes.</p><p>+--------+----------+ | DIP SW | GPIO Pin | +========+==========+ | &gt; 1 | GPIO13 | +--------+----------+ | &gt; 2 | GPIO12 | +--------+----------+ | &gt; 3 | GPIO15 | +--------+----------+ | &gt; 4 | GPIO14 | +--------+----------+</p><h2 id="rmii-clock-selection" tabindex="-1">RMII Clock Selection <a class="header-anchor" href="#rmii-clock-selection" aria-label="Permalink to &quot;RMII Clock Selection&quot;">​</a></h2><p>The ethernet MAC and PHY under RMII working mode need a common 50 MHz reference clock (i.e. RMII clock) that can be provided either externally, or generated from internal ESP32 APLL (not recommended).</p><h3 id="rmii-clock-sourced-externally-by-phy" tabindex="-1">RMII Clock Sourced Externally by PHY <a class="header-anchor" href="#rmii-clock-sourced-externally-by-phy" aria-label="Permalink to &quot;RMII Clock Sourced Externally by PHY&quot;">​</a></h3><p>By default, the ESP32-Ethernet-Kit is configured to provide RMII clock for the IP101GRI PHY&#39;s 50M_CLKO output. The clock signal is generated by the frequency multiplication of 25 MHz crystal connected to the PHY. For details, please see the figure below.</p><p><img src="`+c+`" alt="RMII Clock from IP101GRI
PHY" class="align-centeralign-center"></p><p>Please note that the PHY is reset on power up by pulling the RESET_N signal down with a resistor. ESP32 should assert RESET_N high with GPIO5 to enable PHY. Only this can ensure the power-up of system. Otherwise ESP32 may enter download mode (when the clock signal of REF_CLK_50M is at a high logic level during the GPIO0 power-up sampling phase).</p><h3 id="rmii-clock-sourced-internally-from-esp32-s-apll" tabindex="-1">RMII Clock Sourced Internally from ESP32&#39;s APLL <a class="header-anchor" href="#rmii-clock-sourced-internally-from-esp32-s-apll" aria-label="Permalink to &quot;RMII Clock Sourced Internally from ESP32\\&#39;s APLL&quot;">​</a></h3><p>Another option is to source the RMII Clock from internal ESP32 APLL, see figure below. The clock signal coming from GPIO0 is first inverted, to account for transmission line delay, and then supplied to the PHY.</p><p><img src="`+d+`" alt="RMII Clock from ESP Internal
APLL" class="align-centeralign-center"></p><p>To implement this option, users need to remove or add some RC components on the board. For details please refer to the <a href="https://dl.espressif.com/dl/schematics/SCH_ESP32-Ethernet-Kit_A_V1.2_20200528.pdf" target="_blank" rel="noreferrer">ESP32-Ethernet-Kit V1.2 Ethernet board (A) schematic</a>, sheet 2, location D2. Please note that if the APLL is already used for other purposes (e.g. I2S peripheral), then you have no choice but use an external RMII clock.</p><h2 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h2><p>UART0 is, by default, the serial console. It connects to the on-board CP2102N bridge and is available on the USB connector.</p><p>It will show up as /dev/ttyUSB[n] where [n] will probably be 0.</p><h2 id="buttons-and-leds" tabindex="-1">Buttons and LEDs <a class="header-anchor" href="#buttons-and-leds" aria-label="Permalink to &quot;Buttons and LEDs&quot;">​</a></h2><h3 id="board-buttons" tabindex="-1">Board Buttons <a class="header-anchor" href="#board-buttons" aria-label="Permalink to &quot;Board Buttons&quot;">​</a></h3><p>There are two buttons labeled Boot and EN. The EN button is not available to software. It pulls the chip enable line that doubles as a reset line.</p><p>The BOOT button is connected to IO0. On reset it is used as a strapping pin to determine whether the chip boots normally or into the serial bootloader. After reset, however, the BOOT button can be used for software input.</p><h3 id="board-leds" tabindex="-1">Board LEDs <a class="header-anchor" href="#board-leds" aria-label="Permalink to &quot;Board LEDs&quot;">​</a></h3><p>There are several on-board LEDs for that indicate the presence of power and USB activity. None of these are available for use by software.</p><h2 id="pin-mapping" tabindex="-1">Pin Mapping <a class="header-anchor" href="#pin-mapping" aria-label="Permalink to &quot;Pin Mapping&quot;">​</a></h2><p>ESP32-WROVER-E IP101GRI UART JTAG GPIO Comments</p><hr><p>S_VP IO36<br> S_VN IO39<br> IO34 IO34<br> IO35 IO35<br> IO32 IO32<br> IO33 IO33<br> IO25 RXD[0]<br> IO26 RXD[1]<br> IO27 CRS_DV<br> IO14 TMS IO14<br> IO12 TDI IO12<br> IO13 TCK IO13<br> IO15 TDO IO15<br> IO2 IO2<br> IO0 REF_CLK See note 1 IO4 IO4<br> IO16 IO16 (NC) See note 2 IO17 IO17 (NC) See note 2 IO5 Reset_N See note 1 IO18 MDIO<br> IO19 TXD[0]<br> IO21 TX_EN<br> RXD0 RXD<br> TXD0 TXD<br> IO22 TXD[1]<br> IO23 MDC</p><p>Note</p><p>1. To prevent the power-on state of the GPIO0 from being affected by the clock output on the PHY side, the RESET_N signal to PHY defaults to low, turning the clock output off. After power-on you can control RESET_N with GPIO5 to turn the clock output on. See also <a href="#rmii-clock-sourced-externally-by-phy">RMII Clock Sourced Externally by PHY</a>. For PHYs that cannot turn off the clock output through RESET_N, it is recommended to use a crystal module that can be disabled/enabled externally. Similarly like when using RESET_N, the oscillator module should be disabled by default and turned on by ESP32 after power-up. For a reference design please see <a href="https://dl.espressif.com/dl/schematics/SCH_ESP32-Ethernet-Kit_A_V1.2_20200528.pdf" target="_blank" rel="noreferrer">ESP32-Ethernet-Kit V1.2 Ethernet board (A) schematic</a>.</p><ol start="2"><li>The ESP32 pins GPIO16 and GPIO17 are not broken out to the ESP32-WROVER-E module and therefore not available for use.</li></ol><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><p>All of the configurations presented below can be tested by running the following commands:</p><pre><code> ./tools/configure.sh esp32-ethernet-kit:&lt;config_name&gt;
 make flash ESPTOOL_PORT=/dev/ttyUSB0 -j
</code></pre><p>Where &lt;config_name&gt; is the name of board configuration you want to use, i.e.: nsh, buttons, wifi... Then use a serial console terminal like <code>picocom</code> configured to 115200 8N1.</p><h3 id="autopm" tabindex="-1">autopm <a class="header-anchor" href="#autopm" aria-label="Permalink to &quot;autopm&quot;">​</a></h3><p>This configuration makes the device automatically enter the low power consumption mode when in the idle state, powering off the cpu and other peripherals.</p><p>In minimum power save mode, the station wakes up every DTIM to receive a beacon. The broadcast data will not be lost because it is transmitted after DTIM. However, it can not save much more power if DTIM is short as the DTIM is determined by the access point.</p><h3 id="buttons" tabindex="-1">buttons <a class="header-anchor" href="#buttons" aria-label="Permalink to &quot;buttons&quot;">​</a></h3><p>This configuration shows the use of the buttons subsystem. It can be used by executing the <code>buttons</code> application and pressing on any of the available board buttons:</p><pre><code>nsh&gt; buttons
buttons_main: Starting the button_daemon
buttons_main: button_daemon started
button_daemon: Running
button_daemon: Opening /dev/buttons
button_daemon: Supported BUTTONs 0x01
nsh&gt; Sample = 1
Sample = 0
</code></pre><h3 id="ethernet" tabindex="-1">ethernet <a class="header-anchor" href="#ethernet" aria-label="Permalink to &quot;ethernet&quot;">​</a></h3><p>This configuration is similar to <code>wifi</code> but uses the Ethernet interface instead of the WiFi one. It also automatically configures the IP and DNS addresses of the device. It currently uses the following static configuration:</p><blockquote><ul><li>IP: 192.168.15.100 (0xc0a80f64)</li><li>Gateway: 192.168.15.1 (0xc0a80f01)</li><li>Netmask: 255.255.255.0 (0xffffff00)</li><li>DNS: 8.8.8.8 (0x08080808)</li></ul></blockquote><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>Basic NuttShell configuration (console enabled in UART0, exposed via USB connection by means of CP2102 converter, at 115200 bps).</p><h3 id="oneshot" tabindex="-1">oneshot <a class="header-anchor" href="#oneshot" aria-label="Permalink to &quot;oneshot&quot;">​</a></h3><p>This config demonstrate the use of oneshot timers present on the ESP32. To test it, just run the <code>oneshot</code> example:</p><pre><code>nsh&gt; oneshot
Opening /dev/oneshot
Maximum delay is 4294967295999999
Starting oneshot timer with delay 2000000 microseconds
Waiting...
Finished
</code></pre><h3 id="rtc" tabindex="-1">rtc <a class="header-anchor" href="#rtc" aria-label="Permalink to &quot;rtc&quot;">​</a></h3><p>This configuration demonstrates the use of the RTC driver through alarms. You can set an alarm, check its progress and receive a notification after it expires:</p><pre><code>nsh&gt; alarm 10
alarm_daemon started
alarm_daemon: Running
Opening /dev/rtc0
Alarm 0 set in 10 seconds
nsh&gt; alarm -r
Opening /dev/rtc0
Alarm 0 is active with 10 seconds to expiration
nsh&gt; alarm_daemon: alarm 0 received
</code></pre><h3 id="wifi" tabindex="-1">wifi <a class="header-anchor" href="#wifi" aria-label="Permalink to &quot;wifi&quot;">​</a></h3><p>Enables Wi-Fi support. You can define your credentials this way:</p><pre><code> make menuconfig
-&gt; Application Configuration
    -&gt; Network Utilities
        -&gt; Network initialization (NETUTILS_NETINIT [=y])
            -&gt; WAPI Configuration
</code></pre><p>Or if you don&#39;t want to keep it saved in the firmware you can do it at runtime:</p><pre><code>nsh&gt; wapi psk wlan0 mypasswd 3
nsh&gt; wapi essid wlan0 myssid 1
nsh&gt; renew wlan0
</code></pre><p>Tip</p><p>Please refer to <code>ESP32 Wi-Fi Station Mode &lt;esp32_wi-fi_sta&gt;</code>{.interpreted-text role=&quot;ref&quot;} for more information.</p><h2 id="readme-txt" tabindex="-1">README.txt <a class="header-anchor" href="#readme-txt" aria-label="Permalink to &quot;README.txt&quot;">​</a></h2>`,79)]))}const k=t(p,[["render",u]]);export{I as __pageData,k as default};
