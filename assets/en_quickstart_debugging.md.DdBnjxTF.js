import{_ as t,c as o,al as a,j as e,a as n,o as p}from"./chunks/framework.NFAqBSgQ.js";const i="/assets/menuconfig-debug.GOHTUl5l.png",m=JSON.parse('{"title":"Debugging","description":"","frontmatter":{},"headers":[],"relativePath":"en/quickstart/debugging.md","filePath":"en/quickstart/debugging.md"}'),l={name:"en/quickstart/debugging.md"};function c(d,s,r,u,g,h){return p(),o("div",null,s[0]||(s[0]=[a('<h1 id="debugging" tabindex="-1">Debugging <a class="header-anchor" href="#debugging" aria-label="Permalink to &quot;Debugging&quot;">​</a></h1><p>Finding and fixing bugs is an important part of the hardware and software development process. Sometimes you also need to use debugging techniques to understand how the system works. Two tools that are helpful are debug logging and debugging using the GNU Debugger (gdb).</p><h2 id="debug-logging" tabindex="-1">Debug Logging <a class="header-anchor" href="#debug-logging" aria-label="Permalink to &quot;Debug Logging&quot;">​</a></h2><p>NuttX has a powerful system logging facility (syslog) with <code>info</code>, <code>warn</code>, and <code>error</code> levels. You can enable debugging for your build for the subsystem or feature by using the <code>menuconfig</code> system.</p>',4),e("p",null,[n("The debug options are available under "),e("code",{class:"interpreted-text",role:"menuselection"},"Build Setup --> Debug Options"),n(". You will most likely have to enable the following options:")],-1),e("ul",null,[e("li",null,[e("code",{class:"interpreted-text",role:"menuselection"},"Enable Debug Features"),n(" --- selecting this will turn on subsystem-level debugging options, they will become visible on the page below. You can then select the ones you want.")]),e("li",null,[e("code",{class:"interpreted-text",role:"menuselection"},"Enable Error Output"),n(" --- this will only log errors.")]),e("li",null,[e("code",{class:"interpreted-text",role:"menuselection"},"Enable Warnings Output"),n(" --- this will log warnings and errors.")]),e("li",null,[e("code",null,"Enable Informational Debug Output"),n('{.interpreted-text role="menuselection"} --- this will produce informational output, warnings, and errors.')])],-1),e("p",null,[n("You can then select from the subsystems that are available, Network, Scheduler, USB, etc. Note that you will need to separately enable the subsystem elsewhere in the "),e("code",null,"menuconfig"),n(" system. To see the "),e("code",null,"CONFIG"),n(" define that is set, use the arrow keys to highlight the subsystem (for instance, "),e("code",null,"Network Debug Features"),n('{.interpreted-text role="menuselection"}) and type '),e("code",{class:"interpreted-text",role:"kbd"},"?"),n(". This will show you that the C macro that is set is called "),e("code",null,"CONFIG_DEBUG_NET"),n(". "),e("code",null,"debug.h"),n(" defines the "),e("code",null,"netinfo()"),n(" logging function that will log output if this macro is set. You can search the source code for "),e("code",null,"netinfo"),n(" to see how it is used.")],-1),e("p",null,[e("img",{src:i,alt:"Screenshot of menuconfig system main screen"}),n('{.align-center width="800px"}')],-1),e("p",null,[n("Note that enabling all these will produce an incredible amount of logging output. Enable the level you want and the area you're interested in, and leave the rest disabled, save the config, and then recompile. You can see the full list of debug feature logging functions in the file "),e("a",{href:"https://github.com/apache/nuttx/blob/master/include/debug.h",target:"_blank",rel:"noreferrer"},"debug.h"),n(".")],-1),e("p",null,[n("Syslog timestamps can be enabled in the configuration in "),e("code",{class:"interpreted-text",role:"menuselection"},"Device Drivers --> System Logging --> Prepend timestamp to syslog message"),n(" ("),e("code",null,"CONFIG_SYSLOG_TIMESTAMP"),n(").")],-1),a(`<p>You may need to do a little bit of experimenting to find the combination of logging settings that work for the problem you&#39;re trying to solve. See the file <a href="https://github.com/apache/nuttx/blob/master/include/debug.h" target="_blank" rel="noreferrer">debug.h</a> for available debug settings that are available.</p><p>There are also subsystems that enable USB trace debugging, and you can log to memory too, if you need the logging to be faster than what the console can output.</p><h2 id="debugging-with-openocd-and-gdb" tabindex="-1">Debugging with <code>openocd</code> and <code>gdb</code> <a class="header-anchor" href="#debugging-with-openocd-and-gdb" aria-label="Permalink to &quot;Debugging with \`openocd\` and \`gdb\`&quot;">​</a></h2><p>To debug our Nucleo board using its embedded SWD debug adapter, start <code>openocd</code> with the following command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg</span></span></code></pre></div><p>This will start a <code>gdb</code> server. Then, start <code>gdb</code> with:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> cd nuttx/</span></span>
<span class="line"><span> gdb-multiarch nuttx/nuttx</span></span></code></pre></div><p>Inside <code>gdb</code> console, connect to the <code>gdb</code> server with:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(gdb) target extended-remote :3333</span></span></code></pre></div><p>You can now use standard <code>gdb</code> commands. For example, to reset the board:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(gdb) mon reset</span></span></code></pre></div><p>To halt the board:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(gdb) mon halt</span></span></code></pre></div><p>To set a breakpoint:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(gdb) breakpoint nsh_main</span></span></code></pre></div><p>and to finally start nuttx:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(gdb) continue</span></span>
<span class="line"><span>Continuing.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Breakpoint 1, nsh_main (argc=1, argv=0x200ddfac) at nsh_main.c:208</span></span>
<span class="line"><span>208     sched_getparam(0, &amp;param);</span></span>
<span class="line"><span>(gdb) continue</span></span>
<span class="line"><span>Continuing.</span></span></code></pre></div><p>Tip</p><p>You can abbreviate <code>gdb</code> commands: <code>info b</code> is a shortcut for <code>information breakpoints</code>; <code>c</code> works the same as <code>continue</code>, etc.</p><h3 id="nuttx-aware-debugging" tabindex="-1">NuttX aware debugging <a class="header-anchor" href="#nuttx-aware-debugging" aria-label="Permalink to &quot;NuttX aware debugging&quot;">​</a></h3><p>Since NuttX is actually an RTOS, it is useful to have <code>gdb</code> be aware of the different tasks/threads that are running. There are two ways to do this: via <code>openocd</code> itself or via <code>gdb</code>. Note that in both cases, you need to enable debug symbols (<code>CONFIG_DEBUG_SYMBOLS</code>).</p><h4 id="with-openocd" tabindex="-1">With openocd <a class="header-anchor" href="#with-openocd" aria-label="Permalink to &quot;With openocd&quot;">​</a></h4><p><code>openocd</code> supports various RTOS directly, including NuttX. It works by reading into internal NuttX symbols which define the active tasks and their properties. As a result, the <code>gdb</code> server will directly be aware of each task as a different [thread]{.title-ref}. The downside of this approach is that it depends on how you build NuttX as there are some options hardcoded into opencd. By default, it assumes:</p><blockquote><ul><li><code>CONFIG_DISABLE_MQUEUE=y</code></li><li><code>CONFIG_LEGACY_PAGING=n</code></li></ul></blockquote><p>If you need these options to be set differently, you will have to edit <code>./src/rtos/nuttx_header.h</code> from <code>openocd</code>, change the corresponding settings and then rebuild it.</p><p>Finally, to enable NuttX integration, you need to supply an additional <code>openocd</code> argument:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg -c &#39;_TARGETNAME configure -rtos nuttx&#39;</span></span></code></pre></div><p>Since <code>openocd</code> also needs to know the memory layout of certain datastructures, you need to have <code>gdb</code> run the following commands once the <code>nuttx</code> binary is loaded:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>eval &quot;monitor nuttx.pid_offset %d&quot;, &amp;((struct tcb_s *)(0))-&gt;pid</span></span>
<span class="line"><span>eval &quot;monitor nuttx.xcpreg_offset %d&quot;, &amp;((struct tcb_s *)(0))-&gt;xcp.regs</span></span>
<span class="line"><span>eval &quot;monitor nuttx.state_offset %d&quot;, &amp;((struct tcb_s *)(0))-&gt;task_state</span></span>
<span class="line"><span>eval &quot;monitor nuttx.name_offset %d&quot;, &amp;((struct tcb_s *)(0))-&gt;name</span></span>
<span class="line"><span>eval &quot;monitor nuttx.name_size %d&quot;, sizeof(((struct tcb_s *)(0))-&gt;name)</span></span></code></pre></div><p>One way to do this is to define a gdb [hook]{.title-ref} function that will be called when running <code>file</code> command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>define hookpost-file</span></span>
<span class="line"><span>  eval &quot;monitor nuttx.pid_offset %d&quot;, &amp;((struct tcb_s *)(0))-&gt;pid</span></span>
<span class="line"><span>  eval &quot;monitor nuttx.xcpreg_offset %d&quot;, &amp;((struct tcb_s *)(0))-&gt;xcp.regs</span></span>
<span class="line"><span>  eval &quot;monitor nuttx.state_offset %d&quot;, &amp;((struct tcb_s *)(0))-&gt;task_state</span></span>
<span class="line"><span>  eval &quot;monitor nuttx.name_offset %d&quot;, &amp;((struct tcb_s *)(0))-&gt;name</span></span>
<span class="line"><span>  eval &quot;monitor nuttx.name_size %d&quot;, sizeof(((struct tcb_s *)(0))-&gt;name)</span></span>
<span class="line"><span>end</span></span></code></pre></div><p>You will see that <code>openocd</code> has received the memory offsets in its output:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Open On-Chip Debugger 0.10.0+dev-01514-ga8edbd020-dirty (2020-11-20-14:23)</span></span>
<span class="line"><span>Licensed under GNU GPL v2</span></span>
<span class="line"><span>For bug reports, read</span></span>
<span class="line"><span>    http://openocd.org/doc/doxygen/bugs.html</span></span>
<span class="line"><span>Info : auto-selecting first available session transport &quot;swd&quot;. To override use &#39;transport select &lt;transport&gt;&#39;.</span></span>
<span class="line"><span>Info : target type name = cortex_m</span></span>
<span class="line"><span>Info : Listening on port 6666 for tcl connections</span></span>
<span class="line"><span>Info : Listening on port 4444 for telnet connections</span></span>
<span class="line"><span>15:41:23: Debugging starts</span></span>
<span class="line"><span>Info : CMSIS-DAP: SWD  Supported</span></span>
<span class="line"><span>Info : CMSIS-DAP: FW Version = 1.10</span></span>
<span class="line"><span>Info : CMSIS-DAP: Interface Initialised (SWD)</span></span>
<span class="line"><span>Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1</span></span>
<span class="line"><span>Info : CMSIS-DAP: Interface ready</span></span>
<span class="line"><span>Info : clock speed 1000 kHz</span></span>
<span class="line"><span>Info : SWD DPIDR 0x2ba01477</span></span>
<span class="line"><span>Info : nrf52.cpu: hardware has 6 breakpoints, 4 watchpoints</span></span>
<span class="line"><span>Info : starting gdb server for nrf52.cpu on 3333</span></span>
<span class="line"><span>Info : Listening on port 3333 for gdb connections</span></span>
<span class="line"><span>Info : accepting &#39;gdb&#39; connection on tcp/3333</span></span>
<span class="line"><span>Error: No symbols for NuttX</span></span>
<span class="line"><span>Info : nRF52832-QFAA(build code: B0) 512kB Flash, 64kB RAM</span></span>
<span class="line"><span>undefined debug reason 8 - target needs reset</span></span>
<span class="line"><span>Warn : Prefer GDB command &quot;target extended-remote 3333&quot; instead of &quot;target remote 3333&quot;</span></span>
<span class="line"><span>Info : pid_offset: 12</span></span>
<span class="line"><span>Info : xcpreg_offset: 132</span></span>
<span class="line"><span>Info : state_offset: 26</span></span>
<span class="line"><span>Info : name_offset: 208</span></span>
<span class="line"><span>Info : name_size: 32</span></span>
<span class="line"><span>target halted due to debug-request, current mode: Thread</span></span>
<span class="line"><span>xPSR: 0x01000000 pc: 0x000000dc msp: 0x20000cf0</span></span>
<span class="line"><span>target halted due to debug-request, current mode: Thread xPSR: 0x01000000 pc: 0x000000dc msp: 0x20000cf0</span></span></code></pre></div><p>Note</p><p>You will probably see the <code>Error: No symbols for NuttX</code> error appear once at startup. This is OK unless you see it every time you step the debugger. In this case, it would mean you did not enable debug symbols.</p><p>Now, You can now inspect threads:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(gdb) info threads</span></span>
<span class="line"><span>  Id   Target Id         Frame</span></span>
<span class="line"><span>* 1    Remote target     nx_start_application () at init/nx_bringup.c:261</span></span>
<span class="line"><span>(gdb) info registers</span></span>
<span class="line"><span>r0             0x0                 0</span></span>
<span class="line"><span>r1             0x2f                47</span></span>
<span class="line"><span>r2             0x0                 0</span></span>
<span class="line"><span>r3             0x0                 0</span></span>
<span class="line"><span>r4             0x0                 0</span></span>
<span class="line"><span>r5             0x0                 0</span></span>
<span class="line"><span>r6             0x0                 0</span></span>
<span class="line"><span>r7             0x20000ca0          536874144</span></span>
<span class="line"><span>r8             0x0                 0</span></span>
<span class="line"><span>r9             0x0                 0</span></span>
<span class="line"><span>r10            0x0                 0</span></span>
<span class="line"><span>r11            0x0                 0</span></span>
<span class="line"><span>r12            0x9                 9</span></span>
<span class="line"><span>sp             0x20000c98          0x20000c98</span></span>
<span class="line"><span>lr             0x19c5              6597</span></span>
<span class="line"><span>pc             0x1996              0x1996 &lt;nx_start_application+10&gt;</span></span>
<span class="line"><span>xPSR           0x41000000          1090519040</span></span>
<span class="line"><span>fpscr          0x0                 0</span></span>
<span class="line"><span>msp            0x20000c98          0x20000c98</span></span>
<span class="line"><span>psp            0x0                 0x0 &lt;_vectors&gt;</span></span>
<span class="line"><span>primask        0x0                 0</span></span>
<span class="line"><span>basepri        0xe0                -32</span></span>
<span class="line"><span>faultmask      0x0                 0</span></span>
<span class="line"><span>control        0x0                 0</span></span></code></pre></div><h4 id="with-gdb" tabindex="-1">With GDB <a class="header-anchor" href="#with-gdb" aria-label="Permalink to &quot;With GDB&quot;">​</a></h4><p>You can also do NuttX aware debugging using <code>gdb</code> scripting support. The benefit is that it works also for the sim build where <code>openocd</code> is not applicable. For this to work, you will need to enable PROC filesystem support which will expose required task information (<code>CONFIG_FS_PROCFS=y</code>).</p><p>To use this approach, you can load the <code>nuttx/tools/pynuttx/gdbinit.py</code> file. An easy way to do this is to add an extra command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> gdb nuttx -ix=tools/pynuttx/gdbinit.py</span></span></code></pre></div><p>gdb can need to set the current elf support architecture, for example, the prefix is arm-ebai-none-.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(gdb) info threads</span></span>
<span class="line"><span>Id   Thread                Info                                                                             Frame</span></span>
<span class="line"><span>*0   Thread 0x20000398     (Name: Idle Task, State: Running, Priority: 0, Stack: 1000)                      0x80001ac __start() at chip/stm32_start.c:111</span></span>
<span class="line"><span>1    Thread 0x10000188     (Name: nsh_main, State: Waiting,Semaphore, Priority: 100, Stack: 2000)           0x800aa06 sys_call2() at /home/ajh/work/vela_all/nuttx/include/arch/syscall.h:187</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>(gdb) (gdb) nxgcore -r 0x40200000,0x48000000,0x07</span></span>
<span class="line"><span>Saved corefile nuttx.core</span></span>
<span class="line"><span>Please run gdbserver.py to parse nuttx.core</span></span></code></pre></div><p>The python script has extended many commands like <code>thread &lt;id&gt;</code> , <code>thread apply &lt;all|id list&gt; cmd</code>, <code>nxsetargs</code> etc. You can use <code>help &lt;command&gt;</code> to get help.</p><p>Note that if you need to continue debugging after using the thread command, please use <code>c</code> instead of <code>continue</code>, because thread will force the register to be set, and the [c]{.title-ref} command will restore the register before conitune.</p>`,46)]))}const f=t(l,[["render",c]]);export{m as __pageData,f as default};
