import{_ as t,c as i,al as a,j as r,a as o,o as s}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"Nordic nRF91","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/nrf91/index.md","filePath":"en/platforms/arm/nrf91/index.md"}'),n={name:"en/platforms/arm/nrf91/index.md"};function p(d,e,l,h,c,u){return s(),i("div",null,e[0]||(e[0]=[a('<h1 id="nordic-nrf91" tabindex="-1">Nordic nRF91 <a class="header-anchor" href="#nordic-nrf91" aria-label="Permalink to &quot;Nordic nRF91&quot;">​</a></h1><p>The nRF91 series of chips from Nordic Semiconductor are based around an ARM Cortex-M33 core with integrated LTE-M/NB-IoT modem and GNSS.</p><h2 id="modem-support" tabindex="-1">Modem Support <a class="header-anchor" href="#modem-support" aria-label="Permalink to &quot;Modem Support&quot;">​</a></h2><p>Modem is supported in the nRF91 using Nordic&#39;s <a href="https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrfxlib/nrf_modem/README.html" target="_blank" rel="noreferrer">Modem library</a>.</p><p>Supported modem features:</p><p>Modem feature Support Notes</p><hr><p>AT Yes <code>/dev/modem</code> Socket SIOCLTECMD GNSS AGPS Bootloader Delta DFU Modem Trace Yes Partial Yes No No No No via <code>usrsock</code></p><p>At this point there is no application that would configure and enable the modem automatically at the boot, so it has to be done manually via AT commands on <code>/dev/modem</code>.</p><p>IMPORTANT: modem firmware works only in TZ non-secure environment.</p><h2 id="peripheral-support" tabindex="-1">Peripheral Support <a class="header-anchor" href="#peripheral-support" aria-label="Permalink to &quot;Peripheral Support&quot;">​</a></h2><p>The following list indicates peripherals supported in NuttX:</p><p>+-----------------------+-----------------------+-------------------+ | Peripheral | Support | Notes | +=======================+=======================+===================+ | CRUPTOCELL DPPI EGU | No No No Yes Yes | | | GPIO GPIOTE | | | +-----------------------+-----------------------+-------------------+ | IPC I2S KMU PDM PWM | Yes No No No Yes Yes | &gt; nrfx compatible | | RTC SPIM SPIS SPU | Yes No Yes Yes Yes No | | | TIMER TWIM TWIS UART | Yes No No | | | UARTE WDT | | | +-----------------------+-----------------------+-------------------+</p><h3 id="i2c" tabindex="-1">I2C <a class="header-anchor" href="#i2c" aria-label="Permalink to &quot;I2C&quot;">​</a></h3><p>I2C is supported both in polling and interrupt mode (via EasyDMA).</p><p>Note</p><p>The I2C peripheral does not support sending two transfers without sending a START nor RSTART. For this reason, this is supported via an internal buffer where messages will be first copied to and sent together.</p>',17),r("p",null,[o("The lower-half of I2C bus is initialized by :c"),r("code",{class:"interpreted-text",role:"func"},"nrf91_i2cbus_initialize"),o(".")],-1),a(`<h3 id="spi" tabindex="-1">SPI <a class="header-anchor" href="#spi" aria-label="Permalink to &quot;SPI&quot;">​</a></h3><p>SPI is supported both in polling and interrupt-based (via EasyDMA) mode. The latter supports arbitrarily long transfers using Nordic&#39;s list-mode EasyDMA (intermediate transfers are currently still manually started).</p><p>It is possible to use SPI without either MOSI/MISO pin defined by simply not providing the relevant <code>BOARD_SPI*_MISO/MOSI_PIN</code> definition.</p><p>This implementation support power management hooks, which will disable SPI peripheral when entering either SLEEP or STANDBY modes and reconfigure it when going back to NORMAL mode.</p><h3 id="uart" tabindex="-1">UART <a class="header-anchor" href="#uart" aria-label="Permalink to &quot;UART&quot;">​</a></h3><p>UART is implemented using polling. UARTE EasyDMA feature is not yet supported. This may introduce a large number of interrupts which may be undesirable.</p><h3 id="pwm" tabindex="-1">PWM <a class="header-anchor" href="#pwm" aria-label="Permalink to &quot;PWM&quot;">​</a></h3><p>PWM is supported via standard driver. This means that more advanced features such as complex sequences or waveform modes are not yet supported.</p><h3 id="timer" tabindex="-1">TIMER <a class="header-anchor" href="#timer" aria-label="Permalink to &quot;TIMER&quot;">​</a></h3><p>The TIMER peripheral is exposed as standard timer.</p><h3 id="rtc" tabindex="-1">RTC <a class="header-anchor" href="#rtc" aria-label="Permalink to &quot;RTC&quot;">​</a></h3><p>The RTC peripheral is exposed as a standard timer, since it is really a low-power timer, without any date handling capabilities.</p><h2 id="tool-issues" tabindex="-1">Tool Issues <a class="header-anchor" href="#tool-issues" aria-label="Permalink to &quot;Tool Issues&quot;">​</a></h2><h3 id="openocd" tabindex="-1">OpenOCD <a class="header-anchor" href="#openocd" aria-label="Permalink to &quot;OpenOCD&quot;">​</a></h3><p>There is no official support for Nordic Cortex M33 chips (nRF9160 or nRF5340).</p><h3 id="segger-j-link" tabindex="-1">Segger J-Link <a class="header-anchor" href="#segger-j-link" aria-label="Permalink to &quot;Segger J-Link&quot;">​</a></h3><p>To start the GDB servers for the application core, use these commands:</p><pre><code>JLinkGDBServer -device nRF9160 -if SWD -speed 4000 -port 2331
</code></pre><p>Then you can connect GDB to targets:</p><pre><code>(gdb) target remote localhost:2331
</code></pre><h2 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h2><blockquote><p>boards/<em>/</em></p></blockquote>`,22)]))}const T=t(n,[["render",p]]);export{f as __pageData,T as default};
