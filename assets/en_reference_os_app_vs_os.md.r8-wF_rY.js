import{_ as t,c as n,al as a,o}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Application OS vs. Internal OS Interfaces","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/os/app_vs_os.md","filePath":"en/reference/os/app_vs_os.md"}'),i={name:"en/reference/os/app_vs_os.md"};function r(c,e,l,s,d,p){return o(),n("div",null,e[0]||(e[0]=[a('<h1 id="application-os-vs-internal-os-interfaces" tabindex="-1">Application OS vs. Internal OS Interfaces <a class="header-anchor" href="#application-os-vs-internal-os-interfaces" aria-label="Permalink to &quot;Application OS vs. Internal OS Interfaces&quot;">â€‹</a></h1><p>NuttX provides a standard, portable OS interface for use by applications. This standard interface is controlled by the specifications proved at <a href="http://opengroup.org" target="_blank" rel="noreferrer">OpenGroup.org</a>. These application interfaces, in general, should not be used directly by logic executing within the OS. The reason for this is that there are certain properties of the standard application interfaces that make them unsuitable for use within the OS These properties include:</p><ol><li><p><strong>Use of the per-thread</strong> <code>errno</code> <strong>variable</strong>: Handling of return values, particularly, in the case of returned error indications. Most legacy POSIX OS interface return information via a <em>per-thread</em><code>errno</code>. There must be no alteration of the <code>errno</code> value that must be stable from the point of view of the application. So, as a general rule, internal OS logic must never modify the <code>errno</code> and particularly not by the inappropriate use of application OS interfaces within OS itself.</p><p>Within the OS, functions do not return error information via the <code>errno</code> variable. Instead, the majority of internal OS function return error information as an integer value: Returned values greater than or equal to zero are success values; returned values less than zero indicate failures. Failures are reported by returning a negated <code>errno</code> value from <code>include/errno.h</code>,</p></li><li><p><strong>Cancellation Points</strong>: Many of the application OS interfaces are <em>cancellation points</em>, i.e., when the task is operating in <em>deferred cancellation</em> state, it cannot be deleted or cancelled until it calls an application OS interface that is a cancellation point.</p><p>The POSIX specification is very specific about this, specific both in identifying which application OS interfaces are cancellation points and specific in the fact that it is prohibited for any OS operation other than those listed in the specification to generate cancellation points. If internal OS logic were to reuse application OS interfaces directly then it could very easily violate this POSIX requirement by incorrectly generating cancellation points on inappropriate OS operations and could result in very difficult to analyze application failures.</p></li><li><p><strong>Use of per-task Resources</strong>: Many resources are only valid in the task group context in which a thread operates. Above we mentioned one: <code>errno</code> is only valid for the thread that is currently executing. So, for example, the <code>errno</code> at the time of a call is a completely different variable than, say, the <code>errno</code> while running in a work queue task.</p><p>File descriptors are an even better example: An open file on file descriptor 5 on task A is <em>not</em> the same open file as might be used on file descriptor 5 on task B.</p><p>As a result, internal OS logic may not use application OS interfaces that use file descriptors or any other <em>per-task</em> resource.</p></li></ol><p>Within NuttX, this is handled by supporting equivalent internal OS interfaces that do not break the above rules. These internal interfaces are intended for use <em>only</em> within the OS and should not be used by application logic. Some examples include:</p><ul><li><code>nxsem_wait()</code>: functionally equivalent to the standard application interface <code>sem_wait()</code>. However, <code>nxsem_wait()</code> will not modify the errno value and will not cause a cancellation point. (see <code>include/nuttx/semaphore.h</code> for other internal OS interfaces for semaphores).</li><li><code>nxsig_waitinfo()</code>: functionally equivalent to the standard application interface <code>sigwaitinfo()</code>. However, <code>nxsig_waitinfo()</code> will not modify the errno value and will not cause a cancellation point (see <code>include/nuttx/signal.h</code> for other internal OS interfaces for signals).</li><li><code>nxmq_send()</code>: functionally equivalent to the standard application interface <code>mq_send()</code>. However, <code>nxmq_send()</code> will not modify the errno value and will not cause a cancellation point (see <code>include/nuttx/mqueue.h</code> for other internal OS interfaces for POSIX message queues).</li><li><code>file_read()</code>: functionally equivalent to the standard application interface <code>read()</code>. However, <code>file_read()</code> will not modify the errno value, will not cause a cancellation point, and uses a special internal data structure in place of the file descriptor (see <code>include/nuttx/fs/fs.h</code> for other internal OS interfaces for VFS functions).</li><li><code>psock_recvfrom()</code>: functionally equivalent to the standard application interface <code>recvfrom()</code>. However, <code>psock_recvfrom()</code> will not modify the errno value, will not cause a cancellation point, and uses a special internal data structure in place of the socket descriptor (see <code>include/nuttx/net/net.h</code> for other internal OS interfaces for sockets).</li></ul>',5)]))}const h=t(i,[["render",r]]);export{u as __pageData,h as default};
