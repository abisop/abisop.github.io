import{_ as e,c as s,al as n,o as t}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Avia Semiconductor HX711","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/character/analog/adc/hx711/index.md","filePath":"en/components/drivers/character/analog/adc/hx711/index.md"}'),i={name:"en/components/drivers/character/analog/adc/hx711/index.md"};function p(l,a,o,r,c,d){return t(),s("div",null,a[0]||(a[0]=[n(`<h1 id="avia-semiconductor-hx711" tabindex="-1">Avia Semiconductor HX711 <a class="header-anchor" href="#avia-semiconductor-hx711" aria-label="Permalink to &quot;Avia Semiconductor HX711&quot;">​</a></h1><p>Driver contributed by Michał Łyszczek.</p><p>HX711 is a 24bit ADC (Analog Digital Converter) designed for weight scales. This chip can be very slow. With internal oscillator and RATE pin pulled down, it outputs only 10 samples per second. To not hog down CPU, driver uses interrupt to detect when chip is ready. This will make read(2) blocking, but system can do whatever it needs before chip is ready. Because of that driver does not fully follow ADC API, but rather standard character device (read only).</p><p>Values from tensometer can be easily read from shell with <code>cat</code> command</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cat /dev/hxx711_0</span></span></code></pre></div><p>Although it may be better to dump values with example <code>hx711</code> program, since <code>cat</code> will just read until the end of time, and if ctrl+c is not working, it will steal shell forever.</p><h2 id="reading" tabindex="-1">reading <a class="header-anchor" href="#reading" aria-label="Permalink to &quot;reading&quot;">​</a></h2><p>Reading is done by calling standard, posix, read(2) function. Only one value can be returned with single call to read(2). But an averaging function can be enabled, so that driver will read N samples, average them, and then will return single averaged value.</p><p>This function accepts two types of buffer.</p><p>If buffer is of size <code>sizeof(int32_t)</code> a int32 value will be stored in a buffer. If buffer size of bigger than <code>sizeof(int32_t)</code> function will store string representation of values in passed buffer.</p><p>Simple code to read and print value may look like this</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int fd;</span></span>
<span class="line"><span>fd = open(&quot;/dev/hx711_0&quot;, O_RDONLY);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>for (; ; )</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    int32_t value;</span></span>
<span class="line"><span>    value = read(fd, &amp;value, sizeof(value));</span></span>
<span class="line"><span>    printf(&quot;Read: %&quot;PRIi32&quot;\\n&quot;, value);</span></span>
<span class="line"><span>  }</span></span></code></pre></div><h2 id="ioctl" tabindex="-1">ioctl <a class="header-anchor" href="#ioctl" aria-label="Permalink to &quot;ioctl&quot;">​</a></h2><p>Since this chip (and driver) is designed for weight scale, kernel driver can provide some processing to make life easier for userspace code. These functions are implemented via ioctl(2) commands. In practice, non of these can be used, but if you just open driver and read it, you will get raw values from hx711 chip, which you will have to process yourself. If your needs are more standard, it&#39;s better to use kernel processing.</p><h3 id="hx711-set-average" tabindex="-1">HX711_SET_AVERAGE <a class="header-anchor" href="#hx711-set-average" aria-label="Permalink to &quot;HX711\\_SET\\_AVERAGE&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>unsigned average = 5;</span></span>
<span class="line"><span>ioctl(fd, HX711_SET_AVERAGE, average);</span></span></code></pre></div><p>Driver will read this number of samples from hx711 and will return average value of them all. To avoid corrupted data due to integer overflow, max average value that can be set is 225. If you need to average more values you will need to write your own code for that.</p><h3 id="hx711-set-channel" tabindex="-1">HX711_SET_CHANNEL <a class="header-anchor" href="#hx711-set-channel" aria-label="Permalink to &quot;HX711\\_SET\\_CHANNEL&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>char channel = &#39;a&#39;;</span></span>
<span class="line"><span>ioctl(fd, HX711_SET_CHANNEL, channel);</span></span></code></pre></div><p>HX711 has 2 channels, A and B, which can be swapped as necessary. Driver automatically performs dummy read, so that next call to read(2) will return value from new channel. When you switch to channel &#39;B&#39;, driver automatically changes gain to 32 (the only possible value). Going back to &#39;A&#39; will set gain to 128.</p><h3 id="hx711-set-gain" tabindex="-1">HX711_SET_GAIN <a class="header-anchor" href="#hx711-set-gain" aria-label="Permalink to &quot;HX711\\_SET\\_GAIN&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>unsigned char gain = 128;</span></span>
<span class="line"><span>ioctl(fd, HX711_SET_GAIN, gain);</span></span></code></pre></div><p>Set gain. Channel &#39;A&#39; supports gain &quot;128&quot; and &quot;64&quot;. Channel &#39;B&#39; has only one gain option - 32.</p><h3 id="hx711-set-val-per-unit" tabindex="-1">HX711_SET_VAL_PER_UNIT <a class="header-anchor" href="#hx711-set-val-per-unit" aria-label="Permalink to &quot;HX711\\_SET\\_VAL\\_PER\\_UNIT&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int val_per_unit = 813;</span></span>
<span class="line"><span>ioctl(fd, HX711_SET_VAL_PER_UNIT, val_per_unit);</span></span></code></pre></div><p>Driver can perform calculations so that you can read physical values like grams, ounce or pounds, or your own artificial unit. You just need to specify what value from tensometer corresponds to one unit.</p><p>Say you have tensometer that has max value of 1&#39;000&#39;000. Value 100&#39;000 means 1kg and sensor is fully linear. If you want to get readings in kg, you would set <code>val_per_unit</code> to 100&#39;000. If you wanted output in grams, it would be value of 100. To have tenths of grams precision, you would set it to 10. Driver does not care about unit, you just pick one and stick to it.</p><p>Note that driver can only return integers, so if you set it to return unit of kg, you will only get 1, 2, 3kg... and you won&#39;t be able to sense 0.5kg or 1.5kg. For that you would have to set value to 10&#39;000, and driver would return you values of 15 (for 1.5kg) or 0.5 (for 0.5kg).</p><h3 id="hx711-tare" tabindex="-1">HX711_TARE <a class="header-anchor" href="#hx711-tare" aria-label="Permalink to &quot;HX711\\_TARE&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>float precision = 0.1;</span></span>
<span class="line"><span>ioctl(fd, HX711_TARE, &amp;precision);</span></span></code></pre></div><p>Every scale needs a tare function. Driver polls hx711 for some time, and if it detects that scale is stable state, ioctl(2) will return with success, and next read(2) call will take new tare value into consideration when returning readings. Scale is assumed to be stable when several consecutive readings are (min-max values) are within specified precition.</p><p>If <code>HX711_SET_VAL_PER_UNIT</code> was set prior to this, you can pass value in your unit. If you configured driver to work with grams, you can set this value to 0.1 (gram) or 5 (gram).</p><p>If driver cannot get stable reading within some time, it will return with ETIME errno set.</p><p>Important note, make sure you have set correct sign before taring, or else you will double your tare value instead of zeroing it!</p><h3 id="hx711-sign" tabindex="-1">HX711_SIGN <a class="header-anchor" href="#hx711-sign" aria-label="Permalink to &quot;HX711\\_SIGN&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int sign = -1;</span></span>
<span class="line"><span>ioctl(fd, HX711_SIGN, &amp;sign);</span></span></code></pre></div><p>If values from drivers go lower when mass on scale goes higher you can swap the sign. This may be necessary when tensometer was installed upside down.</p><h2 id="hx711-example-program" tabindex="-1">hx711 example program <a class="header-anchor" href="#hx711-example-program" aria-label="Permalink to &quot;hx711 example program&quot;">​</a></h2><p>There is also companion program in Application Configuration ---&gt; Examples called <code>HX711 driver example</code>. Main purpose of this is to show how to use the driver, but it also is a very good tool for quickly debugging chip from the shell, as it can dump readings and set all options.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>-h       print this help message</span></span>
<span class="line"><span>-d&lt;path&gt; path to hx711 device, default: /dev/hx711_0</span></span>
<span class="line"><span>-t&lt;prec&gt; tares the scale with specified precision, might take few seconds to complete.</span></span>
<span class="line"><span>         If you set value per unit, precision is in units, otherwise it&#39;s raw values.</span></span>
<span class="line"><span>         If units are used, float can be passed like 0.1</span></span>
<span class="line"><span>-v&lt;val&gt;  value read that corresponds to one unit. This value has to be</span></span>
<span class="line"><span>         calibrated first before it&#39;s known</span></span>
<span class="line"><span>-s       reverse sign, if values decreses when mass increases, pass this</span></span>
<span class="line"><span>-D       dumps current device settings (like, average, channel, gain etc.)</span></span>
<span class="line"><span>-a&lt;avg&gt;  set how many samples should be averaged before returning value,</span></span>
<span class="line"><span>         values [1..225] are valid</span></span>
<span class="line"><span>-c&lt;chan&gt; set channel to read (either &#39;a&#39; or &#39;b&#39; is valid)</span></span>
<span class="line"><span>-g&lt;gain&gt; set adc gain, for channel &#39;a&#39; 64 and 128 are valid,</span></span>
<span class="line"><span>         for channel &#39;b&#39;, only 64 is valid</span></span>
<span class="line"><span>-r&lt;num&gt;  read this number of samples before exiting, samples will be printed</span></span>
<span class="line"><span>         on stdout as string, one sample per line</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Set values are persistent, as in once set they are stored in driver and</span></span>
<span class="line"><span>will be applied during execution of this program.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>If you specify only &lt;-a|-c|-g|-v|-t&gt; without -r, program will set new parameters</span></span>
<span class="line"><span>and exit. You can later call program again only with -r option to read</span></span>
<span class="line"><span>samples with previously set values. You can also pass all of them in one call</span></span>
<span class="line"><span></span></span>
<span class="line"><span>To test if you require CONFIG_ADC_HX711_ADD_DELAY option set, run as:</span></span>
<span class="line"><span>     hx711 -a225 -r128</span></span>
<span class="line"><span>This will load hx711 chip long enough to show any possible errors due to</span></span>
<span class="line"><span>lack of added delay.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Program executes in order: set options, tare, dump, run, so if you specify all</span></span>
<span class="line"><span>options, new settings will be applied, then new settings will be printed</span></span>
<span class="line"><span>and at the end program will tare the scale and print samples</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Examples:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Set hx711 settings for first chip and exit:</span></span>
<span class="line"><span>     hx711 -a32 -ca -g64</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Dump chip settings from different chip</span></span>
<span class="line"><span>     hx711 -d/dev/hx711_2 -D</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Read 10 samples with previously set hx711 settings</span></span>
<span class="line"><span>     hx711 -r10</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Change channel and read 32 samples (average setting won&#39;t change):</span></span>
<span class="line"><span>     hx711 -cb -r32</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Set value per unit, to get output in grams, and then tare with 10g precision</span></span>
<span class="line"><span>     hx711 -v 813 -t 10</span></span></code></pre></div>`,40)]))}const g=e(i,[["render",p]]);export{u as __pageData,g as default};
