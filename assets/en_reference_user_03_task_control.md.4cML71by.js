import{_ as n,c as s,j as e,a as t,al as l,o as i}from"./chunks/framework.NFAqBSgQ.js";const k=JSON.parse('{"title":"Task Control Interfaces","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/user/03_task_control.md","filePath":"en/reference/user/03_task_control.md"}'),o={name:"en/reference/user/03_task_control.md"};function r(c,a,d,u,h,p){return i(),s("div",null,a[0]||(a[0]=[e("h1",{id:"task-control-interfaces",tabindex:"-1"},[t("Task Control Interfaces "),e("a",{class:"header-anchor",href:"#task-control-interfaces","aria-label":'Permalink to "Task Control Interfaces"'},"​")],-1),e("p",null,"Warning",-1),e("p",null,"This section name is duplicate with the first, how should it be named?",-1),e("ul",null,[e("li",null,[e("p",null,[e("strong",null,"Scheduler locking interfaces"),t(". These "),e("em",null,"non-standard"),t(" interfaces are used to enable and disable pre-emption and to test is pre-emption is currently enabled.")]),e("blockquote",null,[e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sched_lock")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sched_unlock")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"sched_lockcount")])])])]),e("li",null,[e("p",null,[e("strong",null,"Task synchronization interfaces"),t(" are used to wait for termination of child tasks.")]),e("blockquote",null,[e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"waitpid")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"waitid")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"wait")])])])]),e("li",null,[e("p",null,[e("strong",null,"Task Exit Hooks"),t(" may be used to register callback functions that are executed when a "),e("em",null,"task group"),t(" terminates. A task group is the functional analog of a process: It is a group that consists of the main task thread and of all of the pthreads created by the main task thread or any of the other pthreads within the task group. Members of a task group share certain resources such as environment variables, file descriptors, "),e("code",null,"FILE"),t(" streams, sockets, pthread keys and open message queues.")]),e("blockquote",null,[e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"atexit")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"on_exit")])])]),e("p",null,"Note"),e("p",null,[t(`Behavior of features related to task group's depend of NuttX configuration settings. See the discussion of "Parent and Child Tasks," below. See also the`),e("a",{href:"https://cwiki.apache.org/confluence/display/NUTTX/NuttX+Tasking",target:"_blank",rel:"noreferrer"},"NuttX Tasking"),t("page and the"),e("a",{href:"https://cwiki.apache.org/confluence/display/NUTTX/Tasks+vs.+Threads+FAQ",target:"_blank",rel:"noreferrer"},"Tasks vs. Threads FAQ"),t("for additional information on tasks and threads in NuttX.")]),e("p",null,[t("A "),e("em",null,"task group"),t(" terminates when the last thread within the group exits.")])])],-1),e("h2",{id:"parent-and-child-tasks",tabindex:"-1"},[t("Parent and Child Tasks "),e("a",{class:"header-anchor",href:"#parent-and-child-tasks","aria-label":'Permalink to "Parent and Child Tasks"'},"​")],-1),e("p",null,"The task synchronization interfaces historically depend upon parent and child relationships between tasks. But default, NuttX does not use any parent/child knowledge. However, there are three important configuration options that can change that.",-1),e("blockquote",null,[e("ul",null,[e("li",null,[e("p",null,[e("code",null,"CONFIG_SCHED_HAVE_PARENT"),t(": If this setting is defined, then it instructs NuttX to remember the task ID of the parent task when each new child task is created. This support enables some additional features (such as "),e("code",null,"SIGCHLD"),t(") and modifies the behavior of other interfaces. For example, it makes "),e("code",null,"waitpid()"),t(" more standards complete by restricting the waited-for tasks to the children of the caller.")])]),e("li",null,[e("p",null,[e("code",null,"CONFIG_SCHED_CHILD_STATUS"),t(": If this option is selected, then the exit status of the child task will be retained after the child task exits. This option should be selected if you require knowledge of a child process's exit status. Without this setting, "),e("code",null,"wait()"),t(", "),e("code",null,"waitpid()"),t(" or "),e("code",null,"waitid()"),t(" may fail. For example, if you do:")]),e("blockquote",null,[e("ol",null,[e("li",null,"Start child task"),e("li",null,[t("Wait for exit status (using :c"),e("code",null,"wait"),t('{.interpreted-text role="func"}, :c'),e("code",{class:"interpreted-text",role:"func"},"waitpid"),t(" or :c"),e("code",{class:"interpreted-text",role:"func"},"waitid"),t(").")])])]),e("p",null,[t("This may fail because the child task may run to completion before the wait begins. There is a non-standard work-around in this case: The above sequence will work if you disable pre-emption using :c"),e("code",{class:"interpreted-text",role:"func"},"sched_lock"),t(" prior to starting the child task, then re-enable pre-emption with :c"),e("code",{class:"interpreted-text",role:"func"},"sched_unlock"),t(" after the wait completes. This works because the child task is not permitted to run until the wait is in place.")]),e("p",null,[t("The standard solution would be to enable "),e("code",null,"CONFIG_SCHED_CHILD_STATUS"),t(". In this case the exit status of the child task is retained after the child exits and the wait will successful obtain the child task's exit status whether it is called before the child task exits or not.")])]),e("li",null,[e("p",null,[e("code",null,"CONFIG_PREALLOC_CHILDSTATUS"),t(". To prevent runaway child status allocations and to improve allocation performance, child task exit status structures are pre-allocated when the system boots. This setting determines the number of child status structures that will be pre-allocated.")]),e("p",null,[t("Obviously, if tasks spawn children indefinitely and never have the exit status reaped, then you may have a memory leak! (See "),e("strong",null,"Warning"),t(" below)")])])])],-1),l(`<p>Warning</p><p>If you enable the <code>CONFIG_SCHED_CHILD_STATUS</code> feature, then your application must either (1) take responsibility for reaping the child status with <code>wait()</code>, <code>waitpid()</code> or <code>waitid()</code>, or (2) suppress retention of child status. If you do not reap the child status, then you have a memory leak and your system will eventually fail.</p><p>Retention of child status can be suppressed on the parent using logic like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct sigaction sa;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>sa.sa_handler = SIG_IGN;</span></span>
<span class="line"><span>sa.sa_flags = SA_NOCLDWAIT;</span></span>
<span class="line"><span>int ret = sigaction(SIGCHLD, &amp;sa, NULL);</span></span></code></pre></div><h2 id="functions" tabindex="-1">Functions <a class="header-anchor" href="#functions" aria-label="Permalink to &quot;Functions&quot;">​</a></h2>`,5)]))}const m=n(o,[["render",r]]);export{k as __pageData,m as default};
