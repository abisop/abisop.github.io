import{_ as s,c as e,al as n,o as t}from"./chunks/framework.NFAqBSgQ.js";const d=JSON.parse('{"title":"Linux Processes vs NuttX Tasks","description":"","frontmatter":{},"headers":[],"relativePath":"en/implementation/processes_vs_tasks.md","filePath":"en/implementation/processes_vs_tasks.md"}'),i={name:"en/implementation/processes_vs_tasks.md"};function l(o,a,p,r,c,h){return t(),e("div",null,a[0]||(a[0]=[n(`<h1 id="linux-processes-vs-nuttx-tasks" tabindex="-1">Linux Processes vs NuttX Tasks <a class="header-anchor" href="#linux-processes-vs-nuttx-tasks" aria-label="Permalink to &quot;Linux Processes vs NuttX Tasks&quot;">​</a></h1><p>You may be used to running programs that are stored in files on Linux or Windows. If you transition to using NuttX tasks on an MCU with limited resources, you will encounter some behavioral differences. This Wiki page will summarize a few of those differences.</p><h2 id="nuttx-build-types" tabindex="-1">NuttX Build Types <a class="header-anchor" href="#nuttx-build-types" aria-label="Permalink to &quot;NuttX Build Types&quot;">​</a></h2><p>NuttX can be built in several different ways:</p><ul><li><strong>Kernel Build</strong> The kernel build, selected with <code>CONFIG_BUILD_KERNEL</code>, uses the MCU&#39;s Memory Management Unit (MMU) to implement processes very similar to Linux processes. There is no interesting discussion here; NuttX behaves very much like Linux.</li><li><strong>Flat Build</strong> Most resource-limited MCUs have no MMU and the code is built as a blob that runs in an unprotected, flat address space out of on-chip FLASH memory. This build mode is selected with <code>CONFIG_BUILD_FLAT</code> and is, by far, the most common way that people build NuttX. This is the interesting case to which this Wiki page is directed.</li><li><strong>Protected Build</strong> Another build option is the protected build. This is essentially the same as the flat build, but uses the MCU&#39;s Memory Protection Unit (MPU) to separate unproctect user address ranges from protected system address ranges. The comments of this Wiki page also apply in this case.</li></ul><h2 id="initialization-of-global-variables" tabindex="-1">Initialization of Global Variables <a class="header-anchor" href="#initialization-of-global-variables" aria-label="Permalink to &quot;Initialization of Global Variables&quot;">​</a></h2><h3 id="linux-behavior" tabindex="-1">Linux Behavior <a class="header-anchor" href="#linux-behavior" aria-label="Permalink to &quot;Linux Behavior&quot;">​</a></h3><p>If you are used to writing programs for Linux, then one thing you will notice is that global variables are initialized only once when the system powers up. For example. Consider this tiny program:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>bool test = true;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main(int argc, char **argv)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, test);</span></span>
<span class="line"><span>  test = false;</span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, test);</span></span>
<span class="line"><span>  return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>If you build and run this program under Linux, you will always see this output:</p><pre><code>test: 1
test: 0
</code></pre><p>In this case, the global variables are re-initialized each time that you load the file into memory and run it.</p><h3 id="nuttx-flat-build-behavior" tabindex="-1">NuttX Flat-Build Behavior <a class="header-anchor" href="#nuttx-flat-build-behavior" aria-label="Permalink to &quot;NuttX Flat-Build Behavior&quot;">​</a></h3><p>But if you build this program into on-chip FLASH and start it as a task (via, say, <code>task_start()</code>) you will see this the first time that you run the program:</p><pre><code>test: 1
test: 0
</code></pre><p>But after that, you will always see:</p><pre><code>test: 0
test: 0
</code></pre><p>The test variable was initialized to true (1) only once at power up, but reset to false (0) each time that the program runs.</p><p>If you want the same behavior when the program is built into the common FLASH blob, then you will have modify the code so that global variables are explicitly reset each time the program runs like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>bool test;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main(int argc, char **argv)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  test = true;</span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, test);</span></span>
<span class="line"><span>  test = false;</span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, test);</span></span>
<span class="line"><span>  return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="nuttx-load-able-programs" tabindex="-1">NuttX Load-able Programs <a class="header-anchor" href="#nuttx-load-able-programs" aria-label="Permalink to &quot;NuttX Load-able Programs&quot;">​</a></h3><p>If you load programs from an file into RAM and execute them, as Linux does, then NuttX will again behave like Linux. Because the flat build NuttX works the same way: When you execute a NuttX ELF or NxFLAT module in a file, the file is copied into RAM and the global variables are initialized before the program runs.</p><p>But code that is built into FLASH works differently. There is only one set of global variables: All of the global variables for the blob that is the monolithic FLASH image. They are all initialized once at power-up reset.</p><p>This is one of the things that makes porting Linux applications into the FLASH blob more complex. You have to manually initialize each global variable in the <code>main()</code> each time your start the task.</p><h2 id="global-variables-and-multiple-task-copies" tabindex="-1">Global Variables and Multiple Task Copies <a class="header-anchor" href="#global-variables-and-multiple-task-copies" aria-label="Permalink to &quot;Global Variables and Multiple Task Copies&quot;">​</a></h2><p>It is better to avoid the use of global variables in the flat build context whenever possible because that usage adds another limitation: No more that one copy of the program can run at any given time. That is because the global variables are shared by each instance (unlike, again, running a program from a file where there is a private copy of each global variable).</p><p>One way to support multiple copies of an in-FLASH program is to move all global variables into a structure. If the amount of memory need for global variables is small, then each <code>main()</code> could simply allocate a copy of that structure on the stack. In the simple example above, this might be:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct my_globals_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  bool test;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main(int argc, char **argv)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  struct my_globals_s my_globals = { true };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, my_globals.test);</span></span>
<span class="line"><span>  my_globals.test = false;</span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, my_globals.test);</span></span>
<span class="line"><span>  return EXIT_SUCCESS;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>A pointer to the structure containing the allocated global variables would then have to passed as a parameter to every internal function that needs access to the global variables. So you would change a internal function like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>static void print_value(void)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, test);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>to:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>static void print_value(FAR struct my_globals_s *globals)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, globals-&gt;test);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Then pass a reference to the allocated global data structure each time that the function is called like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>print_value(&amp;my_globals);</span></span></code></pre></div><p>If the size of the global variable structure is large, then allocating the instance on the stack might not be such a good idea. In that case, it might be better to allocate the global variable structure using <code>malloc()</code>. But don&#39;t forget to <code>free()</code> the allocated variable structure before exiting! (See the following Memory Clean-Up discussion).</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct my_globals_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  bool test;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main(int argc, char **argv)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  FAR struct my_globals_s *my_globals;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  my_globals = (FAR struct my_globals_s *)malloc(sizeof(struct my_globals_s));</span></span>
<span class="line"><span>  if (my_globals = NULL)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      fprintf(stderr, &quot;ERROR: Failed to allocate state structure\\n&quot;);</span></span>
<span class="line"><span>      return EXIT_FAILURE;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  my_globals=&gt;test = true;</span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, my_globals-&gt;test);</span></span>
<span class="line"><span>  my_globals=&gt;test = false;</span></span>
<span class="line"><span>  printf(&quot;test: %i\\n&quot;, my_globals-&gt;test);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  free(my_globals);</span></span>
<span class="line"><span>  return EXIT_SUCCESS;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="memory-clean-up" tabindex="-1">Memory Clean-Up <a class="header-anchor" href="#memory-clean-up" aria-label="Permalink to &quot;Memory Clean-Up&quot;">​</a></h2><h3 id="linux-process-exit" tabindex="-1">Linux Process Exit <a class="header-anchor" href="#linux-process-exit" aria-label="Permalink to &quot;Linux Process Exit&quot;">​</a></h3><p>Another, unrelated thing that makes porting Linux programs into the FLASH blob is the memory clean-up. When a Linux process exits, its entire address environment is destroyed including all of allocated memory. This tiny program will not leak memory if implemented as a Linux process:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int main(int argc, char **argv)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  char *buffer = malloc(1024);</span></span>
<span class="line"><span>  ... do stuff with buffer ...</span></span>
<span class="line"><span>  return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>That same program, if ported into the FLASH blob will now have memory leaks because there is no automatic clean-up of allocated memory when the task exits. Instead, you must explicitly clean up all allocated memory by freeing it:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int main(int argc, char **argv)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  char *buffer = malloc(1024);</span></span>
<span class="line"><span>  ... do stuff with buffer ...</span></span>
<span class="line"><span>  free(buffer);</span></span>
<span class="line"><span>  return 0;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>The memory clean-up with the Linux process exits is a consequent of the teardown of the process address environment when the process terminates. Each process contains its own heap; when the process address environment is torndown, that process heap is returned to the OS page allocator. So the memory clean-up basically comes for free.</p><h3 id="nuttx-task-exit" tabindex="-1">NuttX Task Exit <a class="header-anchor" href="#nuttx-task-exit" aria-label="Permalink to &quot;NuttX Task Exit&quot;">​</a></h3><p>But when you run a task in the monolithic, on-chip FLASH blob, you share the same heap with all other tasks. There is no magic clean-up that can find and free your tasks&#39;s allocations within the common heap (see &quot;Ways to Free Memory on Task Exit&quot;).</p><h3 id="nuttx-process-exit" tabindex="-1">NuttX Process Exit <a class="header-anchor" href="#nuttx-process-exit" aria-label="Permalink to &quot;NuttX Process Exit&quot;">​</a></h3><p>NOTE that when you run processes on NuttX (with <code>CONFIG_BUILD_KERNEL</code>), NuttX also behaves the same way as Linux: The address environment is destroyed with the task exits and all of the memory is reclaimed. But all other cases will leak memory.</p><h3 id="ways-to-free-memory-on-task-exit" tabindex="-1">Ways to Free Memory on Task Exit <a class="header-anchor" href="#ways-to-free-memory-on-task-exit" aria-label="Permalink to &quot;Ways to Free Memory on Task Exit&quot;">​</a></h3><p>There are ways that you could associate allocated memory with a task so that it could cleaned up when the task exits. That approach has been rejected, however, because (1) it could not be done reliably, and (2) it would add a memory allocation overhead that would not be acceptable in context where memory is constrained.</p><p>Related issue can be found on <a href="https://github.com/apache/nuttx/issues/3345" target="_blank" rel="noreferrer">Github</a>.</p>`,50)]))}const b=s(i,[["render",l]]);export{d as __pageData,b as default};
