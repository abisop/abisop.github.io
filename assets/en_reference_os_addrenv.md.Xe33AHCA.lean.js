import{_ as s,c as a,al as r,j as e,a as t,o as l}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"Address Environments","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/os/addrenv.md","filePath":"en/reference/os/addrenv.md"}'),i={name:"en/reference/os/addrenv.md"};function d(o,n,c,u,h,p){return l(),a("div",null,n[0]||(n[0]=[r("",4),e("ol",null,[e("li",null,[e("p",null,[e("strong",null,"Binary Loader Support"),t(". These are low-level interfaces used in "),e("code",null,"binfmt/"),t(" to instantiate tasks with address environments. These interfaces all operate on type "),e("code",null,"arch_addrenv_t"),t(" which is an abstract representation of a task group's address environment and the type must be defined in"),e("code",null,"arch/arch.h"),t(" if "),e("code",null,"CONFIG_ARCH_ADDRENV"),t(" is defined. These low-level interfaces include:")]),e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_create()"),t(": Create an address environment.")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_destroy()"),t(": Destroy an address environment.")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_vtext()"),t(": Returns the virtual base address of the "),e("code",null,".text"),t(" address environment.")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_vdata()"),t(": Returns the virtual base address of the "),e("code",null,".bss"),t("/"),e("code",null,".data"),t(" address environment.")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_heapsize()"),t(": Return the initial heap size.")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_select()"),t(": Instantiate an address environment.")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_clone()"),t(": Copy an address environment from one location to another.")])])]),e("li",null,[e("p",null,[e("strong",null,"Tasking Support"),t(". Other interfaces must be provided to support higher-level interfaces used by the NuttX tasking logic. These interfaces are used by the functions in "),e("code",null,"sched/"),t(" and all operate on the task group which as been assigned an address environment by "),e("code",null,"up_addrenv_clone()"),t(".")]),e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_attach()"),t(": Clone the group address environment assigned to a new thread. This operation is done when a pthread is created that share's the same address environment.")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_detach()"),t(": Release the thread's reference to a group address environment when a task/thread exits.")])])]),e("li",null,[e("p",null,[e("strong",null,"Dynamic Stack Support"),t(". "),e("code",null,"CONFIG_ARCH_STACK_DYNAMIC=y"),t(" indicates that the user process stack resides in its own address space. This option is also "),e("em",null,"required"),t(" if "),e("code",null,"CONFIG_BUILD_KERNEL"),t(" and "),e("code",null,"CONFIG_LIBC_EXECFUNCS"),t(" are selected. Why? Because the caller's stack must be preserved in its own address space when we instantiate the environment of the new process in order to initialize it.")]),e("p",null,[e("strong",null,"NOTE:"),t(" The naming of the "),e("code",null,"CONFIG_ARCH_STACK_DYNAMIC"),t(" selection implies that dynamic stack allocation is supported. Certainly this option must be set if dynamic stack allocation is supported by a platform. But the more general meaning of this configuration environment is simply that the stack has its own address space.")]),e("p",null,[t("If "),e("code",null,"CONFIG_ARCH_STACK_DYNAMIC=y"),t(" is selected then the platform specific code must export these additional interfaces:")]),e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_ustackalloc()"),t(": Create a stack address environment")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_ustackfree()"),t(": Destroy a stack address environment.")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_vustack()"),t(": Returns the virtual base address of the stack")]),e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_ustackselect()"),t(": Instantiate a stack address environment")])])]),e("li",null,[e("p",null,[t("If "),e("code",null,"CONFIG_ARCH_KERNEL_STACK"),t(" is selected, then each user process will have two stacks: (1) a large (and possibly dynamic) user stack and (2) a smaller kernel stack. However, this option is "),e("em",null,"required"),t(" if both "),e("code",null,"CONFIG_BUILD_KERNEL"),t(" and "),e("code",null,"CONFIG_LIBC_EXECFUNCS"),t(" are selected. Why? Because when we instantiate and initialize the address environment of the new user process, we will temporarily lose the address environment of the old user process, including its stack contents. The kernel C logic will crash immediately with no valid stack in place.")]),e("p",null,[t("If "),e("code",null,"CONFIG_ARCH_KERNEL_STACK=y"),t(" is selected then the platform specific code must export these additional interfaces:")]),e("ul",null,[e("li",null,[t(":c"),e("code",{class:"interpreted-text",role:"func"},"up_addrenv_kstackalloc"),t(": Allocate the process kernel stack.")])])])],-1)]))}const m=s(i,[["render",d]]);export{f as __pageData,m as default};
