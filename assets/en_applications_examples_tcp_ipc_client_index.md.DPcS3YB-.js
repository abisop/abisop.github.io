import{_ as e,c as a,al as i,o as n}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"tcp_ipc_client Client for TCP IPC NuttX","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/examples/tcp_ipc_client/index.md","filePath":"en/applications/examples/tcp_ipc_client/index.md"}'),s={name:"en/applications/examples/tcp_ipc_client/index.md"};function o(r,t,l,c,p,h){return n(),a("div",null,t[0]||(t[0]=[i('<h1 id="tcp-ipc-client-client-for-tcp-ipc-nuttx" tabindex="-1"><code>tcp_ipc_client</code> Client for TCP IPC NuttX <a class="header-anchor" href="#tcp-ipc-client-client-for-tcp-ipc-nuttx" aria-label="Permalink to &quot;`tcp_ipc_client` Client for TCP IPC NuttX&quot;">​</a></h1><h2 id="what-s-this" tabindex="-1">What&#39;s this? <a class="header-anchor" href="#what-s-this" aria-label="Permalink to &quot;What&#39;s this?&quot;">​</a></h2><p>This program consists of a client socket &amp; custom messages that send data (hex-string formatted data) to a server (tcp_ipc_server). Then, tcp_ipc_server send this data over LoraWAN (using Radioenge LoRaWAN module). It means using TCP/IP sockets as IPC channel to ensure controlled access to LoRaWAN connectivity. The goals of using this approach to send LoRaWAN data are:</p><ul><li>Having a solid and reliable infrastructure to ensure IPC works fine for multiple applications simultaneously</li><li>Having the possibility to host different IoT projects and solutions that use LPWAN in a single ESP32</li><li>Having the possibility to validate, test and debug multiple IoT projects and solutions at the same time, under the same connectivity conditions (same signal strength, same antenna, same modem/transceiver, etc.)</li></ul><p>Both client and server work on local network scope.</p><h2 id="how-do-i-use-this" tabindex="-1">How do I use this? <a class="header-anchor" href="#how-do-i-use-this" aria-label="Permalink to &quot;How do I use this?&quot;">​</a></h2><p>In order to test tcp_ipc_client &amp; tcp_ipc_server together, there are two ways to proceed:</p><ul><li>Init server manually (command: SERVER &amp;), and after successful server init, also init client manually (CLIENT 127.0.0.1)</li><li>init server automatically after boot using NuttShell start up scripts (check: <a href="https://nuttx.apache.org/docs/latest/applications/nsh/installation.html#nuttshell-start-up-scripts" target="_blank" rel="noreferrer">https://nuttx.apache.org/docs/latest/applications/nsh/installation.html#nuttshell-start-up-scripts</a> )</li></ul><h2 id="additional-info" tabindex="-1">Additional info <a class="header-anchor" href="#additional-info" aria-label="Permalink to &quot;Additional info&quot;">​</a></h2><p>Both tcp_ipc_client and tcp_ipc_server examples have been full covered in NuttX International Workshop 2022. You can watch the full presentation here: <a href="https://www.youtube.com/watch?v=hr0OfTt1KeY" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=hr0OfTt1KeY</a> The tcp_ipc_server and tcp_ipc_client examples have been developed by Flavio Ipirranga and Pedro Bertoleti from Instituto de Pesquisas Eldorado (IPE) in Brazil.</p>',10)]))}const _=e(s,[["render",o]]);export{u as __pageData,_ as default};
