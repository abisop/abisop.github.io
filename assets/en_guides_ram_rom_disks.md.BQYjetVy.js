import{_ as e,c as a,al as n,o as i}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"RAM Disks and ROM Disks","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/ram_rom_disks.md","filePath":"en/guides/ram_rom_disks.md"}'),t={name:"en/guides/ram_rom_disks.md"};function o(r,s,c,p,l,d){return i(),a("div",null,s[0]||(s[0]=[n(`<h1 id="ram-disks-and-rom-disks" tabindex="-1">RAM Disks and ROM Disks <a class="header-anchor" href="#ram-disks-and-rom-disks" aria-label="Permalink to &quot;RAM Disks and ROM Disks&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/RAM+Disks+and+ROM+Disks" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/RAM+Disks+and+ROM+Disks</a></p><h2 id="nsh-mkrd-command" tabindex="-1">NSH mkrd Command <a class="header-anchor" href="#nsh-mkrd-command" aria-label="Permalink to &quot;NSH mkrd Command&quot;">​</a></h2><p>The typical way to create a RAM disk is by using the NuttShell (NSH) <code>mkrd</code> command. The syntax is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mkrd [-m &lt;minor&gt;] [-s &lt;sector-size&gt;] &lt;nsectors&gt;</span></span></code></pre></div><p>This command creates a RAM disk consisting of <code>&lt;nsectors&gt;</code> sectors, each of size <code>&lt;sector-size&gt;</code> (or 512 bytes if <code>&lt;sector-size&gt;</code> is not specified). The RAM disk is then registered as <code>/dev/ram&lt;minor&gt;</code>. If <code>&lt;minor&gt;</code> is not specified, <code>mkrd</code> attempts to register the RAM disk as <code>/dev/ram0</code>.</p><p>Internally, the NSH <code>mkrd</code> command is a simple wrapper around the OS <code>boardctl()</code> interface, using the <code>BOARDIOC_MKRD</code> command. &quot;Under the hood,&quot; this <code>boardctl()</code> command performs the following:</p><ol><li>Allocates kernel-space memory with <code>kmm_malloc()</code> of size <code>&lt;nsectors&gt;</code> times <code>&lt;sector-size&gt;</code></li><li>Zeros the allocated memory, and</li><li>Calls the OS-internal function <code>ramdisk_register()</code> to create the RAM disk.</li></ol><h2 id="nsh-romfs-etc-support" tabindex="-1">NSH ROMFS /etc Support <a class="header-anchor" href="#nsh-romfs-etc-support" aria-label="Permalink to &quot;NSH ROMFS /etc Support&quot;">​</a></h2><p>A ROM disk is a block device created from a read-only file system image stored in FLASH or other ROM. There is no NSH command available to create a ROM disk at runtime. However, it is possible to enable ROM disk support in NSH using the <code>CONFIG_NSH_ROMFSETC</code> option, as described in the section on NSH start-up scripts in the <a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=139629410" target="_blank" rel="noreferrer">NSH User Guide</a>.</p><p>Any application is able to create a ROM disk using the <code>boardctl()</code> interface with the <code>BOARDIOC_ROMDISK</code> command.</p><h2 id="creating-ram-disks-in-board-bring-up-logic" tabindex="-1">Creating RAM Disks in Board Bring-Up Logic <a class="header-anchor" href="#creating-ram-disks-in-board-bring-up-logic" aria-label="Permalink to &quot;Creating RAM Disks in Board Bring-Up Logic&quot;">​</a></h2><p>RAM disks may be created in board-specific initialization logic that runs in supervisor mode. That logic might look as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int board_ramdisk(int minor, unsigned int sectsize, unsigned int nsectors)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  size_t allocsize = (size_t)sectsize * (size_t)nsectors;</span></span>
<span class="line"><span>  FAR uint8_t *buffer;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Allocate the memory backing up the ramdisk */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  buffer = (FAR uint8_t *)kmm_zalloc(allocsize);</span></span>
<span class="line"><span>  if (buffer == NULL)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      return -ENOMEM;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  /* Then register the ramdisk */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  ret = ramdisk_register(minor, buffer, nsectors, sectsize,</span></span>
<span class="line"><span>                        RDFLAG_WRENABLED | RDFLAG_FUNLINK);</span></span>
<span class="line"><span>  if (ret &lt; 0)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      kmm_free(buffer);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return ret;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Alternatively, this could be replaced by a call to the OS internal function <code>mkrd()</code>.</p><h2 id="creating-rom-disks-in-board-bring-up-logic" tabindex="-1">Creating ROM Disks in Board Bring-Up Logic <a class="header-anchor" href="#creating-rom-disks-in-board-bring-up-logic" aria-label="Permalink to &quot;Creating ROM Disks in Board Bring-Up Logic&quot;">​</a></h2><p>Note</p><p>Currently, the <code>romdisk_register()</code> function is only available within the OS. Certain logic in <code>apps/</code> directly calls <code>romdisk_register()</code>, which violates the portable POSIX OS interface. The correct approach for an application is to create a ROM disk via <code>boardctl(BOARDIOC_ROMDISK)</code> as described above. Calling <code>romdisk_register()</code> directly is not only a violation of the NuttX portable interface, but also is not allowed in PROTECTED or KERNEL build modes.</p><p>ROM disks, i.e., read-only disks in FLASH, can be created by board bring-up logic in a way similar to RAM disks, with the following caveats:</p><ul><li>The FLASH region is not allocated; the FLASH address, the sector size, and the number of sectors must already be known.</li><li>The <code>romdisk_register()</code> function is used instead of <code>ramdisk_register()</code>.</li></ul><p>A simple example could look like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int board_romdisk(int minor, FAR uint8_t *buffer, unsigned int sectsize,</span></span>
<span class="line"><span>                  unsigned int nsectors)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  /* Register the romdisk */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  return romdisk_register(minor, buffer, nsectors, sectsize);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Calling <code>romdisk_register()</code> is equivalent to calling <code>ramdisk_register()</code> with the final parameter <code>flags == 0</code>.</p><p>Most ROM disks use the ROMFS file system, although CROMFS is another option. Creating ROMFS file system images involves several steps. Tools are available to simplify the process of building ROMFS images, but that topic is outside the scope of this Wiki page.</p>`,25)]))}const g=e(t,[["render",o]]);export{h as __pageData,g as default};
