import{_ as t,c as s,al as o,o as r}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"USB Host-Side Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/special/usbhost.md","filePath":"en/components/drivers/special/usbhost.md"}'),c={name:"en/components/drivers/special/usbhost.md"};function i(n,e,a,d,l,h){return r(),s("div",null,e[0]||(e[0]=[o('<h1 id="usb-host-side-drivers" tabindex="-1">USB Host-Side Drivers <a class="header-anchor" href="#usb-host-side-drivers" aria-label="Permalink to &quot;USB Host-Side Drivers&quot;">â€‹</a></h1><ul><li><p><strong>USB host controller driver</strong> abstracts the host controller device in the target chip. Each USB host controller driver must implement an instance of <code>struct usbhost_driver_s</code> and <code>struct usbhost_connection_s</code> defined in <code>include/nuttx/usb/usbhost.h</code>.</p><ul><li><code>struct usbhost_driver_s</code> provides the interface between the USB host driver and the USB host class driver.</li><li><code>struct usbhost_connection_s</code> provides the interface between the USB host driver and platform-specific connection management and device enumeration logic.</li></ul><p><strong>Examples</strong>: <code>arch/arm/src/lpc17xx_40xx/lpc17_40_usbhost.c</code>, <code>arch/arm/src/stm32/stm32_otgfshost.c</code>, <code>arch/arm/src/sama5/sam_ohci.c</code>, and <code>arch/arm/src/sama5/sam_ehci.c</code>.</p></li><li><p><strong>USB host class driver</strong> abstracts USB peripherals connected to the USB host controller. Each USB host class driver must implement an instance of <code>struct usbhost_class_s</code> defined also in <code>include/nuttx/usb/usbhost.h</code>.</p><p><strong>Examples</strong>: <code>drivers/usbhost/usbhost_storage.c</code></p></li><li><p><strong>USB Host Class Driver Registry</strong>. The NuttX USB host infrastructure includes a <em>registry</em>. During its initialization, each USB host class driver must call the interface, <code>usbhost_registerclass()</code> in order to add its interface to the registry. Later, when a USB device is connected, the USB host controller will look up the USB host class driver that is needed to support the connected device in this registry.</p><p><strong>Examples</strong>: <code>drivers/usbhost/usbhost_registry.c</code>, <code>drivers/usbhost/usbhost_registerclass.c</code>, and <code>drivers/usbhost/usbhost_findclass.c</code>,</p></li><li><p><strong>Detection and Enumeration of Connected Devices</strong>. Each USB host device controller supports two methods that are used to detect and enumeration newly connected devices (and also detect disconnected devices):</p><ul><li><p><code>int (*wait)(FAR struct usbhost_connection_s *drvr, FAR const bool *connected);</code></p><p>Wait for a device to be connected or disconnected.</p></li><li><p><code>int (*enumerate)(FAR struct usbhost_connection_s *drvr, int rhpndx);</code></p><p>Enumerate the device connected to a root hub port. As part of this enumeration process, the driver will (1) get the device&#39;s configuration descriptor, (2) extract the class ID info from the configuration descriptor, (3) call <code>usbhost_findclass(</code>) to find the class that supports this device, (4) call the <code>create()</code> method on the <code>struct usbhost_registry_s interface</code> to get a class instance, and finally (5) call the <code>connect()</code> method of the <code>struct usbhost_class_s</code> interface. After that, the class is in charge of the sequence of operations.</p></li></ul></li><li><p><strong>Binding USB Host-Side Drivers</strong>. USB host-side controller drivers are not normally directly accessed by user code, but are usually bound to another, higher level USB host class driver. The class driver exports the standard NuttX device interface so that the connected USB device can be accessed just as with other, similar, on-board devices. For example, the USB host mass storage class driver (<code>drivers/usbhost/usbhost_storage.c</code>) will register a standard, NuttX block driver interface (like <code>/dev/sda</code>) that can be used to mount a file system just as with any other other block driver instance. In general, the binding sequence is:</p><ol><li><p>Each USB host class driver includes an initialization entry point that is called from the application at initialization time. This driver calls <code>usbhost_registerclass()</code> during this initialization in order to makes itself available in the event the device that it supports is connected.</p><p><strong>Examples</strong>: The function <code>usbhost_msc_initialize()</code> in the file <code>drivers/usbhost/usbhost_storage.c</code></p></li><li><p>Each application must include a <em>waiter</em> thread that</p><p>(1) calls the USB host controller driver&#39;s <code>wait()</code> to detect the connection of a device, and then (2) call the USB host controller driver&#39;s <code>enumerate</code> method to bind the registered USB host class driver to the USB host controller driver.</p><p><strong>Examples</strong>: The function <code>nsh_waiter()</code> in the file <code>boards/arm/lpc17xx_40xx/olimex-lpc1766stk/src/lpc17_40_appinit.c</code>.</p></li><li><p>As part of its operation during the binding operation, the USB host class driver will register an instances of a standard NuttX driver under the <code>/dev</code> directory. To repeat the above example, the USB host mass storage class driver (<code>drivers/usbhost/usbhost_storage.c</code>) will register a standard, NuttX block driver interface (like <code>/dev/sda</code>) that can be used to mount a file system just as with any other other block driver instance.</p><p><strong>Examples</strong>: See the call to <code>register_blockdriver()</code> in the function <code>usbhost_initvolume()</code> in the file <code>drivers/usbhost/usbhost_storage.c</code>.</p></li></ol></li></ul>',2)]))}const v=t(c,[["render",i]]);export{p as __pageData,v as default};
