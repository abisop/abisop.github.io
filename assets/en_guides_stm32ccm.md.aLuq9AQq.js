import{_ as a,c as t,al as s,o}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"STM32 CCM Allocator","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/stm32ccm.md","filePath":"en/guides/stm32ccm.md"}'),l={name:"en/guides/stm32ccm.md"};function n(i,e,r,c,p,d){return o(),t("div",null,e[0]||(e[0]=[s(`<h1 id="stm32-ccm-allocator" tabindex="-1">STM32 CCM Allocator <a class="header-anchor" href="#stm32-ccm-allocator" aria-label="Permalink to &quot;STM32 CCM Allocator&quot;">​</a></h1><h2 id="ccm-memory" tabindex="-1">CCM Memory <a class="header-anchor" href="#ccm-memory" aria-label="Permalink to &quot;CCM Memory&quot;">​</a></h2><p>The STM32 F2, F3, and F4 families have a special block of SRAM available called CCM (Core Coupled Memory). This memory has the drawback that it cannot be used for STM32 DMA operations.</p><p>By default, the CCM memory is lumped in with the rest of memory when the NuttX heaps are created. But this can be a problem because it will be a toss of the coin if non-DMA-able CCM memory or other DMA-able memory gets returned when <code>malloc()</code> is called. That usually does not matter but it certainly does make a difference if you are allocating memory that will be used for DMA! In that case, getting CCM memory for your DMA buffer will cause a failure.</p><h2 id="config-stm32-ccmexclude" tabindex="-1">CONFIG_STM32_CCMEXCLUDE <a class="header-anchor" href="#config-stm32-ccmexclude" aria-label="Permalink to &quot;CONFIG\\_STM32\\_CCMEXCLUDE&quot;">​</a></h2><p>There is a configuration option called <code>CONFIG_STM32_CCMEXCLUDE</code> that can be used to exclude CCM memory from the heap. That solves the problem of getting CCM memory when you want to allocate a DMA buffer. But then what do you do with the CCM memory? Do you let it go unused?</p><h2 id="ccm-allocator" tabindex="-1">CCM Allocator <a class="header-anchor" href="#ccm-allocator" aria-label="Permalink to &quot;CCM Allocator&quot;">​</a></h2><p>In order to make use of the CCM memory, a CCM memory allocator is available. This memory allocator is automatically enabled when the following options are set:</p><ul><li><code>CONFIG_STM32_CCMEXCLUDE</code> CCM memory is excluded from the normal heap, and</li><li><code>CONFIG_MM_MULTIHEAP</code> Support for multiple heaps is enabled.</li></ul><p>Under those conditions, the CCM memory allocator is enabled and the allocator interfaces prototyped in the <code>arch/arm/src/stm32/stm32_ccm.h</code> are available.</p><p>NOTE: These interfaces are, technically, not prototyped since they are really provided via C pre-processor macros.</p><p>NOTE: In order to use the CCM memory allocator functions, you must first call <code>ccm_initialize()</code> somewhere in your early boot-up logic.</p><p>With these interfaces you have a (nearly) standard way to manage memory from a heap that consists of the the CCM SRAM. And, since the CCM memory is no longer a part of the normal heap, all allocated I/O buffers will be DMA-able (unless you have included other non-DMA-able memory regions in the stack).</p><h2 id="ccm-stacks" tabindex="-1">CCM Stacks <a class="header-anchor" href="#ccm-stacks" aria-label="Permalink to &quot;CCM Stacks&quot;">​</a></h2><p>One particular problem that has been reported by Petteri Aimonen requires some additional work-arounds. The STM32 SPI driver supports DMA and with SPI it is sometimes necessary to do some very small transfers for which there is no real gain from using DMA. In this case, Petteri has devised a clever way to both 1) make use of the CMM memory and 2) to force fallback to non-DMA transfers for these small stack transfers.</p><p>Here is what Petteri has done:</p><ol><li><p>First, he has modified <code>arch/arm/src/common/up_createstack.c</code> and <code>up_releasestack.c</code> so that stacks are allocated from CCM memory. That allocation is something like the following:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void *result = ccm_zalloc(size);</span></span>
<span class="line"><span>if (!result)</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>   /* Fall back to main heap */</span></span>
<span class="line"><span>    result = zalloc(size);</span></span>
<span class="line"><span>  }</span></span></code></pre></div><p>With the matching:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>if (((uint32_t)p &amp; 0xF0000000) == 0x10000000)</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    ccm_free(p);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    free(p);</span></span>
<span class="line"><span>  }</span></span></code></pre></div></li><li><p>Then Petteri added special DMA support enabled with <code>CONFIG_STM32_DMACAPABLE</code>. That option enables an option in all of the DMA logic called:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>bool stm32_dmacapable(uint32_t maddr);</span></span></code></pre></div><p>That will return true if it is possible to do DMA from the address and false if not.</p></li><li><p>Finally, Petteri added logic to the STM32 SPI driver that use <code>stm32_dmacapable()</code>: If the address is not DMA capable, then the SPI driver will fall back to non-DMA operation.</p><p>With Petteri&#39;s changes all of the large I/O buffers will be allocated from DMA-able memory. All stacks will be allocated from non-DMA-able CCM memory (provided that there is space). Small SPI DMA buffers on the non-DMA-able stack will be detected by <code>stm32_dmacapable()</code> and in that case, the STM32 SPI driver will fall back and use non-DMA-transfers.</p><p>From all reports this works quite well.</p></li></ol>`,17)]))}const u=a(l,[["render",n]]);export{m as __pageData,u as default};
