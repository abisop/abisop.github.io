import{_ as s,c as a,al as n,o as t}from"./chunks/framework.NFAqBSgQ.js";const i="/assets/sensor_driver_model.D28-2S1X.png",g=JSON.parse('{"title":"Sensor \\"uORB\\" Drivers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/drivers/special/sensors/sensors_uorb.md","filePath":"en/components/drivers/special/sensors/sensors_uorb.md"}'),r={name:"en/components/drivers/special/sensors/sensors_uorb.md"};function o(l,e,p,c,d,h){return t(),a("div",null,e[0]||(e[0]=[n('<h1 id="sensor-uorb-drivers" tabindex="-1">Sensor &quot;uORB&quot; Drivers <a class="header-anchor" href="#sensor-uorb-drivers" aria-label="Permalink to &quot;Sensor \\&quot;uORB\\&quot; Drivers&quot;">​</a></h1><p>NuttX, in order to uniformly manage all sensors, reuse common code, and reduce space occupation, extracts the common parts of all sensor drivers into an <strong>upper half layer</strong> that provides general functionalities. The <strong>lower half layer</strong> is responsible for the actual interaction with sensor registers.</p><p>NuttX sensor drivers focus more on physical sensors. For virtually fused sensors generated through integration, they are automatically created through application advertisements or subscriptions. For devices like IMUs, which integrate multiple sensors into one unit, multiple lower halves need to be instantiated within the driver, and device nodes are registered separately through the API (sensor_register) provided by the upper half.</p><h2 id="naming" tabindex="-1">Naming <a class="header-anchor" href="#naming" aria-label="Permalink to &quot;Naming&quot;">​</a></h2><p>The name used for this component in NuttX may be misleading because this sensor framework is not dependent on &quot;uORB&quot; in any way. Sensors implemented in this way can be used as general character drivers with a standardized interface.</p><h2 id="driver-model" tabindex="-1"><strong>Driver Model</strong> <a class="header-anchor" href="#driver-model" aria-label="Permalink to &quot;**Driver Model**&quot;">​</a></h2><p>The NuttX Sensor Upperhalf Driver is primarily responsible for registering device nodes, implementing the struct file_operations, multi-user access, ring buffer management, low power consumption, and downsampling logic. The Lowerhalf Driver is divided into rpmsg half and a general lower half. The rpmsg half is responsible for cross-core subscription and publication with remote CPUs, while the general lower half is responsible for interacting with sensor hardware. The main actions performed by the general lower half include a set of sensor operations such as <code>activate</code>, <code>set_interval</code>, <code>batch</code>, <code>selftest</code>, <code>set_calibvalue</code>, <code>calibrate</code>, and <code>control</code>. Under interrupt or polling mechanisms, sensor events are sent to the ring buffer in the upper layer.</p><p><img src="'+i+`" alt="image" class="align-center" width="800px"></p><h2 id="problems-to-solve" tabindex="-1">Problems to solve <a class="header-anchor" href="#problems-to-solve" aria-label="Permalink to &quot;Problems to solve&quot;">​</a></h2><p>The current implementation uses the <code>float</code> type which may make it difficult to use on platforms without FPU support.</p><h2 id="code" tabindex="-1"><strong>Code</strong> <a class="header-anchor" href="#code" aria-label="Permalink to &quot;**Code**&quot;">​</a></h2><pre><code>nuttx/driver/sensor/sensor.c               sensor upperhalf implementation
nuttx/driver/sensor/sensor_rpmsg.c         sensor rpmsg lowerhalf implementation
nuttx/driver/sensor/usensor.c              userspace sensor register implementation
nuttx/include/nuttx/sensors/sensor.h       sensor unify structure header file
nuttx/include/nuttx/sensors/ioctl.h        sensor ioctl cmd header file

CONFIG_SENSORS                             open sensor driver config
CONFIG_USENSORS                            open user sensor driver config
CONFIG_SENSORS_RPMSG                       open rpmsg sensor driver config
</code></pre><h2 id="data-structures" tabindex="-1"><strong>Data Structures</strong> <a class="header-anchor" href="#data-structures" aria-label="Permalink to &quot;**Data Structures**&quot;">​</a></h2><h3 id="sensor-types" tabindex="-1"><strong>Sensor Types</strong> <a class="header-anchor" href="#sensor-types" aria-label="Permalink to &quot;**Sensor Types**&quot;">​</a></h3><p>NuttX defines 50+ types of sensors, covering most physical sensors. All type definitions are located in include/nuttx/uorb.h. If a new type needs to be added, a comment must be provided for the new type, explaining the purpose and units of the sensor.</p><p><strong>SENSOR_TYPE_CUSTOM</strong></p><p>This is a custom type used for irregular sensor devices where the event structure changes or is dynamically altered. It is registered using <code>sensor_custom_register</code>.</p><p><strong>SENSOR_TYPE_ACCELEROMETER</strong></p><p>Accelerometer, used to measure the acceleration vector of the device. Units: m/s=2. Event data structure: (This indicates that there is a specific data structure for accelerometer events, but the actual structure is not provided in the text you gave.)</p><p>(won&#39;t introduce them one by one since there are many)</p><h3 id="sensor-topic-definition" tabindex="-1"><strong>Sensor Topic Definition</strong> <a class="header-anchor" href="#sensor-topic-definition" aria-label="Permalink to &quot;**Sensor Topic Definition**&quot;">​</a></h3><p>The data structure for sensors, which is also the topic structure for uORB, is defined in <code>include/nuttx/uorb.h</code>.</p><h3 id="lower-half-structure" tabindex="-1"><strong>Lower Half Structure</strong> <a class="header-anchor" href="#lower-half-structure" aria-label="Permalink to &quot;**Lower Half Structure**&quot;">​</a></h3><p>This structure serves as a bridge between the sensor driver&#39;s upper half and lower half. Both the upper half and lower half populate this structure, with the lower half responsible for synchronizing configuration information and the upper half for exposing data reporting interfaces.</p><p>The lower part highlighted in red is filled by the lower half driver, while the rest is filled by the upper half.</p><p><code>type</code> indicates the sensor type: <code>SENSOR_TYPE_XXX</code></p><p><code>nbuffer</code> specifies the length of the ring buffer in the upper half driver;</p><p><code>ops</code> represents the set of sensor operations implemented by the lower half driver.</p><p><code>push_event</code> and <code>notify_event</code> are not used simultaneously and are filled by the upper half.</p><p><code>push_event</code> works in conjunction with the ring buffer for the lower half to report data to the ring buffer;</p><p><code>notify_event</code> is used in conjunction with fetch to notify the upper half that data is ready when actively pulling data in a blocking operation.</p><p><code>sensor_lock</code> and <code>sensor_unlock</code> are filled by the upper half and exported to the lower half to avoid recursive deadlock issues. Currently, they are only used for sensor_rpmsg.</p><p><code>priv</code> is filled by the upper half and represents the upper context.</p><p><code>persist</code> indicates whether the topic is a notification-type topic.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct sensor_lowerhalf_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  int type;</span></span>
<span class="line"><span>  unsigned long nbuffer;</span></span>
<span class="line"><span>  FAR const struct sensor_ops_s *ops;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  union</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      sensor_push_event_t push_event;</span></span>
<span class="line"><span>      sensor_notify_event_t notify_event;</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  CODE void (*sensor_lock)(FAR void * priv);</span></span>
<span class="line"><span>  CODE void (*sensor_unlock)(FAR void * priv);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  FAR void *priv;</span></span>
<span class="line"><span>  bool persist;</span></span>
<span class="line"><span>};</span></span></code></pre></div><h3 id="api" tabindex="-1"><strong>API</strong> <a class="header-anchor" href="#api" aria-label="Permalink to &quot;**API**&quot;">​</a></h3><p>The NuttX Sensor UpperHalf Driver provides a set of APIs for the lower half, including registration and timestamp acquisition.</p><h4 id="registration-and-deregistration" tabindex="-1"><strong>Registration and Deregistration</strong> <a class="header-anchor" href="#registration-and-deregistration" aria-label="Permalink to &quot;**Registration and Deregistration**&quot;">​</a></h4><p>For the 50+ types of sensors, the sensor_register function can be used to register a character device. The parameter dev represents the handle of the lower half, and devno is the index of the device name. If the registration is successful, a node will be created under <code>/dev/{topic}</code>, for example: <code>/dev/topic/sensor_accel0</code>. If it fails, an error code will be returned.</p><p>For custom special-type drivers, the <code>sensor_custom_register</code> function needs to be used to register a character device. The parameter dev is the handle of the lower half, path is the path of the character device, and esize is the element size of the data reported by the sensor. If the registration is successful, a character device node will be created at the specified path. If it fails, an error code will be returned.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int sensor_register(FAR struct sensor_lowerhalf_s *dev, int devno);</span></span>
<span class="line"><span>void sensor_unregister(FAR struct sensor_lowerhalf_s *dev, int devno);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int sensor_custom_register(FAR struct sensor_lowerhalf_s *dev,</span></span>
<span class="line"><span>                           FAR const char *path, unsigned long esize);</span></span>
<span class="line"><span>void sensor_custom_unregister(FAR struct sensor_lowerhalf_s *dev,</span></span>
<span class="line"><span>                              FAR const char *path);</span></span></code></pre></div><h4 id="acquiring-timestamps" tabindex="-1"><strong>Acquiring Timestamps</strong> <a class="header-anchor" href="#acquiring-timestamps" aria-label="Permalink to &quot;**Acquiring Timestamps**&quot;">​</a></h4><p>The function returns a timestamp with microsecond precision.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>static inline uint64_t sensor_get_timestamp(void);</span></span></code></pre></div><h3 id="sensor-driver-operation-set" tabindex="-1"><strong>Sensor Driver Operation Set</strong> <a class="header-anchor" href="#sensor-driver-operation-set" aria-label="Permalink to &quot;**Sensor Driver Operation Set**&quot;">​</a></h3><p>Sensor driver frameworks for different systems and platforms always revolve around sensor characteristics, and the NuttX Sensor is no exception. For sensors, common operations include: opening/closing, initializing range/resolution/filtering, setting the sampling rate (ODR)/hardware FIFO/operating mode, and interrupt control. Based on practical applications and references from other systems, several key points have been selected to form the sensor operation set. For those without the need for dynamic changes, they can simply be passed as parameters to the initialization function.</p><h4 id="opening-closing" tabindex="-1"><strong>Opening/Closing</strong> <a class="header-anchor" href="#opening-closing" aria-label="Permalink to &quot;**Opening/Closing**&quot;">​</a></h4><p>When the caller invokes open and close, the corresponding open and close in the lower half will be called, with parameters being lower and filep respectively. filep contains user information, so the driver can differentiate between different users. Currently, this interface is only used by the sensor_rpmsg lower half.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CODE int (*open)(FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                 FAR struct file *filep);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CODE int (*close)(FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                  FAR struct file *filep);</span></span></code></pre></div><h4 id="activating-deactivating-the-sensor" tabindex="-1"><strong>Activating/Deactivating the Sensor</strong> <a class="header-anchor" href="#activating-deactivating-the-sensor" aria-label="Permalink to &quot;**Activating/Deactivating the Sensor**&quot;">​</a></h4><p>When the caller invokes open, if it is a subscriber, it will call activate in the lower half to activate the sensor. When close is called, deactivate is invoked to turn off the sensor.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CODE int (*activate)(FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                     FAR struct file *filep, bool enable);</span></span></code></pre></div><h4 id="setting-the-sampling-rate" tabindex="-1"><strong>Setting the Sampling Rate</strong> <a class="header-anchor" href="#setting-the-sampling-rate" aria-label="Permalink to &quot;**Setting the Sampling Rate**&quot;">​</a></h4><p>Applications (including the Sensor service) set the sampling rate of the sensor through the system call ioctl.</p><p>Call flow:</p><blockquote><ol><li><code>ioctl(fd, SNIOC_SET_INTERVAL, &amp;interval)</code></li><li>vfs</li><li><code>sensor_ioctl</code></li><li><code>set_interval()</code>.</li></ol></blockquote><p>The sampling interval between consecutive samples of the sensor is set in microseconds. If period_us exceeds the range of min_delay and max_delay, it will be adjusted. When modifying the sampling rate, it should be ensured that the data that has already been prepared is not lost.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CODE int (*batch)(FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                  FAR struct file *filep,</span></span>
<span class="line"><span>                  FAR unsigned long *latency_us);</span></span></code></pre></div><h4 id="proactively-pulling-data" tabindex="-1"><strong>Proactively Pulling Data</strong> <a class="header-anchor" href="#proactively-pulling-data" aria-label="Permalink to &quot;**Proactively Pulling Data**&quot;">​</a></h4><p>To proactively obtain sensor data, set to NULL if using interrupt or polling methods.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CODE int (*fetch)(FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                  FAR struct file *filep,</span></span>
<span class="line"><span>                  FAR char *buffer, size_t buflen);</span></span></code></pre></div><h4 id="self-test" tabindex="-1"><strong>Self-Test</strong> <a class="header-anchor" href="#self-test" aria-label="Permalink to &quot;**Self-Test**&quot;">​</a></h4><p>The sensor self-test is mainly used for factory testing and aging purposes.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CODE int (*selftest)(FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                     FAR struct file *filep,</span></span>
<span class="line"><span>                     unsigned long arg);</span></span></code></pre></div><h4 id="calibration" tabindex="-1"><strong>Calibration</strong> <a class="header-anchor" href="#calibration" aria-label="Permalink to &quot;**Calibration**&quot;">​</a></h4><p>Trigger calibration with calibrate and return calibration data to arg. Use set_calibvalue to set calibration data to the underlying sensor.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CODE int (*calibrate)(FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                      FAR struct file *filep,</span></span>
<span class="line"><span>                      unsigned long arg);</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>CODE int (*set_calibvalue)(FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                           FAR struct file *filep,</span></span>
<span class="line"><span>                           unsigned long arg);</span></span></code></pre></div><h4 id="sensor-information" tabindex="-1"><strong>Sensor Information</strong> <a class="header-anchor" href="#sensor-information" aria-label="Permalink to &quot;**Sensor Information**&quot;">​</a></h4><p>Use get_info to proactively obtain sensor information data, with the return value being <code>sensor_device_info_s</code>.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct sensor_device_info_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  uint32_t      version;</span></span>
<span class="line"><span>  float         power;</span></span>
<span class="line"><span>  float         max_range;</span></span>
<span class="line"><span>  float         resolution;</span></span>
<span class="line"><span>  int32_t       min_delay;</span></span>
<span class="line"><span>  int32_t       max_delay;</span></span>
<span class="line"><span>  uint32_t      fifo_reserved_event_count;</span></span>
<span class="line"><span>  uint32_t      fifo_max_event_count;</span></span>
<span class="line"><span>  char          name[SENSOR_INFO_NAME_SIZE];</span></span>
<span class="line"><span>  char          vendor[SENSOR_INFO_NAME_SIZE];</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>CODE int (*get_info)(FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                     FAR struct file *filep,</span></span>
<span class="line"><span>                     FAR struct sensor_device_info_s *info);</span></span></code></pre></div><h4 id="custom-control" tabindex="-1"><strong>Custom Control</strong> <a class="header-anchor" href="#custom-control" aria-label="Permalink to &quot;**Custom Control**&quot;">​</a></h4><p>In addition to the above controls, if certain sensor control requirements are still not met, the control command with custom controls can be used.</p><p>Call flow:</p><blockquote><ol><li><code>ioctl(fd, custom macro cmd, custom parameters)</code></li><li>vfs</li><li><code>sensor_ioctl</code></li><li><code>control()</code>.</li></ol></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CODE int (*control)(FAR struct file *filep,</span></span>
<span class="line"><span>                    FAR struct sensor_lowerhalf_s *lower,</span></span>
<span class="line"><span>                    int cmd, unsigned long arg);</span></span></code></pre></div><h3 id="downsampling" tabindex="-1"><strong>Downsampling</strong> <a class="header-anchor" href="#downsampling" aria-label="Permalink to &quot;**Downsampling**&quot;">​</a></h3><p>The downsampling capability of Vela Sensor is provided by the sensor upper half at the driver layer, supporting both aligned and unaligned downsampling mechanisms. When the publisher pushes the main line index each time, the subscriber retrieves data from its own index. If the difference between the two indexes exceeds the length of the internal queue, data will be lost. Otherwise, the next theoretical data point is calculated based on the subscription frequency, the publication frequency factor, and the current index.</p><h3 id="multi-core-mechanism" tabindex="-1"><strong>Multi-Core Mechanism</strong> <a class="header-anchor" href="#multi-core-mechanism" aria-label="Permalink to &quot;**Multi-Core Mechanism**&quot;">​</a></h3><p>The cross-core capability of Vela Sensor is provided by the sensor rpmsg lower half at the driver layer, which is primarily responsible for sending or receiving subscription and broadcast messages from other cores.</p><h3 id="publishing-topics" tabindex="-1"><strong>Publishing Topics</strong> <a class="header-anchor" href="#publishing-topics" aria-label="Permalink to &quot;**Publishing Topics**&quot;">​</a></h3><p>When a local application publishes a topic for the first time, it broadcasts the message to all cores. If there are subscriptions on other cores, they bind with each other. A stub is created locally to represent the subscription on a remote core, and a proxy is created on the remote core to represent the local publisher. All subsequent communication between them is determined by the context of the stub and proxy.</p><h3 id="subscribing-to-topics" tabindex="-1"><strong>Subscribing to Topics</strong> <a class="header-anchor" href="#subscribing-to-topics" aria-label="Permalink to &quot;**Subscribing to Topics**&quot;">​</a></h3><p>When a local application subscribes to a topic for the first time, if the message is broadcast to all cores and there are publishers on other cores, they bind with each other and communicate through stubs and proxies.</p><h3 id="remote-control" tabindex="-1"><strong>Remote Control</strong> <a class="header-anchor" href="#remote-control" aria-label="Permalink to &quot;**Remote Control**&quot;">​</a></h3><p>When a local subscriber modifies the sampling rate and the publisher of that topic is remote, the local proxy will publish this sampling rate to the remote stub. Upon receiving this control information, the stub sets it for the actual physical hardware. The same applies to other controls.</p><h3 id="remote-message-publishing" tabindex="-1"><strong>Remote Message Publishing</strong> <a class="header-anchor" href="#remote-message-publishing" aria-label="Permalink to &quot;**Remote Message Publishing**&quot;">​</a></h3><p>When local data is published, the sensor rpmsg lower half collects all messages within a sampling interval that does not exceed half of the fastest topic&#39;s interval and sends them to other cores together, reducing IPC occurrences and saving power consumption.</p><h3 id="subscription-and-publication-order" tabindex="-1"><strong>Subscription and Publication Order</strong> <a class="header-anchor" href="#subscription-and-publication-order" aria-label="Permalink to &quot;**Subscription and Publication Order**&quot;">​</a></h3><p>There is no order restriction for advertising and subscribing to topics. For notification-type topics, even if the advertisement is canceled immediately after data publication, other cores can still successfully obtain the latest data. For general-purpose topics, subscribing after publication will only allow reading of data published after the subscription.</p><h2 id="programming-modes" tabindex="-1"><strong>Programming Modes</strong> <a class="header-anchor" href="#programming-modes" aria-label="Permalink to &quot;**Programming Modes**&quot;">​</a></h2><p>NuttX Sensor drivers support three data retrieval methods: proactive, interrupt-driven, and polling. The proactive method allows filling sensor events using a buffer passed in by the app, reducing memory copy operations. The interrupt-driven and polling methods open an internal circular buffer, where each event is automatically pushed upon generation. The size of the buffer is set by sensor_lowerhalf_s::buffer_size. For sensors with high sampling rates, it is recommended to set the buffer size for 2-3 events, while for sensors with low sampling rates, setting it for 1 event is sufficient.</p><h3 id="proactive-retrieval" tabindex="-1"><strong>Proactive Retrieval</strong> <a class="header-anchor" href="#proactive-retrieval" aria-label="Permalink to &quot;**Proactive Retrieval**&quot;">​</a></h3><p>This method is recommended for sensors with low sampling rates and small data volumes. The <code>sensor_ops_s::fetch</code> function must be implemented.</p><p>The call flow is:</p><blockquote><ol><li><code>read(fd, buf, len)</code></li><li>vfs</li><li><code>sensor_read</code></li><li><code>fetch()</code></li></ol></blockquote><p>It is not advisable to use the fetch method to retrieve sensor data. When the caller invokes read, accessing the bus to obtain data has two disadvantages: the bus speed is low, which may block the upper layer; and the retrieved data may be old and not representative of the current state.</p><p>When using the fetch function, the upper layer will automatically disable the circular buffer and can directly use the user-space buffer to store register data, reducing memory copy operations. When the character device node is opened in non-blocking mode, the fetch operation will directly read the registers via the I2C/SPI bus, and the poll operation will always succeed. When opened in blocking mode, if there is no ready data when read is called, the poll function can be used to monitor it. If a POLLIN event occurs, the read function should be called immediately to retrieve the data.</p><h3 id="interrupt-driven-retrieval" tabindex="-1"><strong>Interrupt-Driven Retrieval</strong> <a class="header-anchor" href="#interrupt-driven-retrieval" aria-label="Permalink to &quot;**Interrupt-Driven Retrieval**&quot;">​</a></h3><p>For sensors with hardware interrupts, sensor data can be read via the bus in the interrupt&#39;s bottom half, and the event can be pushed to the upper layer&#39;s circular buffer using <code>sensor_lowerhalf_s::push_event</code>. When using the internal circular buffer, data generated in each interrupt&#39;s bottom half is pushed to the upper layer&#39;s circular buffer. Upper-layer applications read data directly from the buffer. When the buffer has no data, it will depend on the blocking flag in f_oflags to determine whether to wait. Common sensors operate in interrupt mode. When an interrupt occurs, a worker is scheduled to start the bottom half, which then retrieves sensor data via buses such as I2C or SPI and calls the push_event interface to push the data to the upper half&#39;s buffer. It is recommended to configure an interrupt pin for sensors with a sampling rate higher than 25Hz.</p><h3 id="polling-retrieval" tabindex="-1"><strong>Polling Retrieval</strong> <a class="header-anchor" href="#polling-retrieval" aria-label="Permalink to &quot;**Polling Retrieval**&quot;">​</a></h3><p>For sensors without hardware interrupts, data generated by the sensor can be collected through periodic polling, with the polling period typically varying based on the sampling rate.</p><h2 id="implemented-drivers" tabindex="-1">Implemented Drivers <a class="header-anchor" href="#implemented-drivers" aria-label="Permalink to &quot;Implemented Drivers&quot;">​</a></h2><ul><li>[[adxl362]{.title-ref}]([adxl362]{.title-ref}.md)</li><li>[[adxl372]{.title-ref}]([adxl372]{.title-ref}.md)</li><li>bh1749nuc</li><li>bme680</li><li>bmi088</li><li>bmi160</li><li>bmi270</li><li>bmm150</li><li>bmp180</li><li>bmp280</li><li>ds18b20</li><li>fakesensor</li><li>fs3000</li><li>gnss</li><li>goldfish_gnss</li><li>goldfish_sensor</li><li>hyt271</li><li>l3gd20</li><li class="title-ref">[[li](\`li.md)s2mdl]</li><li>lsm9ds1</li><li>ltr308</li><li>mpu9250</li><li>ms56xx</li><li>[[nau7802]{.title-ref}]([nau7802]{.title-ref}.md)</li><li>[[](]{.title-ref}.md)sht4x\`</li><li class="title-ref">[[l](\`l.md)sm6dso32]</li><li>wtgahrs2</li></ul>`,103)]))}const f=s(r,[["render",o]]);export{g as __pageData,f as default};
