import{_ as t,c as a,al as i,o}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"ATM64 MTE extension","description":"","frontmatter":{},"headers":[],"relativePath":"en/debugging/mte.md","filePath":"en/debugging/mte.md"}'),r={name:"en/debugging/mte.md"};function n(s,e,d,h,c,l){return o(),a("div",null,e[0]||(e[0]=[i(`<h1 id="atm64-mte-extension" tabindex="-1">ATM64 MTE extension <a class="header-anchor" href="#atm64-mte-extension" aria-label="Permalink to &quot;ATM64 MTE extension&quot;">​</a></h1><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">​</a></h2><p>Arm v8.5 introduced the Arm Memory Tagging Extension (MTE), a hardware implementation of tagged memory.</p><p>Basically, MTE tags every memory allocation/deallocation with additional metadata. It assigns a tag to a memory location, which can then be associated with a pointer that references that memory location. At runtime, the CPU checks that the pointer and metadata tags match with every load and store.</p><p>NX OS currently supports deploying MTE on ARM64 QEMU, which is supported at the EL1 level of NX OS.</p><h2 id="principle" tabindex="-1">Principle <a class="header-anchor" href="#principle" aria-label="Permalink to &quot;Principle&quot;">​</a></h2><p>The Arm Memory Tagging Extension implements lock and key access to memory. Locks can be set on memory and keys provided during memory access. If the key matches the lock, the access is permitted. If it does not match, an error is reported.</p><p>Memory locations are tagged by adding four bits of metadata to each 16 bytes of physical memory. This is the Tag Granule. Tagging memory implements the lock. Pointers, and therefore virtual addresses, are modified to contain the key. In order to implement the key bits without requiring larger pointers MTE uses the Top Byte Ignore (TBI) feature of the Armv8-A Architecture. When TBI is enabled, the top byte of a virtual address is ignored when using it as an input for address translation. This allows the top byte to store metadata. In MTE four bits of the top byte are used to provide the key</p><h2 id="architectural-details" tabindex="-1">Architectural Details <a class="header-anchor" href="#architectural-details" aria-label="Permalink to &quot;Architectural Details&quot;">​</a></h2><p>MTE adds instructions to the Armv8-A Architecture that are outlined below and grouped into three different categories [6]: Instructions for tag manipulation applicable to stack and heap tagging.</p><p>IRG In order for the statistical basis of MTE to be valid, a source of random tags is required. IRG is defined to provide this in hardware and insert such a tag into a register for use by other instructions.</p><p>GMI This instruction is for manipulating the excluded set of tags for use with the IRG instruction. This is intended for cases where software uses specific tag values for special purposes while retaining random tag behavior for normal allocations.</p><p>LDG, STG, and STZG These instructions allow getting or setting tags in memory. They are intended for changing tags in memory either without modifying the data or zeroing the data.</p><p>ST2G and STZ2G These are denser alternatives to STG and STZG which operate on two granules of memory when allocation size allows them to be used.</p><p>STGP This instruction stores both tag and data to memory. Instructions Intended for pointer arithmetic and stack tagging:</p><p>ADDG and SUBG These are variants of the ADD and SUB instructions, intended for arithmetic on addresses. They allow both the tag and address to be separately modified by an immediate value. These instructions are intended for creating the addresses of objects on the stack.</p><p>SUBP(S) This instruction provides a 56-bit subtract with optional flag setting which is required for pointer arithmetic that ignores the tag in the top byte.</p><p>Instructions intended for system use: LDGM, STGM, and STZGM These are bulk tag manipulation instructions which are UNDEFINED at EL0. These are intended for system software to manipulate tags for the purposes of initialization and serialization. For example, they can be used to implement swapping of tagged memory to a medium which is not tag-aware. The zeroing form can be used for efficient initialization of memory.</p><p>Currently NX OS supports the execution of the above instructions, such as irg, ldg, stg instructions. Their test programs are stored in &quot;apps/system/mte&quot; to test whether the current system supports</p><h2 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to &quot;Usage&quot;">​</a></h2><p>If you want to experience the MTE function of NX OS, you can refer to the following： To enable ARM64_MTE, configure the kernel with:</p><pre><code>CONFIG_ARM64_MTE=y
</code></pre><p>Of course you can also run it with the existing configuration：</p><blockquote><p>boards/arm64/qemu/qemu-armv8a/configs/mte</p></blockquote>`,24)]))}const u=t(r,[["render",n]]);export{m as __pageData,u as default};
