import{_ as r,c as o,j as e,a,al as n,o as i}from"./chunks/framework.NFAqBSgQ.js";const b=JSON.parse('{"title":"Board IOCTL","description":"","frontmatter":{},"headers":[],"relativePath":"en/reference/user/13_boardctl.md","filePath":"en/reference/user/13_boardctl.md"}'),l={name:"en/reference/user/13_boardctl.md"};function c(s,t,d,h,m,p){return i(),o("div",null,t[0]||(t[0]=[e("h1",{id:"board-ioctl",tabindex:"-1"},[a("Board IOCTL "),e("a",{class:"header-anchor",href:"#board-ioctl","aria-label":'Permalink to "Board IOCTL"'},"​")],-1),e("p",null,[a("In a small embedded system, there will typically be a much greater interaction between application and low-level board features. The canonically correct to implement such interactions is by implementing a character driver and performing the interactions via low level "),e("code",null,"ioctl()"),a(' calls. This, however, may not be practical in many cases and will lead to "correct" but awkward implementations.')],-1),e("p",null,[a(":c"),e("code",{class:"interpreted-text",role:"func"},"boardctl"),a(" is non-standard OS interface to alleviate the problem. It basically circumvents the normal device driver "),e("code",null,"ioctl()"),a(" interface and allows the application to perform direct IOCTL-like calls to the board-specific logic. It is especially useful for setting up board operational and test configurations.")],-1),e("p",null,[a(":c"),e("code",{class:"interpreted-text",role:"func"},"boardctl"),a(" is an application interface to the OS. There is no point, in fact, of using :c"),e("code",{class:"interpreted-text",role:"func"},"boardctl"),a(" within the OS; the board interfaces prototyped in "),e("code",null,"include/nuttx/board.h"),a('{.interpreted-text role="file"} may be called directly from within the OS.')],-1),e("h2",{id:"supported-commands",tabindex:"-1"},[a("Supported commands "),e("a",{class:"header-anchor",href:"#supported-commands","aria-label":'Permalink to "Supported commands"'},"​")],-1),e("p",null,[a("The following is the list of supported :c"),e("code",null,"boardctl"),a('{.interpreted-text role="func"} commands. Besides this list, board logic can implement handling of custom commands by implementing the :c'),e("code",{class:"interpreted-text",role:"func"},"board_ioctl"),a(" interface.")],-1),n('<h3 id="system-state-control" tabindex="-1">System state control <a class="header-anchor" href="#system-state-control" aria-label="Permalink to &quot;System state control&quot;">​</a></h3><h3 id="power-management" tabindex="-1">Power Management <a class="header-anchor" href="#power-management" aria-label="Permalink to &quot;Power Management&quot;">​</a></h3><h3 id="board-information" tabindex="-1">Board information <a class="header-anchor" href="#board-information" aria-label="Permalink to &quot;Board information&quot;">​</a></h3><h3 id="filesystems" tabindex="-1">Filesystems <a class="header-anchor" href="#filesystems" aria-label="Permalink to &quot;Filesystems&quot;">​</a></h3><h3 id="symbol-handling" tabindex="-1">Symbol Handling <a class="header-anchor" href="#symbol-handling" aria-label="Permalink to &quot;Symbol Handling&quot;">​</a></h3><h3 id="usb" tabindex="-1">USB <a class="header-anchor" href="#usb" aria-label="Permalink to &quot;USB&quot;">​</a></h3><h3 id="graphics" tabindex="-1">Graphics <a class="header-anchor" href="#graphics" aria-label="Permalink to &quot;Graphics&quot;">​</a></h3><h3 id="testing" tabindex="-1">Testing <a class="header-anchor" href="#testing" aria-label="Permalink to &quot;Testing&quot;">​</a></h3>',8)]))}const f=r(l,[["render",c]]);export{b as __pageData,f as default};
