import{_ as t,c as o,al as a,o as r}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Microchip AT90USB","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/avr/at90usb/index.md","filePath":"en/platforms/avr/at90usb/index.md"}'),s={name:"en/platforms/avr/at90usb/index.md"};function i(n,e,d,l,c,p){return r(),o("div",null,e[0]||(e[0]=[a('<h1 id="microchip-at90usb" tabindex="-1">Microchip AT90USB <a class="header-anchor" href="#microchip-at90usb" aria-label="Permalink to &quot;Microchip AT90USB&quot;">​</a></h1><h2 id="avr-at90usb64x-and-at90usb6128x" tabindex="-1">AVR AT90USB64x and AT90USB6128x <a class="header-anchor" href="#avr-at90usb64x-and-at90usb6128x" aria-label="Permalink to &quot;AVR AT90USB64x and AT90USB6128x&quot;">​</a></h2><p><strong>Micropendous 3 AT90USB64x</strong> and <strong>AT90USB6128x</strong>. This port of NuttX to the Opendous Micropendous 3 board. The Micropendous3 is may be populated with an AT90USB646, 647, 1286, or 1287. I have only the AT90USB647 version for testing. This version have very limited memory resources: 64K of FLASH and 4K of SRAM.</p><p><strong>PJRC Teensy++ 2.0 AT90USB1286</strong>. This is a port of NuttX to the PJRC Teensy++ 2.0 board. This board was developed by <a href="http://pjrc.com/teensy/" target="_blank" rel="noreferrer">PJRC</a>. The Teensy++ 2.0 is based on an Microchip AT90USB1286 MCU.</p><p><strong>AVR-Specific Issues</strong>. The basic AVR port is solid. The biggest issue for using AVR is its tiny SRAM memory and its Harvard architecture. Because of the Harvard architecture, constant data that resides to flash is inaccessible using &quot;normal&quot; memory reads and writes (only SRAM data can be accessed &quot;normally&quot;). Special AVR instructions are available for accessing data in FLASH, but these have not been integrated into the normal, general purpose OS.</p><p>Most NuttX test applications are console-oriented with lots of strings used for <code>printf()</code> and debug output. These strings are all stored in SRAM now due to these data accessing issues and even the smallest console-oriented applications can quickly fill a 4-8K memory. So, in order for the AVR port to be useful, one of two things would need to be done:</p><ol><li>Don&#39;t use console applications that required lots of strings. The basic AVR port is solid and your typical deeply embedded application should work fine. Or,</li><li>Create a special version of printf that knows how to access strings that reside in FLASH (or EEPROM).</li></ol><p><strong>Development Environments:</strong> 1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU toolchain, 3) Cygwin/MSYS with Windows native toolchain, or 4) Native Windows. All testing, however, has been performed using the NuttX DIY toolchain for Linux or Cygwin is provided by the NuttX <a href="https://bitbucket.org/nuttx/buildroot/downloads/" target="_blank" rel="noreferrer">buildroot</a> package. As a result, that toolchain is recommended.</p><h3 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h3><blockquote><p>boards/<em>/</em></p></blockquote>',10)]))}const b=t(s,[["render",i]]);export{u as __pageData,b as default};
