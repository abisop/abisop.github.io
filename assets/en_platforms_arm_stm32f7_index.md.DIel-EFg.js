import{_ as a,c as n,al as o,j as e,a as t,o as r}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"ST STM32F7","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/stm32f7/index.md","filePath":"en/platforms/arm/stm32f7/index.md"}'),s={name:"en/platforms/arm/stm32f7/index.md"};function l(d,i,h,u,p,c){return r(),n("div",null,i[0]||(i[0]=[o(`<h1 id="st-stm32f7" tabindex="-1">ST STM32F7 <a class="header-anchor" href="#st-stm32f7" aria-label="Permalink to &quot;ST STM32F7&quot;">​</a></h1><h2 id="supported-mcus" tabindex="-1">Supported MCUs <a class="header-anchor" href="#supported-mcus" aria-label="Permalink to &quot;Supported MCUs&quot;">​</a></h2><p>TODO</p><h2 id="peripheral-support" tabindex="-1">Peripheral Support <a class="header-anchor" href="#peripheral-support" aria-label="Permalink to &quot;Peripheral Support&quot;">​</a></h2><p>The following list indicates peripherals supported in NuttX:</p><p>Peripheral Support Notes</p><hr><p>FLASH PM RCC GPIO SYSCFG DMA DMA2D EXTI CRC FMC QUADSPI ADC DAC DFSDM DCMI LTDC DSI JPEG RNG CRYP HASH TIM LPTIM IWDG WWDG RTC I2C USART SPI I2S SAI SPIDIFRX MDIOS SDMMC CAN OTG_FS OTG_HS ETH HDMI_CEC Yes ? Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes Yes No No Yes No No Yes No ? Yes No Yes Yes Yes Yes Yes Yes ? No No ? Yes Yes Yes Yes Yes No</p><h3 id="porting-stm32-f4-drivers" tabindex="-1">Porting STM32 F4 Drivers <a class="header-anchor" href="#porting-stm32-f4-drivers" aria-label="Permalink to &quot;Porting STM32 F4 Drivers&quot;">​</a></h3><p>The STM32F746 is very similar to the STM32 F429 and many of the drivers in the stm32/ directory could be ported here: ADC, BBSRAM, CAN, DAC, DMA2D, FLASH, I2C, IWDG, LSE, LSI, LTDC, OTGFS, OTGHS, PM, Quadrature Encoder, RNG, RTCC, SDMMC (was SDIO), Timer/counters, and WWDG.</p><p>Many of these drivers would be ported very simply; many ports would just be a matter of copying files and some seach-and-replacement. Like:</p><ol><li>Compare the two register definitions files; make sure that the STM32 F4 peripheral is identical (or nearly identical) to the F7 peripheral. If so then,</li><li>Copy the register definition file from the stm32/chip directory to the stm32f7/chip directory, making name changes as appropriate and updating the driver for any minor register differences.</li><li>Copy the corresponding C file (and possibly a matching .h file) from the stm32/ directory to the stm32f7/ directory again with naming changes and changes for any register differences.</li><li>Update the Make.defs file to include the new C file in the build.</li></ol><p>For other files, particularly those that use DMA, the port will be significantly more complex. That is because the STM32F7 has a D-Cache and, as a result, we need to exercise much more care to maintain cache coherency. There is a Wiki page discussing the issues of porting drivers from the stm32/ to the stm32f7/ directories here: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Porting+Drivers+to+the+STM32+F7" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Porting+Drivers+to+the+STM32+F7</a></p><h3 id="memory" tabindex="-1">Memory <a class="header-anchor" href="#memory" aria-label="Permalink to &quot;Memory&quot;">​</a></h3><ul><li>CONFIG_RAM_SIZE - Describes the installed DRAM (SRAM in this case)</li><li>CONFIG_RAM_START - The start address of installed SRAM (SRAM1)</li></ul><p>This configurations use only SRAM1 for data storage. The heap includes the remainder of SRAM1. If CONFIG_MM_REGIONS=2, then SRAM2 will be included in the heap.</p><p>DTCM SRAM is never included in the heap because it cannot be used for DMA. A DTCM allocator is available, however, so that DTCM can be managed with dtcm_malloc(), dtcm_free(), etc.</p><p>In order to use FMC SRAM, the following additional things need to be present in the NuttX configuration file:</p><ul><li>CONFIG_STM32F7_FMC_SRAM - Indicates that SRAM is available via the FMC (as opposed to an LCD or FLASH).</li><li>CONFIG_HEAP2_BASE - The base address of the SRAM in the FMC address space (hex)</li><li>CONFIG_HEAP2_SIZE - The size of the SRAM in the FMC address space (decimal)</li><li>CONFIG_ARCH_INTERRUPTSTACK - This architecture supports an interrupt stack. If defined, this symbol is the size of the interrupt stack in bytes. If not defined, the user task stacks will be used during interrupt handling.</li><li>CONFIG_ARCH_STACKDUMP - Do stack dumps after assertions</li></ul><h3 id="clock" tabindex="-1">Clock <a class="header-anchor" href="#clock" aria-label="Permalink to &quot;Clock&quot;">​</a></h3><ul><li><p>CONFIG_ARCH_BOARD_STM32F7_CUSTOM_CLOCKCONFIG - Enables special STM32F7 clock configuration features.:</p><pre><code>CONFIG_ARCH_BOARD_STM32F7_CUSTOM_CLOCKCONFIG=n
</code></pre></li><li><p>CONFIG_ARCH_LOOPSPERMSEC - Must be calibrated for correct operation of delay loops</p></li></ul><h3 id="timers" tabindex="-1">Timers <a class="header-anchor" href="#timers" aria-label="Permalink to &quot;Timers&quot;">​</a></h3><p>Timer devices may be used for different purposes. One special purpose is to generate modulated outputs for such things as motor control. If CONFIG_STM32F7_TIMn is defined (as above) then the following may also be defined to indicate that the timer is intended to be used for pulsed output modulation, ADC conversion, or DAC conversion. Note that ADC/DAC require two definition: Not only do you have to assign the timer (n) for used by the ADC or DAC, but then you also have to configure which ADC or DAC (m) it is assigned to.:</p><ul><li>CONFIG_STM32F7_TIMn_PWM Reserve timer n for use by PWM, n=1,..,14</li><li>CONFIG_STM32F7_TIMn_ADC Reserve timer n for use by ADC, n=1,..,14</li><li>CONFIG_STM32F7_TIMn_ADCm Reserve timer n to trigger ADCm, n=1,..,14, m=1,..,3</li><li>CONFIG_STM32F7_TIMn_DAC Reserve timer n for use by DAC, n=1,..,14</li><li>CONFIG_STM32F7_TIMn_DACm Reserve timer n to trigger DACm, n=1,..,14, m=1,..,2</li></ul><p>For each timer that is enabled for PWM usage, we need the following additional configuration settings:</p>`,25),e("ul",{"1,..,4":""},[e("li",null,"CONFIG_STM32F7_TIMx_CHANNEL - Specifies the timer output channel")],-1),o(`<p>NOTE: The STM32 timers are each capable of generating different signals on each of the four channels with different duty cycles. That capability is not supported by this driver: Only one output channel per timer.</p><h3 id="jtag" tabindex="-1">JTAG <a class="header-anchor" href="#jtag" aria-label="Permalink to &quot;JTAG&quot;">​</a></h3><h3 id="usart" tabindex="-1">USART <a class="header-anchor" href="#usart" aria-label="Permalink to &quot;USART&quot;">​</a></h3><p>Options:</p><ul><li>CONFIG_U[S]ARTn_SERIAL_CONSOLE - selects the USARTn (n=1,2,3) or UARTm (m=4,5) for the console and ttys0 (default is the USART1).</li><li>CONFIG_U[S]ARTn_RXBUFSIZE - Characters are buffered as received. This specific the size of the receive buffer</li><li>CONFIG_U[S]ARTn_TXBUFSIZE - Characters are buffered before being sent. This specific the size of the transmit buffer</li><li>CONFIG_U[S]ARTn_BAUD - The configure BAUD of the UART. Must be</li><li>CONFIG_U[S]ARTn_BITS - The number of bits. Must be either 7 or 8.</li><li>CONFIG_U[S]ARTn_PARTIY - 0=no parity, 1=odd parity, 2=even parity</li><li>CONFIG_U[S]ARTn_2STOP - Two stop bits</li></ul><h3 id="can" tabindex="-1">CAN <a class="header-anchor" href="#can" aria-label="Permalink to &quot;CAN&quot;">​</a></h3><ul><li>CONFIG_CAN - Enables CAN support (one or both of CONFIG_STM32F7F7_CAN1 or CONFIG_STM32F7F7_CAN2 must also be defined)</li><li>CONFIG_CAN_EXTID - Enables support for the 29-bit extended ID. Default Standard 11-bit IDs.</li><li>CONFIG_CAN_TXFIFOSIZE - The size of the circular tx buffer of CAN messages. Default: 8</li><li>CONFIG_CAN_RXFIFOSIZE - The size of the circular rx buffer of CAN messages. Default: 8</li><li>CONFIG_CAN_NPENDINGRTR - The size of the list of pending RTR requests. Default: 4</li><li>CONFIG_CAN_LOOPBACK - A CAN driver may or may not support a loopback mode for testing. The STM32F7 CAN driver does support loopback mode.</li><li>CONFIG_STM32F7F7_CAN1_BAUD - CAN1 BAUD rate. Required if CONFIG_STM32F7F7_CAN1 is defined.</li><li>CONFIG_STM32F7F7_CAN2_BAUD - CAN1 BAUD rate. Required if CONFIG_STM32F7F7_CAN2 is defined.</li><li>CONFIG_STM32F7_CAN_TSEG1 - The number of CAN time quanta in segment 1. Default: 6</li><li>CONFIG_STM32F7_CAN_TSEG2 - the number of CAN time quanta in segment 2. Default: 7</li><li>CONFIG_STM32F7_CAN_REGDEBUG - If CONFIG_DEBUG_FEATURES is set, this will generate an dump of all CAN registers.</li></ul><h3 id="can-socketcan" tabindex="-1">CAN SocketCAN <a class="header-anchor" href="#can-socketcan" aria-label="Permalink to &quot;CAN SocketCAN&quot;">​</a></h3><p>TODO</p><h3 id="spi" tabindex="-1">SPI <a class="header-anchor" href="#spi" aria-label="Permalink to &quot;SPI&quot;">​</a></h3><ul><li>CONFIG_STM32F7_SPI_INTERRUPTS - Select to enable interrupt driven SPI support. Non-interrupt-driven, poll-waiting is recommended if the interrupt rate would be to high in the interrupt driven case.</li><li>CONFIG_STM32F7_SPIx_DMA - Use DMA to improve SPIx transfer performance. Cannot be used with CONFIG_STM32F7_SPI_INTERRUPT.</li></ul><h3 id="sdio" tabindex="-1">SDIO <a class="header-anchor" href="#sdio" aria-label="Permalink to &quot;SDIO&quot;">​</a></h3><p>TODO</p><h3 id="eth" tabindex="-1">ETH <a class="header-anchor" href="#eth" aria-label="Permalink to &quot;ETH&quot;">​</a></h3><p>Options:</p><ul><li>CONFIG_STM32F7_PHYADDR - The 5-bit address of the PHY on the board</li><li>CONFIG_STM32F7_MII - Support Ethernet MII interface</li><li>CONFIG_STM32F7_MII_MCO1 - Use MCO1 to clock the MII interface</li><li>CONFIG_STM32F7_MII_MCO2 - Use MCO2 to clock the MII interface</li><li>CONFIG_STM32F7_RMII - Support Ethernet RMII interface</li><li>CONFIG_STM32F7_AUTONEG - Use PHY autonegotiation to determine speed and mode</li><li>CONFIG_STM32F7_ETHFD - If CONFIG_STM32F7_AUTONEG is not defined, then this may be defined to select full duplex mode. Default: half-duplex</li><li>CONFIG_STM32F7_ETH100MBPS - If CONFIG_STM32F7_AUTONEG is not defined, then this may be defined to select 100 MBps speed. Default: 10 Mbps</li><li>CONFIG_STM32F7_PHYSR - This must be provided if CONFIG_STM32F7_AUTONEG is defined. The PHY status register address may diff from PHY to PHY. This configuration sets the address of the PHY status register.</li><li>CONFIG_STM32F7_PHYSR_SPEED - This must be provided if CONFIG_STM32F7_AUTONEG is defined. This provides bit mask indicating 10 or 100MBps speed.</li><li>CONFIG_STM32F7_PHYSR_100MBPS - This must be provided if CONFIG_STM32F7_AUTONEG is defined. This provides the value of the speed bit(s) indicating 100MBps speed.</li><li>CONFIG_STM32F7_PHYSR_MODE - This must be provided if CONFIG_STM32F7_AUTONEG is defined. This provide bit mask indicating full or half duplex modes.</li><li>CONFIG_STM32F7_PHYSR_FULLDUPLEX - This must be provided if CONFIG_STM32F7_AUTONEG is defined. This provides the value of the mode bits indicating full duplex mode.</li><li>CONFIG_STM32F7_ETH_PTP - Precision Time Protocol (PTP). Not supported but some hooks are indicated with this condition.</li></ul><h3 id="usb-otg-fs" tabindex="-1">USB OTG FS <a class="header-anchor" href="#usb-otg-fs" aria-label="Permalink to &quot;USB OTG FS&quot;">​</a></h3><p>STM32 USB OTG FS Host Driver Support</p><p>Pre-requisites:</p><ul><li>CONFIG_USBDEV - Enable USB device support</li><li>CONFIG_USBHOST - Enable USB host support</li><li>CONFIG_STM32F7_OTGFS - Enable the STM32 USB OTG FS block</li><li>CONFIG_STM32F7_SYSCFG - Needed</li><li>CONFIG_SCHED_WORKQUEUE - Worker thread support is required</li></ul><p>Options:</p><ul><li>CONFIG_STM32F7_OTGFS_RXFIFO_SIZE - Size of the RX FIFO in 32-bit words. Default 128 (512 bytes)</li><li>CONFIG_STM32F7_OTGFS_NPTXFIFO_SIZE - Size of the non-periodic Tx FIFO in 32-bit words. Default 96 (384 bytes)</li><li>CONFIG_STM32F7_OTGFS_PTXFIFO_SIZE - Size of the periodic Tx FIFO in 32-bit words. Default 96 (384 bytes)</li><li>CONFIG_STM32F7_OTGFS_DESCSIZE - Maximum size of a descriptor. Default: 128</li><li>CONFIG_STM32F7_OTGFS_SOFINTR - Enable SOF interrupts. Why would you ever want to do that?</li><li>CONFIG_STM32F7_USBHOST_REGDEBUG - Enable very low-level register access debug. Depends on CONFIG_DEBUG_FEATURES.</li><li>CONFIG_STM32F7_USBHOST_PKTDUMP - Dump all incoming and outgoing USB packets. Depends on CONFIG_DEBUG_FEATURES.</li></ul><h3 id="usb-otg-hs" tabindex="-1">USB OTG HS <a class="header-anchor" href="#usb-otg-hs" aria-label="Permalink to &quot;USB OTG HS&quot;">​</a></h3><p>TODO</p><h2 id="fpu" tabindex="-1">FPU <a class="header-anchor" href="#fpu" aria-label="Permalink to &quot;FPU&quot;">​</a></h2><h3 id="fpu-configuration-options" tabindex="-1">FPU Configuration Options <a class="header-anchor" href="#fpu-configuration-options" aria-label="Permalink to &quot;FPU Configuration Options&quot;">​</a></h3><p>There are two version of the FPU support built into the STM32 port.</p><ol><li><p>Non-Lazy Floating Point Register Save</p><p>In this configuration floating point register save and restore is implemented on interrupt entry and return, respectively. In this case, you may use floating point operations for interrupt handling logic if necessary. This FPU behavior logic is enabled by default with:</p><pre><code>CONFIG_ARCH_FPU=y
</code></pre></li><li><p>Lazy Floating Point Register Save.</p><p>An alternative mplementation only saves and restores FPU registers only on context switches. This means: (1) floating point registers are not stored on each context switch and, hence, possibly better interrupt performance. But, (2) since floating point registers are not saved, you cannot use floating point operations within interrupt handlers.</p><p>This logic can be enabled by simply adding the following to your .config file:</p><pre><code>CONFIG_ARCH_FPU=y
</code></pre></li></ol><h2 id="spi-test" tabindex="-1">SPI Test <a class="header-anchor" href="#spi-test" aria-label="Permalink to &quot;SPI Test&quot;">​</a></h2><p>Available for some Nucleo boards.</p><p>The builtin SPI test facility can be enabled with the following settings:</p><pre><code>+CONFIG_STM32F7_SPI=y
+CONFIG_STM32F7_SPI1=y
+CONFIG_STM32F7_SPI2=y
+CONFIG_STM32F7_SPI3=y

+# CONFIG_STM32F7_SPI_INTERRUPTS is not set
+# CONFIG_STM32F7_SPI1_DMA is not set
+# CONFIG_STM32F7_SPI2_DMA is not set
+# CONFIG_STM32F7_SPI3_DMA is not set
 # CONFIG_STM32F7_CUSTOM_CLOCKCONFIG is not set

+CONFIG_NUCLEO_SPI_TEST=y
+CONFIG_NUCLEO_SPI_TEST_MESSAGE=&quot;Hello World&quot;
+CONFIG_NUCLEO_SPI1_TEST=y
+CONFIG_NUCLEO_SPI1_TEST_FREQ=1000000
+CONFIG_NUCLEO_SPI1_TEST_BITS=8
+CONFIG_NUCLEO_SPI1_TEST_MODE3=y

+CONFIG_NUCLEO_SPI2_TEST=y
+CONFIG_NUCLEO_SPI2_TEST_FREQ=12000000
+CONFIG_NUCLEO_SPI2_TEST_BITS=8
+CONFIG_NUCLEO_SPI2_TEST_MODE3=y

+CONFIG_NUCLEO_SPI3_TEST=y
+CONFIG_NUCLEO_SPI3_TEST_FREQ=40000000
+CONFIG_NUCLEO_SPI3_TEST_BITS=8
+CONFIG_NUCLEO_SPI3_TEST_MODE3=y

+CONFIG_BOARDCTL=y
+CONFIG_NSH_ARCHINIT=y
</code></pre><h2 id="development-environment" tabindex="-1">Development Environment <a class="header-anchor" href="#development-environment" aria-label="Permalink to &quot;Development Environment&quot;">​</a></h2><p>Either Linux or Cygwin on Windows can be used for the development environment. The source has been built only using the GNU toolchain (see below). Other toolchains will likely cause problems.</p><p>All testing has been conducted using the GNU toolchain from ARM for Linux. found here <a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/4.9/4.9-2015-q3-update/+download/gcc-arm-none-eabi-4_9-2015q3-20150921-linux.tar.bz2" target="_blank" rel="noreferrer">https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/4.9/4.9-2015-q3-update/+download/gcc-arm-none-eabi-4_9-2015q3-20150921-linux.tar.bz2</a></p><p>If you change the default toolchain, then you may also have to modify the PATH environment variable to include the path to the toolchain binaries.</p><h2 id="ides" tabindex="-1">IDEs <a class="header-anchor" href="#ides" aria-label="Permalink to &quot;IDEs&quot;">​</a></h2><p>NuttX is built using command-line make. It can be used with an IDE, but some effort will be required to create the project.</p><h3 id="makefile-build" tabindex="-1">Makefile Build <a class="header-anchor" href="#makefile-build" aria-label="Permalink to &quot;Makefile Build&quot;">​</a></h3><p>Under Eclipse, it is pretty easy to set up an &quot;empty makefile project&quot; and simply use the NuttX makefile to build the system. That is almost for free under Linux. Under Windows, you will need to set up the &quot;Cygwin GCC&quot; empty makefile project in order to work with Windows (Google for &quot;Eclipse Cygwin&quot; -there is a lot of help on the internet).</p><h2 id="basic-configuration-build-steps" tabindex="-1">Basic configuration &amp; build steps <a class="header-anchor" href="#basic-configuration-build-steps" aria-label="Permalink to &quot;Basic configuration &amp; build steps&quot;">​</a></h2><p>A GNU GCC-based toolchain is assumed. The PATH environment variable should be modified to point to the correct path to the Cortex-M7 GCC toolchain (if different from the default in your PATH variable).</p><ul><li><p>Configures nuttx creating .config file in the nuttx directory.:</p><pre><code> tools/configure.sh nucleo-f746zg:nsh
</code></pre></li><li><p>Refreshes the .config file with the latest available configurations.:</p><pre><code> make oldconfig
</code></pre></li><li><p>Select the features you want in the build.:</p><pre><code> make menuconfig
</code></pre></li><li><p>Builds NuttX with the features you selected.:</p><pre><code> make
</code></pre></li></ul><h2 id="flashing-and-debugging" tabindex="-1">Flashing and Debugging <a class="header-anchor" href="#flashing-and-debugging" aria-label="Permalink to &quot;Flashing and Debugging&quot;">​</a></h2><p>NuttX firmware Flashing with STLink probe and OpenOCD:</p><pre><code>openocd -f  interface/stlink.cfg -f target/stm32f7x.cfg -c &#39;program nuttx.bin 0x08000000; reset run; exit&#39;
</code></pre><p>Remote target Reset with STLink probe and OpenOCD:</p><pre><code>openocd -f interface/stlink.cfg -f target/stm32f7x.cfg -c &#39;init; reset run; exit&#39;
</code></pre><p>Remote target Debug with STLink probe and OpenOCD:</p>`,49),e("blockquote",null,[e("ol",null,[e("li",null,[e("p",null,[t("You need to have NuttX built with debug symbols, see "),e("code",{class:"interpreted-text",role:"ref"},"debugging"),t(".")])]),e("li",null,[e("p",null,"Launch the OpenOCD GDB server:"),e("pre",null,[e("code",null,`openocd -f interface/stlink.cfg -f target/stm32f7x.cfg -c 'init; reset halt'
`)])]),e("li",null,[e("p",null,"You can now attach to remote OpenOCD GDB server with your favorite debugger, for instance gdb:"),e("pre",null,[e("code",null,`arm-none-eabi-gdb --tui nuttx -ex 'target extended-remote localhost:3333'
(gdb) monitor reset halt
(gdb) breakpoint nsh_main
(gdb) continue
`)])])])],-1),e("h2",{id:"supported-boards",tabindex:"-1"},[t("Supported Boards "),e("a",{class:"header-anchor",href:"#supported-boards","aria-label":'Permalink to "Supported Boards"'},"​")],-1),e("blockquote",null,[e("p",null,[t("boards/"),e("em",null,"/")])],-1)]))}const T=a(s,[["render",l]]);export{f as __pageData,T as default};
