import{_ as a,c as t,al as s,o as i}from"./chunks/framework.NFAqBSgQ.js";const h=JSON.parse('{"title":"Syscall Layer","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/syscall.md","filePath":"en/components/syscall.md"}'),n={name:"en/components/syscall.md"};function o(l,e,r,c,p,d){return i(),t("div",null,e[0]||(e[0]=[s('<h1 id="syscall-layer" tabindex="-1">Syscall Layer <a class="header-anchor" href="#syscall-layer" aria-label="Permalink to &quot;Syscall Layer&quot;">​</a></h1><p>This page discusses supports a syscall layer from communication between a monolithic, kernel-mode NuttX kernel and a separately built, user-mode application set.</p><p>With most MCUs, NuttX is built as a flat, single executable image containing the NuttX RTOS along with all application code. The RTOS code and the application run in the same address space and at the same kernel-mode privileges. In order to exploit security features of certain processors, an alternative build model is also supported: NuttX can be built separately as a monolithic, kernel-mode module and the applications can be added as a separately built, user-mode module.</p><p>The syscall layer provided in this directory serves as the communication layer from the user-mode application into the kernel-mode RTOS. The switch from user-mode to kernel-mode is accomplished using software interrupts (SWIs). SWIs are implemented differently and named differently by different manufacturers but all work essentially the same: A special instruction is executed in user-mode that causes a software generated interrupt. The software generated interrupt is caught within the kernel and handle in kernel-mode.</p><h2 id="header-files" tabindex="-1">Header Files <a class="header-anchor" href="#header-files" aria-label="Permalink to &quot;Header Files&quot;">​</a></h2><h3 id="include-syscall-h" tabindex="-1"><code>include/syscall.h</code> <a class="header-anchor" href="#include-syscall-h" aria-label="Permalink to &quot;`include/syscall.h`&quot;">​</a></h3><p>This header file supports general access to SWI facilities. It is simply a wrapper file that includes <code>include/sys/syscall.h</code> and <code>include/arch/syscall.h</code>.</p><h3 id="include-sys-syscall-h" tabindex="-1"><code>include/sys/syscall.h</code> <a class="header-anchor" href="#include-sys-syscall-h" aria-label="Permalink to &quot;`include/sys/syscall.h`&quot;">​</a></h3><p>The SWIs received by the kernel are distinguish by a code that identifies how to process the SWI. This header file defines all such codes understood by the NuttX kernel.</p><h3 id="include-arch-syscall-h-or-arch-cpu-include-syscall-h" tabindex="-1"><code>include/arch/syscall.h</code> (or <code>arch/&lt;cpu&gt;/include/syscall.h</code>) <a class="header-anchor" href="#include-arch-syscall-h-or-arch-cpu-include-syscall-h" aria-label="Permalink to &quot;`include/arch/syscall.h` (or `arch/&lt;cpu&gt;/include/syscall.h`)&quot;">​</a></h3><p>This header file is provided by the platform-specific logic and declares (or defines) the mechanism for providing software interrupts on this platform. The following functions must be declared (or defined) in this header file:</p><ul><li><p><code>SWI</code> with <code>SYS_</code> call number only:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uintptr_t sys_call0(unsigned int nbr);</span></span></code></pre></div></li><li><p><code>SWI</code> with <code>SYS_</code> call number and one parameter:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uintptr_t sys_call1(unsigned int nbr, uintptr_t parm1);</span></span></code></pre></div></li><li><p><code>SWI</code> with <code>SYS_</code> call number and two parameters:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uintptr_t sys_call2(unsigned int nbr, uintptr_t parm1, uintptr_t parm2);</span></span></code></pre></div></li><li><p><code>SWI</code> with <code>SYS_</code> call number and three parameters:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uintptr_t sys_call3(unsigned int nbr, uintptr_t parm1,</span></span>\n<span class="line"><span>                    uintptr_t parm2, uintptr_t parm3);</span></span></code></pre></div></li><li><p><code>SWI</code> with <code>SYS_</code> call number and four parameters:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uintptr_t sys_call4(unsigned int nbr, uintptr_t parm1, uintptr_t parm2,</span></span>\n<span class="line"><span>                    uintptr_t parm3, uintptr_t parm4);</span></span></code></pre></div></li><li><p><code>SWI</code> with <code>SYS_</code> call number and five parameters:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uintptr_t sys_call5(unsigned int nbr, uintptr_t parm1, uintptr_t parm2,</span></span>\n<span class="line"><span>                    uintptr_t parm3, uintptr_t parm4, uintptr_t parm5);</span></span></code></pre></div></li><li><p><code>SWI</code> with <code>SYS_</code> call number and six parameters:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>uintptr_t sys_call6(unsigned int nbr, uintptr_t parm1, uintptr_t parm2,</span></span>\n<span class="line"><span>                    uintptr_t parm3, uintptr_t parm4, uintptr_t parm5,</span></span>\n<span class="line"><span>                    uintptr_t parm6);</span></span></code></pre></div></li></ul><h3 id="syscall-database" tabindex="-1">Syscall Database <a class="header-anchor" href="#syscall-database" aria-label="Permalink to &quot;Syscall Database&quot;">​</a></h3><p>Sycall information is maintained in a database. That &quot;database&quot; is implemented as a simple comma-separated-value file, <code>syscall.csv</code>. Most spreadsheets programs will accept this format and can be used to maintain the syscall database.</p><p>The format of the CSV file for each line is:</p><ul><li>Field 1: Function name</li><li>Field 2: The header file that contains the function prototype</li><li>Field 3: Condition for compilation</li><li>Field 4: The type of function return value.</li><li>Field 5 - N+5: The type of each of the N formal parameters of the function</li><li>Fields N+5 - : If the last parameter is &quot;...&quot;, then the following fields provide the type and number of of possible optional parameters. See note below about variadic functions</li></ul><p>Each type field has a format as follows:</p><ul><li><p>type name:</p><p>For all simpler types</p></li><li><p>formal type | actual type:</p><p>For array types where the form of the formal (eg. <code>int parm[2]</code>) differs from the type of actual passed parameter (eg. <code>int*</code>). This is necessary because you cannot do simple casts to array types.</p></li><li><p>formal type | union member actual type | union member fieldname:</p><p>A similar situation exists for unions. For example, the formal parameter type union sigval -- You cannot cast a uintptr_t to a union sigval, but you can cast to the type of one of the union member types when passing the actual parameter. Similarly, we cannot cast a union sigval to a uinptr_t either. Rather, we need to cast a specific union member fieldname to <code>uintptr_t</code>.</p></li></ul><h2 id="variadic-functions" tabindex="-1">Variadic Functions <a class="header-anchor" href="#variadic-functions" aria-label="Permalink to &quot;Variadic Functions&quot;">​</a></h2><p>General variadic functions which may have an arbitrary number of argument or arbitrary types cannot be represented as system calls. <code>syslog()</code> is a good example. Normally you would work around this by using the non- variadic form of the OS interface that accepts a <code>va_list</code> as an argument, <code>vsyslog()</code> in this case.</p><p>There are many functions that have a variadic form but take only one or two optional arguments. There can be handled as system calls, but only by treating them as though they had a fixed number of arguments.</p><p>These are handled in <code>syscall.csv</code> by appending the number and type of optional arguments. For example, consider the <code>open()</code> OS interface. Its prototype is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int open(const char *path, int oflag, ...);</span></span></code></pre></div><p>In reality, open may take only a single optional argument of type <code>mode_t</code> and is represented in <code>syscall.csv</code> like this:</p><pre><code>&quot;open&quot;,&quot;fcntl.h&quot;,&quot;&quot;,&quot;int&quot;,&quot;const char*&quot;,&quot;int&quot;,&quot;...&quot;,&quot;mode_t&quot;\n</code></pre><p>The existence of the <code>mode_t</code> tells <code>tools/mksyscall</code> that there is at most one optional parameter and, if present, it is of type <code>mode_t</code>.</p><p>NOTE: This CSV file is used not only to support the generate of trap information, but also for the generation of symbol tables. See <code>Documentation/components/tools/</code> and <code>Documentation/components/libs/</code> for further information.</p><h2 id="auto-generated-files" tabindex="-1">Auto-Generated Files <a class="header-anchor" href="#auto-generated-files" aria-label="Permalink to &quot;Auto-Generated Files&quot;">​</a></h2><p>Stubs and proxies for the sycalls are automatically generated from this CSV database. Here the following definition is used:</p><ul><li>Proxy - A tiny bit of code that executes in the user space. A proxy has exactly the same function prototype as does the &quot;real&quot; function for which it proxies. However, it only serves to map the function call into a syscall, marshaling all of the system call parameters as necessary.</li><li>Stub - Another tiny bit of code that executes within the NuttX kernel that is used to map a software interrupt received by the kernel to a kernel function call. The stubs receive the marshaled system call data, and perform the actually kernel function call (in kernel-mode) on behalf of the proxy function.</li></ul><h2 id="sub-directories" tabindex="-1">Sub-Directories <a class="header-anchor" href="#sub-directories" aria-label="Permalink to &quot;Sub-Directories&quot;">​</a></h2><ul><li><code>stubs</code> - Autogenerated stub files are placed in this directory.</li><li><code>proxies</code> - Autogenerated proxy files are placed in this directory.</li></ul><h2 id="mksyscall" tabindex="-1">mksyscall <a class="header-anchor" href="#mksyscall" aria-label="Permalink to &quot;mksyscall&quot;">​</a></h2><p>mksyscall is C program that is used during the initial NuttX build by the logic in the top-level <code>syscall/</code> directory. Information about the stubs and proxies is maintained in a comma separated value (CSV) file in the <code>syscall/</code> directory. The mksyscall program will accept this CSV file as input and generate all of the required proxy or stub files as output. See <code>Documentation/components/tools/</code> for additional information.</p>',34)]))}const m=a(n,[["render",o]]);export{h as __pageData,m as default};
