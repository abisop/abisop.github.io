import{_ as t,c as s,al as r,o as a}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"Per-Thread Interrupt Controls","description":"","frontmatter":{},"headers":[],"relativePath":"en/implementation/interrupt_controls.md","filePath":"en/implementation/interrupt_controls.md"}'),n={name:"en/implementation/interrupt_controls.md"};function o(i,e,l,p,d,h){return a(),s("div",null,e[0]||(e[0]=[r(`<h1 id="per-thread-interrupt-controls" tabindex="-1">Per-Thread Interrupt Controls <a class="header-anchor" href="#per-thread-interrupt-controls" aria-label="Permalink to &quot;Per-Thread Interrupt Controls&quot;">â€‹</a></h1><p>Using NuttX, you will find that the interrupts enabled/disabled state is not a global property. You can not just turn interrupts off and on for all tasks. Rather, enabling and disabling interrupts effects only while the single task that is controlling the interrupts runs. Consider the following sequence:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>irqstate_t flags;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>flags = irqsave();   /* Disable interrupts */</span></span>
<span class="line"><span>sleep(5);            /* Sleep for 5 seconds */</span></span>
<span class="line"><span>irqrestore(flags);   /* Re-enable interrupts */</span></span></code></pre></div><p>What happens while the task sleeps? Does that mean that interrupts will be disabled for five seconds? No, interrupts will (probably) be re-enabled while the task is sleeping. How does this work?</p><p>It is really very simple. Each time a context switches occurs, a set of registers are saved for the task that is being suspended. Then those registers are restored from the previously saved registers for a next task that will run. This is why we often describe a context switch as just setjmp/longjmp on steroids: A context switch works just like setjmp (save a set of registers) and longjmp (restore a set of registers), except that more registers are saved and restored.</p><p>For the the ARMv7-M, as an example, you can see the set of registers that are stored in <code>arch/arm/include/armv7-m/irq.h</code></p><p>Among those registers are saved and restore are the register(s) that determine if interrupts are enable or not. For the ARMv7-M family that is either the <code>PRIMASK</code> register or the <code>BASEPRI</code> registers. So if a task disables interrupts then suspends, the current value of <code>PRIMASK</code>/<code>BASEPRI</code> register is saved and replaced with the stored value of the <code>PRIMASK</code>/<code>BASEPRI</code> register for the next task that will run, thus re-enabling interrupts while the rist task is suspended.</p><p>So interrupt enabled/disable is a per-thread property, not a global property. If you have been working with bare metal systems for a long time, this might seem foreign to you.</p><p>By the way, locking the scheduler via <code>sched_lock()</code> behaves in this same way (but the mechanism is a little different).</p>`,9)]))}const g=t(n,[["render",o]]);export{u as __pageData,g as default};
