import{_ as i,c as o,al as r,j as e,a,o as n}from"./chunks/framework.NFAqBSgQ.js";const b=JSON.parse('{"title":"Nordic nRF52","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/nrf52/index.md","filePath":"en/platforms/arm/nrf52/index.md"}'),s={name:"en/platforms/arm/nrf52/index.md"};function l(d,t,h,p,c,u){return n(),o("div",null,t[0]||(t[0]=[r('<h1 id="nordic-nrf52" tabindex="-1">Nordic nRF52 <a class="header-anchor" href="#nordic-nrf52" aria-label="Permalink to &quot;Nordic nRF52&quot;">​</a></h1><p>The nRF52 series of chips from Nordic Semiconductor are based around an ARM Cortex-M4 core running at 64 MHz and feature Bluetooth Low Energy (BLE) support.</p><h2 id="memory-map" tabindex="-1">Memory Map <a class="header-anchor" href="#memory-map" aria-label="Permalink to &quot;Memory Map&quot;">​</a></h2><h3 id="nrf52832" tabindex="-1">nRF52832 <a class="header-anchor" href="#nrf52832" aria-label="Permalink to &quot;nRF52832&quot;">​</a></h3><p>Block Name Start Address Length</p><hr><p>FLASH 0x00000000 512K RAM 0x20000000 64K</p><h3 id="nrf52840" tabindex="-1">nRF52840 <a class="header-anchor" href="#nrf52840" aria-label="Permalink to &quot;nRF52840&quot;">​</a></h3><p>Block Name Start Address Length</p><hr><p>FLASH 0x00000000 1024K RAM 0x20000000 256K</p><h2 id="clock-configuration" tabindex="-1">Clock Configuration <a class="header-anchor" href="#clock-configuration" aria-label="Permalink to &quot;Clock Configuration&quot;">​</a></h2><p>Clock settings are handled via Kconfig options, which determines whether to start external crystal for the HFCLK, whether to start the LFCLK and which oscillator to use.</p><h2 id="system-timer" tabindex="-1">System Timer <a class="header-anchor" href="#system-timer" aria-label="Permalink to &quot;System Timer&quot;">​</a></h2><p>The clock used for providing system time can be chosen via Kconfig. You can choose to use ARM SysTick or use RTC in tickless mode.</p><h2 id="regulator-control" tabindex="-1">Regulator Control <a class="header-anchor" href="#regulator-control" aria-label="Permalink to &quot;Regulator Control&quot;">​</a></h2><p>DC/DC regulator can be made to be enabled at boot via Kconfig.</p><h2 id="peripheral-support" tabindex="-1">Peripheral Support <a class="header-anchor" href="#peripheral-support" aria-label="Permalink to &quot;Peripheral Support&quot;">​</a></h2><p>The following list indicates peripherals supported in NuttX:</p><p>Peripheral Support Notes</p><hr><p>GPIO GPIOTE I2S MWU NFCT PDM PPI PWM QDEC QSPI Yes Yes No No No No Yes Yes No Yes<br> RADIO RNG RTC SAADC SPIM SPIS TEMP TIMER TWIM TWIS UART UARTE USBD WDT Yes Yes Yes Yes Yes No No Yes Yes No Yes No Yes Yes BLE, IEEE 802.15.4</p><p>Peripherals such as AAR, ACL, CCM, ECB are not directly used by NuttX since they are part of BLE controller implementation (link).</p><h3 id="gpio-gpiote" tabindex="-1">GPIO/GPIOTE <a class="header-anchor" href="#gpio-gpiote" aria-label="Permalink to &quot;GPIO/GPIOTE&quot;">​</a></h3><p>Pins can be configured/operated using <code>nrf52_gpio_*</code> functions. Interrupts are handled via the GPIOTE peripheral in one of two ways: via a GPIOTE channel or via PORT events. The former allows for simultaneous rising/falling edge-sensitive interrupts per-pin. However, as there are a limited number of channels (and sometimes these are used by some drivers for specific tasks), it may not always be possible to use this mechanism. The latter approach for pin interrupts is via the PORT event, determined by pin state on a their corresponding GPIO port. This is related to the SENSE capability of pins, which can only be set to either rising or falling edge sensing.</p><p>Depending on <code>CONFIG_NRF52_PER_PIN_INTERRUPTS</code> option, you can set a callback for the PORT event itself or you can set a callback for a given pin. In the latter case the driver scans for pins with DETECT bit high and calls the configured callback automatically.</p><p>Finally, GPIOTE can also be used to configure a channel in <em>task mode</em>, which allows to control pin state via tasks/events.</p><h3 id="adc" tabindex="-1">ADC <a class="header-anchor" href="#adc" aria-label="Permalink to &quot;ADC&quot;">​</a></h3>',28),e("p",null,[a("The SAADC peripheral is exposed via standard ADC driver. The lower-half of this driver is initialized by calling :c"),e("code",{class:"interpreted-text",role:"func"},"nrf52_adcinitialize"),a(".")],-1),e("h3",{id:"i2c",tabindex:"-1"},[a("I2C "),e("a",{class:"header-anchor",href:"#i2c","aria-label":'Permalink to "I2C"'},"​")],-1),e("p",null,"I2C is supported both in polling and interrupt mode (via EasyDMA).",-1),e("p",null,"Note",-1),e("p",null,"The I2C peripheral does not support sending two transfers without sending a START nor RSTART. For this reason, this is supported via an internal buffer where messages will be first copied to and sent together.",-1),e("p",null,[a("The lower-half of I2C bus is initialized by :c"),e("code",{class:"interpreted-text",role:"func"},"nrf52_i2cbus_initialize"),a(". There's also a software (bitbang) I2C implementation for nRF52. The lower-half is initialized via :c"),e("code",null,"nrf52_i2c_bitbang_initialize"),a('{.interpreted-text role="func"}.')],-1),r('<h3 id="spi" tabindex="-1">SPI <a class="header-anchor" href="#spi" aria-label="Permalink to &quot;SPI&quot;">​</a></h3><p>SPI is supported both in polling and interrupt-based (via EasyDMA) mode. The latter supports arbitrarily long transfers using Nordic&#39;s list-mode EasyDMA (intermediate transfers are currently still manually started).</p><p>It is possible to use SPI without either MOSI/MISO pin defined by simply not providing the relevant <code>BOARD_SPI*_MISO/MOSI_PIN</code> definition.</p><p>This implementation support power management hooks, which will disable SPI peripheral when entering either SLEEP or STANDBY modes and reconfigure it when going back to NORMAL mode.</p><h3 id="uart" tabindex="-1">UART <a class="header-anchor" href="#uart" aria-label="Permalink to &quot;UART&quot;">​</a></h3><p>UART is implemented using polling. UARTE EasyDMA feature is not yet supported. This may introduce a large number of interrupts which may be undesirable.</p><h3 id="ppi" tabindex="-1">PPI <a class="header-anchor" href="#ppi" aria-label="Permalink to &quot;PPI&quot;">​</a></h3><p>The PPI peripheral is supported via a specific API which lets you control the EVENT and TASKs to trigger, both for individual and grouped channels.</p><p>When using channels, you should consider that some peripherals may use PPI internally and some may be unavailable for further use. As a helper, if debug assertions are enabled, calls to PPI API will check for a channel to actually be disabled when being enabled and vice-versa. This may help catch collisions in PPI use.</p><h3 id="pwm" tabindex="-1">PWM <a class="header-anchor" href="#pwm" aria-label="Permalink to &quot;PWM&quot;">​</a></h3><p>PWM is supported via standard driver. This means that more advanced features such as complex sequences or waveform modes are not yet supported.</p><h3 id="qspi" tabindex="-1">QSPI <a class="header-anchor" href="#qspi" aria-label="Permalink to &quot;QSPI&quot;">​</a></h3><p>QSPI is supported both in interrupt-based (via EasyDMA) mode and is exposed via standard QSPI interface.</p><h3 id="rng" tabindex="-1">RNG <a class="header-anchor" href="#rng" aria-label="Permalink to &quot;RNG&quot;">​</a></h3><p>The RNG peripheral will be used to register a random/urandom device automatically, when enabled.</p><h3 id="timer" tabindex="-1">TIMER <a class="header-anchor" href="#timer" aria-label="Permalink to &quot;TIMER&quot;">​</a></h3><p>The TIMER peripheral is exposed as standard timer.</p><h3 id="rtc" tabindex="-1">RTC <a class="header-anchor" href="#rtc" aria-label="Permalink to &quot;RTC&quot;">​</a></h3><p>The RTC peripheral is exposed as a standard timer, since it is really a low-power timer, without any date handling capabilities.</p><h3 id="usbd" tabindex="-1">USBD <a class="header-anchor" href="#usbd" aria-label="Permalink to &quot;USBD&quot;">​</a></h3><p>The USBD peripheral is exposed via standard USBDEV interface.</p><h3 id="wdt" tabindex="-1">WDT <a class="header-anchor" href="#wdt" aria-label="Permalink to &quot;WDT&quot;">​</a></h3><p>The watchdog is supported via low-level API interface and also via standard watchdog driver. The driver is written so as to handle an already running watchdog, which may have been set by a bootloader.</p><h2 id="ble-support" tabindex="-1">BLE Support <a class="header-anchor" href="#ble-support" aria-label="Permalink to &quot;BLE Support&quot;">​</a></h2>',24),e("p",null,[a("BLE is supported in nRF52 using Nordic's "),e("a",{href:"https://developer.nordicsemi.com/nRF_Connect_SDK/doc/latest/nrfxlib/softdevice_controller/README.html",target:"_blank",rel:"noreferrer"},"SoftDevice Controller"),a(", using HCI interface. To enable BLE support you need to call :c"),e("code",{class:"interpreted-text",role:"func"},"nrf52_sdc_initialize"),a(" on boot, which will initialize the BLE controller.")],-1),r('<p>SDC support involves registering various high-priority zero-latency interrupts and thus requires enabling BASEPRI and high-priority interrupt support. On supported boards, a sample <code>sdc</code> configuration is provided with settings already set.</p><p>Note that in this case, some peripherals (mostly those related to BLE) will be unavailable. Some PPI channels will also be ocuppied (<code>NRF52_PPI_NUM_CONFIGURABLE_CHANNELS</code> will be set accordingly in this case).</p><h2 id="ieee-802-15-4-support" tabindex="-1">IEEE 802.15.4 Support <a class="header-anchor" href="#ieee-802-15-4-support" aria-label="Permalink to &quot;IEEE 802.15.4 Support&quot;">​</a></h2><p>Details about IEEE 802.15.4 support for nRF52 can be found in [[ieee802154]{.title-ref}.]([ieee802154]{.title-ref}..md)</p><h2 id="supported-boards" tabindex="-1">Supported Boards <a class="header-anchor" href="#supported-boards" aria-label="Permalink to &quot;Supported Boards&quot;">​</a></h2><blockquote><p>boards/<em>/</em> ieee802154.rst</p></blockquote>',6)]))}const f=i(s,[["render",l]]);export{b as __pageData,f as default};
