import{_ as a,c as s,al as n,o as i}from"./chunks/framework.NFAqBSgQ.js";const t="/assets/GraphicsInterfaces.BKDpzKB-.png",u=JSON.parse('{"title":"Framebuffer Character Driver","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/nxgraphics/framebuffer_char_driver.md","filePath":"en/components/nxgraphics/framebuffer_char_driver.md"}'),r={name:"en/components/nxgraphics/framebuffer_char_driver.md"};function p(o,e,l,c,d,f){return i(),s("div",null,e[0]||(e[0]=[n('<h1 id="framebuffer-character-driver" tabindex="-1">Framebuffer Character Driver <a class="header-anchor" href="#framebuffer-character-driver" aria-label="Permalink to &quot;Framebuffer Character Driver&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Framebuffer+Character+Driver" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Framebuffer+Character+Driver</a></p><h2 id="nx-graphics" tabindex="-1">NX Graphics <a class="header-anchor" href="#nx-graphics" aria-label="Permalink to &quot;NX Graphics&quot;">​</a></h2><p>NuttX has supported higher level graphics for some time with the OS&#39;s [[/component](]{.title-ref}/component.md)s/nxgraphics/index` and application oriented [[NxWidget](`NxWidget.md)s &lt;/applications/graphics/nxwidgets/index&gt;]{.title-ref} and the tiny window manager [[NxWM &lt;/application](`NxWM &lt;/application.md)s/graphics/nxwm/index&gt;]{.title-ref}. These are higher level in the sense that the primary graphical function is to support windowing and control of tools and toolbars within windows. These graphics tools often do not meet the needs of developers with very low end graphics and minimal display requirements.</p><h2 id="figure-1" tabindex="-1">Figure 1 <a class="header-anchor" href="#figure-1" aria-label="Permalink to &quot;Figure 1&quot;">​</a></h2><p>The framebuffer character driver, along with the option LCD framebuffer interface, is an optional lighter-weight graphics interface.</p><p><img src="'+t+`" alt="image"></p><h2 id="framebuffer-character-driver-details" tabindex="-1">Framebuffer Character Driver details <a class="header-anchor" href="#framebuffer-character-driver-details" aria-label="Permalink to &quot;Framebuffer Character Driver details&quot;">​</a></h2><p>A [framebuffer character driver]{.title-ref} has been recently been added to bypass the complexity of [NX]{.title-ref} and to provide a direct application interface to the framebuffer graphic device. The framebuffer buffer character devices, as with all character devices, provides the interface to the graphics device via stand POSIX VFS commands (<code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, <code>seek()</code>, ...), through IOCTL commands, and for this driver via the <code>mmap()</code> function. These interfaces are described below,</p><p>The framebuffer character driver is located in the NuttX source tree at <code>drivers/video/fb.c</code>. It is enabled in the build with <code>CONFIG_VIDEO_FB=y</code>. In order to register the framebuffer driver, you will need to include logic in the your board-specific start-up function that calls <code>fb_register()</code> That code sequence might look something like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;nuttx/video/fb.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef CONFIG_VIDEO_FB</span></span>
<span class="line"><span>/* Initialize and register the simulated framebuffer driver */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ret = fb_register(0, 0);</span></span>
<span class="line"><span>if (ret &lt; 0)</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>    syslog(LOG_ERR, &quot;ERROR: fb_register() failed: %d\\n&quot;, ret);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>#endif</span></span></code></pre></div><p>The <code>fb_register()</code> function takes two parameters:</p><ul><li>[display]{.title-ref}. The display number for the case of boards supporting multiple displays or for hardware that supports multiple layers (each layer is consider a display). Typically zero.</li><li>[plane]{.title-ref}. Identifies the color plane on hardware that supports separate framebuffer &quot;planes&quot; for each color component. Should be zero because no planar hardware is currently supported by NuttX.</li></ul><p><code>fb_register()</code> will register the framebuffer character device at <code>/dev/fb</code> [N]{.title-ref} where [N]{.title-ref} is the display number if the devices supports only a single plane. If the hardware supports multiple color planes, then the device will be registered at <code>/dev/fb</code> [N-M]{.title-ref} where [N]{.title-ref} is the again display number but [M]{.title-ref} is the display plane.</p><p>There is a simple example at <code>apps/examples/fb</code> that provides an illustration of most of the following interfacing methods.</p><h2 id="posix-interfaces" tabindex="-1">POSIX Interfaces <a class="header-anchor" href="#posix-interfaces" aria-label="Permalink to &quot;POSIX Interfaces&quot;">​</a></h2><p>The interaction with the framebuffer character driver via POSIX VFS interface calls is the same as for other character drivers. The only aspect that might require some additional discussion is the use of <code>read()</code>, <code>write()</code>, and <code>seek()</code>.</p><ul><li><code>read()</code> returns data from the framebuffer memory and updates the file position based on the number of bytes read.</li><li><code>write()</code> puts data into the framebuffer memory and also updates the file position.</li></ul><p>That file position is initially set to the position zero meaning the beginning of the framebuffer. It is advanced each time you <code>read()</code> from or <code>write()</code> to the framebuffer. Is also updated by <code>seek()</code>:</p><ul><li><code>seek()</code> sets the file position to any desired location within the framebuffer.</li></ul><p>The file position is in units of [bytes]{.title-ref}. This can be confusing because other positional data may be in units [pixels]{.title-ref}. Pixels have different [depth]{.title-ref} in different displays, that is, different graphic hardware may support pixels with differing bits-per-pixel. The pixel depth can be obtained using one of the IOCTL commands listed below. Since the file position is in bytes, the bits-per-pixel must be taken account when using <code>read()</code>, <code>write()</code>, and <code>seek()</code>. The usual conversion from pixels to bytes is:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>start_byte = (start_pixel * bits_per_pixel) &gt;&gt; 3;</span></span>
<span class="line"><span>end_byte   = (end_pixel * bits_per_pixel + 7) &gt;&gt; 3;</span></span></code></pre></div><p>While the framebuffer may be accessed with these POSIX interfaces, a more typical way of interacting with the framebuffer from an application would involve use of <code>mmap()</code> as described below.</p><h2 id="ioctl-commands" tabindex="-1">IOCTL Commands <a class="header-anchor" href="#ioctl-commands" aria-label="Permalink to &quot;IOCTL Commands&quot;">​</a></h2><ul><li><p><code>FBIOGET_VIDEOINFO</code>. Get color plane info. Its argument is pointer a writable instance of <code>struct fb_videoinfo_s</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct fb_videoinfo_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    uint8_t    fmt;         /* see FB_FMT_*  */</span></span>
<span class="line"><span>    fb_coord_t xres;        /* Horizontal resolution in pixel columns */</span></span>
<span class="line"><span>    fb_coord_t yres;        /* Vertical resolution in pixel rows */</span></span>
<span class="line"><span>    uint8_t    nplanes;     /* Number of color planes supported */</span></span>
<span class="line"><span>};</span></span></code></pre></div></li><li><p><code>FBIOGET_PLANEINFO</code>. Get video plane info. It received a pointer to a writable instance of <code>struct fb_planeinfo_s</code> as its argument:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct fb_planeinfo_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    FAR void  *fbmem;       /* Start of frame buffer memory */</span></span>
<span class="line"><span>    uint32_t   fblen;       /* Length of frame buffer memory in bytes */</span></span>
<span class="line"><span>    fb_coord_t stride;      /* Length of a line in bytes */</span></span>
<span class="line"><span>    uint8_t    display;     /* Display number */</span></span>
<span class="line"><span>    uint8_t    bpp;         /* Bits per pixel */</span></span>
<span class="line"><span>};</span></span></code></pre></div></li><li><p><code>FBIOGET_CMAP</code> and <code>FBIOPUT_CMAP</code>. Get/Put RGB color mapping. These commands are available only if the hardware and framebuffer driver support color mapping (<code>CONFIG_FB_CMAP=y</code>). They each take a pointer to an instance of <code>struct fb_cmap_s</code> as an argument (writeable for <code>FBIOGET_CMAP</code> and read-only for <code>FBIOPUT_CMAP</code>).</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_FB_CMAP</span></span>
<span class="line"><span>struct fb_cmap_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    uint16_t  first;        /* Offset offset first color entry in tables */</span></span>
<span class="line"><span>    uint16_t  len;          /* Number of color entries  in tables */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /* Tables of  color component.  Any may be NULL if not used */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    uint8_t *red;           /* Table of 8-bit red values */</span></span>
<span class="line"><span>    uint8_t *green;         /* Table of 8-bit green values */</span></span>
<span class="line"><span>    uint8_t *blue;          /* Table of 8-bit blue values */</span></span>
<span class="line"><span>#ifdef CONFIG_FB_TRANSPARENCY</span></span>
<span class="line"><span>    uint8_t *transp;        /* Table of 8-bit transparency */</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>#endif</span></span></code></pre></div></li><li><p><code>FBIOGET_CURSOR</code>. Get cursor attributes. This command is available only if the hardware and framebuffer driver support cursors (<code>CONFIG_FB_HWCURSOR=y</code>). It take a pointer to a writable instance of <code>struct fb_cursorattrib_s</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_FB_HWCURSOR</span></span>
<span class="line"><span>#ifdef CONFIG_FB_HWCURSORIMAGE</span></span>
<span class="line"><span>struct fb_cursorimage_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    fb_coord_t     width;    /* Width of the cursor image in pixels */</span></span>
<span class="line"><span>    fb_coord_t     height    /* Height of the cursor image in pixels */</span></span>
<span class="line"><span>    const uint8_t *image;    /* Pointer to image data */</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct fb_cursorpos_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    fb_coord_t x;            /* X position in pixels */</span></span>
<span class="line"><span>    fb_coord_t y;            /* Y position in rows */</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ifdef CONFIG_FB_HWCURSORSIZE</span></span>
<span class="line"><span>struct fb_cursorsize_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    fb_coord_t h;             /* Height in rows */</span></span>
<span class="line"><span>    fb_coord_t w;             /* Width in pixels */</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span></span></span>
<span class="line"><span>struct fb_cursorattrib_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>#ifdef CONFIG_FB_HWCURSORIMAGE</span></span>
<span class="line"><span>    uint8_t fmt;                   /* Video format of cursor */</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>    struct fb_cursorpos_s  pos;    /* Current cursor position */</span></span>
<span class="line"><span>#ifdef CONFIG_FB_HWCURSORSIZE</span></span>
<span class="line"><span>    struct fb_cursorsize_s mxsize; /* Maximum cursor size */</span></span>
<span class="line"><span>    struct fb_cursorsize_s size;   /* Current size */</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>#endif</span></span></code></pre></div></li><li><p><code>FBIOPUT_CURSOR</code>. Set cursor attributes. This command is available only if the hardware and framebuffer driver support cursors (<code>CONFIG_FB_HWCURSOR=y</code>). It take a pointer to a writable instance of <code>struct fb_setcursor_s</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#ifdef CONFIG_FB_HWCURSOR</span></span>
<span class="line"><span>struct fb_setcursor_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    uint8_t flags;                /* See FB_CUR_* definitions */</span></span>
<span class="line"><span>    struct fb_cursorpos_s pos;    /* Cursor position */</span></span>
<span class="line"><span>#ifdef CONFIG_FB_HWCURSORSIZE</span></span>
<span class="line"><span>    struct fb_cursorsize_s  size; /* Cursor size */</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>#ifdef CONFIG_FB_HWCURSORIMAGE</span></span>
<span class="line"><span>    struct fb_cursorimage_s img;  /* Cursor image */</span></span>
<span class="line"><span>#endif</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>#endif</span></span></code></pre></div></li><li><p><code>FBIO_UPDATE</code>. This IOCTL command updates a rectangular region in the framebuffer. Some hardware requires that there be such a notification when a change is made to the framebuffer (see, for example, the discussion of LCD drivers below). This IOTCL command is if <code>CONFIG_NX_UPDATE=y</code> is defined. It takes a pointer to a read-only instance of <code>struct nxgl_rect_s</code> that describes the region to be updated:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct nxgl_rect_s</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    struct nxgl_point_s pt1; /* Upper, left-hand corner */</span></span>
<span class="line"><span>    struct nxgl_point_s pt2; /* Lower, right-hand corner */</span></span>
<span class="line"><span>};</span></span></code></pre></div></li></ul><h2 id="mmap" tabindex="-1"><code>mmap()</code> <a class="header-anchor" href="#mmap" aria-label="Permalink to &quot;\`mmap()\`&quot;">​</a></h2><p>Above we talked about using <code>read()</code>, <code>write()</code>, and <code>seek()</code> to access the framebuffer. The simplest way to access the framebuffer, however, is by using the <code>mmap()</code> to map the framebuffer memory into the application memory space. The following <code>mmap()</code> command, for example, can be used to obtain a pointer to a read-able, write-able copy of the framebuffer:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>FAR void *fbmem;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fbmem = mmap(NULL, fblen, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FILE, fd, 0);</span></span>
<span class="line"><span>if (state.fbmem == MAP_FAILED)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    /* Handle failure */</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>printf(&quot;Mapped FB: %p\\n&quot;, fbmem);</span></span></code></pre></div><p>Where fd is the file descriptor of the opened framebuffer character driver and <code>fblen</code> was obtained via an IOCTL command as described above. NOTE that the framebuffer buffer pointer is also available within the values returned by the IOCTL commands. The address is a kernel memory address and may not be valid in all build configurations. Hence, <code>mmap()</code> is the preferred, portable way to get the framebuffer address.</p><h2 id="framebuffer-vs-lcd-graphics-drivers" tabindex="-1">Framebuffer vs. LCD Graphics Drivers <a class="header-anchor" href="#framebuffer-vs-lcd-graphics-drivers" aria-label="Permalink to &quot;Framebuffer vs. LCD Graphics Drivers&quot;">​</a></h2><p>Framebuffer graphics drivers are very common in high-end CPUs but most low-end, embedded hardware will not support a framebuffer.</p><p>A framebuffer graphics driver supports a region of memory that is shared both by the software and by the graphics hardware. Any modification to the framebuffer memory results in a corresponding modification on the display with no intervening software interaction. Some video memory is dual ported to support concurrent video processor and application processor accesses; or perhaps the LCD peripheral just constantly DMAs the framebuffer memory to the graphics hardware.</p><p>Most low-end embedded MCUs have a much simpler hardware interface: The interface to the LCD may be through a simple parallel interface or, more commonly, through a slower serial interface such as SPI. In order to support such low-end hardware with the framebuffer character driver, a special software layer called the [Framebuffer LCD Front End]{.title-ref} has been developed. This is the topic of the next paragraph.</p><h2 id="lcd-framebuffer-front-end" tabindex="-1">LCD Framebuffer Front-End <a class="header-anchor" href="#lcd-framebuffer-front-end" aria-label="Permalink to &quot;LCD Framebuffer Front-End&quot;">​</a></h2><p>The [LCD Framebuffer Front-End]{.title-ref} provides a standard NuttX framebuffer interface, but works on top of a standard parallel or serial LCD driver. It provides the framebuffer, the framebuffer interface, and the hooks to adapt the LCD driver. The LCD framebuffer front-end can be found in the NuttX source tree at <code>drivers/lcd/lcd_framebuffer.c</code>.</p><p>In order to provide updates to the LCD hardware after updates to the framebuffer, the LCD framebuffer front-end must be notified when significant changes to the framebuffer have been made. This notification is supported when <code>CONFIG_NX_UPDATE=y</code> is defined in the configuration. In this case, the LCD framebuffer front-end will support the special. OS-internal interface function <code>nx_notify_rectangle()</code> which defines the rectangular region in the framebuffer that has been changed. In response to a call to <code>nx_notify_rectangle()</code> will use the lower-level LCD interface to update only that rectangular region on the display.</p><p>This kind of update for standard LCD drivers is very efficient: It is usually more efficient to update a region on the display than it is for form a complex image with text and line drawing; the updated region seems to update very quickly because of that. In fact, many of the low-end LCD drivers already include an internal framebuffer to support this style of LCD update.</p><p>When used with LCD character driver, the <code>nx_notify_rectangle()</code> function will be called by the character river in response to the <code>FBIO_UPDATE IOCTL</code> command.</p><p>Another advantage of the framebuffer, both the LCD internal framebuffer and the framebuffer character driver, is that super-efficient reading of the LCD display memory: The LCD display memory is not read at all! The read is from the copy in the framebuffer.</p><p>Of course, using both an LCD internal framebuffer with the framebuffer character drivers is wasteful; one framebuffer is enough!</p><p>As a caution, it is important to remember that a framebuffer can be quite large. For example, a 480x320 display with 16-bit RGB pixels would require an allocated framebuffer of size 300 KiB. This is inappropriate with most small MCUs (unless they support external memory). For tiny displays, such as 128x64 1-bit monochromatic displays, the framebuffer memory usage is not bad: 1 KiB in that example.</p><h2 id="framebuffer-graphics-library" tabindex="-1">Framebuffer Graphics Library <a class="header-anchor" href="#framebuffer-graphics-library" aria-label="Permalink to &quot;Framebuffer Graphics Library&quot;">​</a></h2><p>Now the missing part is some kind of application-space framebuffer graphics library. The NuttX framebuffer driver is superficially similar to the Linux framebuffer driver so there is a lot of support for Linux framebuffer graphics support that should be easily ported to NuttX -- Perhaps DirectFB would be an GPL option? SDL with its MIT license might be a more compatible source for such a port.</p>`,44)]))}const m=a(r,[["render",p]]);export{u as __pageData,m as default};
