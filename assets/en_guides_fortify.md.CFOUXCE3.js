import{_ as a,c as i,al as t,o as n}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"Fortify","description":"","frontmatter":{},"headers":[],"relativePath":"en/guides/fortify.md","filePath":"en/guides/fortify.md"}'),s={name:"en/guides/fortify.md"};function o(r,e,l,c,p,d){return n(),i("div",null,e[0]||(e[0]=[t(`<h1 id="fortify" tabindex="-1">Fortify <a class="header-anchor" href="#fortify" aria-label="Permalink to &quot;Fortify&quot;">​</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p>A common error in C programs is invoking functions that might exceed memory bounds, causing crashes or undefined behavior. Examples include incorrect usage of functions like <code>memcpy</code> and <code>memset</code>. [FORTIFY_SOURCE]{.title-ref} is a mechanism designed to help developers quickly detect and mitigate boundary-related issues caused by improper use of library functions.</p><h2 id="support" tabindex="-1">Support <a class="header-anchor" href="#support" aria-label="Permalink to &quot;Support&quot;">​</a></h2><p>[FORTIFY_SOURCE]{.title-ref} is implemented as a software check by the compiler and is supported across all architectures. It works by adding additional validation checks to standard library function calls.</p><h2 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to &quot;Usage&quot;">​</a></h2><p>To enable [FORTIFY_SOURCE]{.title-ref}, configure the kernel with the following option:</p><p><code>CONFIG_FORTIFY_SOURCE=level</code></p><p>Where [level]{.title-ref} can be set as:</p><ol><li><strong>Compile-time Checks</strong>: Detects issues during compilation by analyzing source code.</li><li><strong>Stack Variable Checks</strong>: Extends level 1 by checking stack variables at runtime.</li><li><strong>Heap Memory Checks</strong>: Builds on level 2 by adding checks for memory allocated with <code>malloc</code>. (Requires GCC version 12 or later.)</li></ol><h3 id="fortify-source-overview" tabindex="-1">FORTIFY_SOURCE Overview <a class="header-anchor" href="#fortify-source-overview" aria-label="Permalink to &quot;FORTIFY\\_SOURCE Overview&quot;">​</a></h3><p>[FORTIFY_SOURCE]{.title-ref} detects potential security vulnerabilities by statically analyzing source code at compile time. It replaces standard library function calls with safer versions that include additional boundary checks. These safer versions validate the operation&#39;s boundaries and the input&#39;s validity before performing certain operations.</p><h2 id="gcc-built-in-functions" tabindex="-1">GCC Built-in Functions <a class="header-anchor" href="#gcc-built-in-functions" aria-label="Permalink to &quot;GCC Built-in Functions&quot;">​</a></h2><p>The GCC compiler internally implements two key functions for \`FORTIFY_SOURCE\`:</p><ul><li><code>__builtin_object_size</code>: Determines the size of a statically allocated object.</li><li><code>__builtin_dynamic_object_size</code>: Determines the size of dynamically allocated objects (e.g., via <code>malloc</code>).</li></ul><p>Starting with GCC 12, these functions support retrieving the size of variables allocated with <code>malloc</code>.</p><p>By passing a variable or buffer as an argument to these functions, the compiler can compute the corresponding size. Using this size, it is possible to check for potential out-of-bounds behavior in runtime operations.</p><h2 id="example-memcpy-implementation-in-nuttx" tabindex="-1">Example: memcpy Implementation in NuttX <a class="header-anchor" href="#example-memcpy-implementation-in-nuttx" aria-label="Permalink to &quot;Example: memcpy Implementation in NuttX&quot;">​</a></h2><p>The following example demonstrates how [FORTIFY_SOURCE]{.title-ref} can be used to enhance security in a <code>memcpy</code> implementation in NuttX:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fortify_function(memcpy) </span></span>
<span class="line"><span>FAR void *memcpy(FAR void *dest,</span></span>
<span class="line"><span>                 FAR const void *src,</span></span>
<span class="line"><span>                 size_t n)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  fortify_assert(n &lt;= fortify_size(dest, 0) &amp;&amp; n &lt;= fortify_size(src, 0));</span></span>
<span class="line"><span>  return __real_memcpy(dest, src, n);</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>In this implementation, the <code>fortify_assert</code> macro ensures that the size of the source and destination buffers is sufficient to handle the requested memory operation. If the assertion fails, it indicates a potential buffer overflow, helping developers quickly identify and address such vulnerabilities.</p>`,21)]))}const h=a(s,[["render",o]]);export{m as __pageData,h as default};
