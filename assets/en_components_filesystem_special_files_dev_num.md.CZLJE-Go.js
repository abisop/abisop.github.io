import{_ as i,c as t,al as s,o as a}from"./chunks/framework.NFAqBSgQ.js";const m=JSON.parse('{"title":"Special Files and Device Numbers","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/filesystem/special_files_dev_num.md","filePath":"en/components/filesystem/special_files_dev_num.md"}'),n={name:"en/components/filesystem/special_files_dev_num.md"};function r(o,e,l,c,d,h){return a(),t("div",null,e[0]||(e[0]=[s('<h1 id="special-files-and-device-numbers" tabindex="-1">Special Files and Device Numbers <a class="header-anchor" href="#special-files-and-device-numbers" aria-label="Permalink to &quot;Special Files and Device Numbers&quot;">​</a></h1><p>Warning</p><p>Migrated from: <a href="https://cwiki.apache.org/confluence/display/NUTTX/Special+Files+and+Device+Numbers" target="_blank" rel="noreferrer">https://cwiki.apache.org/confluence/display/NUTTX/Special+Files+and+Device+Numbers</a></p><h2 id="special-files-in-unix-like-file-systems" tabindex="-1">Special Files in Unix-like File Systems <a class="header-anchor" href="#special-files-in-unix-like-file-systems" aria-label="Permalink to &quot;Special Files in Unix-like File Systems&quot;">​</a></h2><p>In Unix-like operating systems, a [special file]{.title-ref} is an interface for a device driver that appears in a file system as if it were an ordinary file. Special files are a feature built into Unix-like file systems such as EXT2.</p><p>See also <a href="https://en.wikipedia.org/wiki/Device_file" target="_blank" rel="noreferrer">Wikipedia article</a>.</p><h2 id="special-files-in-other-file-systems" tabindex="-1">Special Files in Other File Systems <a class="header-anchor" href="#special-files-in-other-file-systems" aria-label="Permalink to &quot;Special Files in Other File Systems&quot;">​</a></h2><p>Some other file systems systems, such as NTFS, also have some more limited and incompatible notion of special files. Others, such as FAT, do not have any such concept. Unix-like environments such as Cygwin that run on these other file systems have to do things a little differently: The have to emulate special files using the resources of the file system that they operate on. This may mean creating [regular]{.title-ref} files with special naming conventions or with special content that can be used to emulate the behavior of special files.</p><h2 id="special-files-and-nuttx" tabindex="-1">Special Files and NuttX <a class="header-anchor" href="#special-files-and-nuttx" aria-label="Permalink to &quot;Special Files and NuttX&quot;">​</a></h2><p>NuttX has done things in a very different way. There are no special files supported in any file system. Rather, special files can exist only in the NuttX [[p](`p.md)seudo file system &lt;pseudofs&gt;]{.title-ref}. This was a decision that was made in the initial design to simplify things for resource limited platforms yet still provide a mostly standard Unix-like/POSIX programming environment.</p><p>What are the advantages of the special files in the NuttX pseudo-file system? Reduce resource usage, reduced bring-up requirements. What are the disadvantages? In NuttX, special files can only reside in the pseudo-file system.</p><p>The only other consequence that I aware of is that NuttX cannot support the POSIX requirement for the <code>st_dev</code> field in the <code>struct stat</code> structure.</p><h2 id="device-files-and-device-numbers" tabindex="-1">Device Files and Device Numbers <a class="header-anchor" href="#device-files-and-device-numbers" aria-label="Permalink to &quot;Device Files and Device Numbers&quot;">​</a></h2><p>In a Unix-like system, devices are access special device files. In a Unix-like system, device files can reside in any compatible file system but, by convention, are always placed in the <code>/dev</code> directory. NuttX achieves programming compatibility with this convention because the top-level, [root]{.title-ref} file system is the pseudo-file system and <code>/dev</code> is part of the pseudo-file system.</p><p>But there is a bigger difference that this. The bigger difference is how device drivers are registered and how the are accessed. The primary content of the Unix-like device file is simply a number, a device number, usually represented as type <code>dev_t</code>. The device number an encoded that consists of a [major]{.title-ref} device number and a [minor]{.title-ref} device number. The major device number identifies the type of driver and the minor number identifies an instance of a driver of that type.</p><p>There is nothing special about these number from the sense of a file system. Just because device file exists with a certain major and minor number, that does not mean that there is actually any real driver instance backing that device file up. For example, you can create a device file from the Linux command line like this, knowing nothing other than major and minor device number:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>dev_t makedev(unsigned int maj, unsigned int min);</span></span></code></pre></div><p>In a Unix-like system, when you try to open a device driver several things must happen: The system must open the device file, obtain the device major and minor number, and then look up the driver instance in some internal [registry]{.title-ref} of registered device drivers. If one is found, then the system can complete the open operation.</p><p>So, the device number is then a [key]{.title-ref} of some kind into a [registry]{.title-ref} of device drivers. NuttX does this very differently: There are no device numbers, rather the pseudo-file system [is]{.title-ref} the device registry! In NuttX, device files cannot be created by users; they can only be created by device drivers by calling the following, internal interface:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>int register_driver(FAR const char *path, FAR const struct file_operations *fops, mode_t mode, FAR void *priv);</span></span></code></pre></div><p>The <code>path</code> argument determines where in the pseudo-file system the device file should be placed. <code>mode</code> provides device file privileges. The <code>fops</code> and <code>priv</code> provide the internal information for the <code>registry</code>.</p><p>So the when you open a device driver in NuttX, many fewer steps are involved: The system must still open the device file, but then since the pseudo-file system [is]{.title-ref} the device registry, all of the device driver information is available and <code>open</code> operation completes with no further actions.</p><h2 id="named-resources" tabindex="-1">Named Resources <a class="header-anchor" href="#named-resources" aria-label="Permalink to &quot;Named Resources&quot;">​</a></h2><p>This use of the pseudo-file system in NuttX to manage device files is consistent with a core NuttX device philosophy: The NuttX VFS and the pseudo-file system in particular, are used to manage all named OS resources. That applies not only to device files and other special files but also to such things named message queues and named semaphores (which can be found in the pseudo-file system in the <code>/var</code> directory).</p>',24)]))}const u=i(n,[["render",r]]);export{m as __pageData,u as default};
