import{_ as o,c as t,al as n,o as i}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"ST Nucleo L432KC","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/arm/stm32l4/boards/nucleo-l432kc/index.md","filePath":"en/platforms/arm/stm32l4/boards/nucleo-l432kc/index.md"}'),a={name:"en/platforms/arm/stm32l4/boards/nucleo-l432kc/index.md"};function l(r,e,s,d,h,u){return i(),t("div",null,e[0]||(e[0]=[n(`<h1 id="st-nucleo-l432kc" tabindex="-1">ST Nucleo L432KC <a class="header-anchor" href="#st-nucleo-l432kc" aria-label="Permalink to &quot;ST Nucleo L432KC&quot;">​</a></h1><p>chip:stm32, chip:stm32l4, chip:stm32l432</p><p>This page discusses issues unique to NuttX configurations for the ST Nucleo-l432kc board from ST Micro. See</p><blockquote><p><a href="http://www.st.com/nucleo-l432kc" target="_blank" rel="noreferrer">http://www.st.com/nucleo-l432kc</a></p></blockquote><p>NucleoL432KC:</p><ul><li>Microprocessor: 32-bit ARM Cortex M4 at 80MHz STM32L432KCU6</li><li>Memory: 256 KB Flash and 64 KB SRAM</li><li>ADC: 1×12-bit, 5 MSPS A/D converter: up to 10 channels</li><li>DMA: 16-stream DMA controllers with FIFOs and burst support</li><li>Timers: Up to 11 timers: up to five 16-bit, one 32-bit, two low-power 16 bit timers, two watchdog timers, and a SysTick timer</li><li>GPIO: Up to 26 I/O ports with interrupt capability, most 5v tolerant</li><li>I2C: Up to 2 × I2C interfaces</li><li>USARTs: Up to 3 USARTs, 2 UARTs, 1 LPUART</li><li>SPIs: Up to 2 SPIs</li><li>SAIs: 1 dual-channel audio interface</li><li>CAN interface</li><li>QSPI interface</li><li>USB: USB 2.0 full-speed device/host/OTG controller with on-chip PHY</li><li>CRC calculation unit</li><li>RTC</li></ul><p>Board features:</p><ul><li>Peripherals: 1 led</li><li>Debug: Serial wire debug and JTAG interfaces via on-board micro-usb stlink v2.1</li><li>Expansion I/F Arduino Nano Headers</li></ul><p>Uses a STM32F103 to provide a ST-Link for programming, debug similar to the OpenOcd FTDI function - USB to JTAG front-end.</p><p>See <a href="http://mbed.org/platforms/ST-Nucleo-L432KC" target="_blank" rel="noreferrer">http://mbed.org/platforms/ST-Nucleo-L432KC</a> for more information about these boards.</p><h2 id="development-environment" tabindex="-1">Development Environment <a class="header-anchor" href="#development-environment" aria-label="Permalink to &quot;Development Environment&quot;">​</a></h2><p>Either Linux or Cygwin on Windows can be used for the development environment. The source has been built only using the GNU toolchain (see below). Other toolchains will likely cause problems.</p><h2 id="gnu-toolchain-options" tabindex="-1">GNU Toolchain Options <a class="header-anchor" href="#gnu-toolchain-options" aria-label="Permalink to &quot;GNU Toolchain Options&quot;">​</a></h2><h3 id="toolchain-configurations" tabindex="-1">Toolchain Configurations <a class="header-anchor" href="#toolchain-configurations" aria-label="Permalink to &quot;Toolchain Configurations&quot;">​</a></h3><p>The NuttX make system has been modified to support the following different toolchain options.</p><ol><li>The NuttX buildroot Toolchain (see below), or</li><li>Any generic arm-none-eabi GNU toolchain.</li></ol><p>All testing has been conducted using the NuttX CodeSourcery toolchain. To use a different toolchain, you simply need to modify the configuration. As an example:</p><pre><code>CONFIG_ARM_TOOLCHAIN_GNU_EABI : Generic arm-none-eabi toolchain
</code></pre><h2 id="ides" tabindex="-1">IDEs <a class="header-anchor" href="#ides" aria-label="Permalink to &quot;IDEs&quot;">​</a></h2><p>NuttX is built using command-line make. It can be used with an IDE, but some effort will be required to create the project.</p><h3 id="makefile-build" tabindex="-1">Makefile Build <a class="header-anchor" href="#makefile-build" aria-label="Permalink to &quot;Makefile Build&quot;">​</a></h3><p>Under Eclipse, it is pretty easy to set up an &quot;empty makefile project&quot; and simply use the NuttX makefile to build the system. That is almost for free under Linux. Under Windows, you will need to set up the &quot;Cygwin GCC&quot; empty makefile project in order to work with Windows (Google for &quot;Eclipse Cygwin&quot; -there is a lot of help on the internet).</p><p>Using Sourcery CodeBench from <a href="http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/overview" target="_blank" rel="noreferrer">http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/overview</a> Download and install the latest version (as of this writing it was sourceryg++-2013.05-64-arm-none-eabi)</p><p>Import the project from git. File-&gt;import-&gt;Git-URI, then import a Exiting code as a Makefile progject from the working directory the git clone was done to.</p><p>Select the Sourcery CodeBench for ARM EABI. N.B. You must do one command line build, before the make will work in CodeBench.</p><h3 id="native-build" tabindex="-1">Native Build <a class="header-anchor" href="#native-build" aria-label="Permalink to &quot;Native Build&quot;">​</a></h3><p>Here are a few tips before you start that effort:</p><ol><li>Select the toolchain that you will be using in your .config file</li><li>Start the NuttX build at least one time from the Cygwin command line before trying to create your project. This is necessary to create certain auto-generated files and directories that will be needed.</li><li>Set up include paths: You will need include/, arch/arm/src/stm32, arch/arm/src/common, arch/arm/src/armv7-m, and sched/.</li><li>All assembly files need to have the definition option -D __ASSEMBLY__ on the command line.</li></ol><p>Startup files will probably cause you some headaches. The NuttX startup file is arch/arm/src/stm32/stm32_vectors.S. With RIDE, I have to build NuttX one time from the Cygwin command line in order to obtain the pre-built startup object needed by RIDE.</p><h2 id="nuttx-eabi-buildroot-toolchain" tabindex="-1">NuttX EABI &quot;buildroot&quot; Toolchain <a class="header-anchor" href="#nuttx-eabi-buildroot-toolchain" aria-label="Permalink to &quot;NuttX EABI \\&quot;buildroot\\&quot; Toolchain&quot;">​</a></h2><p>A GNU GCC-based toolchain is assumed. The PATH environment variable should be modified to point to the correct path to the Cortex-M3 GCC toolchain (if different from the default in your PATH variable).</p><p>If you have no Cortex-M3 toolchain, one can be downloaded from the NuttX Bitbucket download site (<a href="https://bitbucket.org/nuttx/buildroot/downloads/" target="_blank" rel="noreferrer">https://bitbucket.org/nuttx/buildroot/downloads/</a>). This GNU toolchain builds and executes in the Linux or Cygwin environment.</p><ol><li><p>You must have already configured NuttX in &lt;some-dir&gt;/nuttx.:</p><pre><code> tools/configure.sh nucleo-l432kc:nsh
 make qconfig
 V=1 make context all 2&gt;&amp;1 | tee mout
</code></pre></li><li><p>Download the latest buildroot package into &lt;some-dir&gt;</p></li><li><p>unpack the buildroot tarball. The resulting directory may have versioning information on it like buildroot-x.y.z. If so, rename &lt;some-dir&gt;/buildroot-x.y.z to &lt;some-dir&gt;/buildroot.</p></li><li><p>cd &lt;some-dir&gt;/buildroot</p></li><li><p>cp boards/cortexm3-eabi-defconfig-4.6.3 .config</p></li><li><p>make oldconfig</p></li><li><p>make</p></li><li><p>Make sure that the PATH variable includes the path to the newly built binaries.</p></li></ol><p>See the file boards/README.txt in the buildroot source tree. That has more details PLUS some special instructions that you will need to follow if you are building a Cortex-M3 toolchain for Cygwin under Windows.</p><p>NOTE: Unfortunately, the 4.6.3 EABI toolchain is not compatible with the the NXFLAT tools. See the top-level TODO file (under &quot;Binary loaders&quot;) for more information about this problem. If you plan to use NXFLAT, please do not use the GCC 4.6.3 EABI toolchain; instead use the GCC 4.3.3 EABI toolchain.</p><h2 id="nxflat-toolchain" tabindex="-1">NXFLAT Toolchain <a class="header-anchor" href="#nxflat-toolchain" aria-label="Permalink to &quot;NXFLAT Toolchain&quot;">​</a></h2><p>If you are <em>not</em> using the NuttX buildroot toolchain and you want to use the NXFLAT tools, then you will still have to build a portion of the buildroot tools -- just the NXFLAT tools. The buildroot with the NXFLAT tools can be downloaded from the NuttX Bitbucket download site (<a href="https://bitbucket.org/nuttx/nuttx/downloads/" target="_blank" rel="noreferrer">https://bitbucket.org/nuttx/nuttx/downloads/</a>).</p><p>This GNU toolchain builds and executes in the Linux or Cygwin environment.</p><ol><li><p>You must have already configured NuttX in &lt;some-dir&gt;/nuttx.:</p><pre><code>tools/configure.sh lpcxpresso-lpc1768:&lt;sub-dir&gt;
</code></pre></li><li><p>Download the latest buildroot package into &lt;some-dir&gt;</p></li><li><p>unpack the buildroot tarball. The resulting directory may have versioning information on it like buildroot-x.y.z. If so, rename &lt;some-dir&gt;/buildroot-x.y.z to &lt;some-dir&gt;/buildroot.</p></li><li><p>cd &lt;some-dir&gt;/buildroot</p></li><li><p>cp boards/cortexm3-defconfig-nxflat .config</p></li><li><p>make oldconfig</p></li><li><p>make</p></li><li><p>Make sure that the PATH variable includes the path to the newly built NXFLAT binaries.</p></li></ol><h2 id="mbed" tabindex="-1">mbed <a class="header-anchor" href="#mbed" aria-label="Permalink to &quot;mbed&quot;">​</a></h2><p>The Nucleo-L432KC includes boot loader from mbed:</p><blockquote><p><a href="https://mbed.org/handbook/Homepage" target="_blank" rel="noreferrer">https://mbed.org/handbook/Homepage</a></p></blockquote><p>Using the mbed loader:</p><ol><li>Connect the Nucleo-L432kc to the host PC using the USB connector.</li><li>A new file system will appear called NUCLEO; open it with Windows Explorer (assuming that you are using Windows).</li><li>Drag and drop nuttx.bin into the MBED window. This will load the nuttx.bin binary into the Nucleo-L432kc. The NUCLEO window will close then re-open and the Nucleo-L432KC will be running the new code.</li></ol><h2 id="hardware" tabindex="-1">Hardware <a class="header-anchor" href="#hardware" aria-label="Permalink to &quot;Hardware&quot;">​</a></h2><h3 id="leds" tabindex="-1">LEDs <a class="header-anchor" href="#leds" aria-label="Permalink to &quot;LEDs&quot;">​</a></h3><p>The Nucleo L432KC provides a single user LED, LD3. LD3 is the green LED connected to Arduino signal D13 corresponding to MCU I/O PB3 (pin 26).</p><ul><li>When the I/O is HIGH value, the LED is on.</li><li>When the I/O is LOW, the LED is off.</li></ul><p>These LEDs are not used by the board port unless CONFIG_ARCH_LEDS is defined. In that case, the usage by the board port is defined in include/board.h and src/sam_leds.c. The LEDs are used to encode OS-related events as follows when the LED is available:</p><blockquote><p>+-------------------+-------------------------+-------------+ | SYMBOL | Meaning | LD3 | +===================+=========================+=============+ | LED_STARTED | NuttX has been started | &gt; OFF | +-------------------+-------------------------+-------------+ | LED_HEAPALLOCATE | Heap has been allocated | &gt; OFF | +-------------------+-------------------------+-------------+ | LED_IRQSENABLED | Interrupts enabled | &gt; OFF | +-------------------+-------------------------+-------------+ | LED_STACKCREATED | Idle stack created | &gt; ON | +-------------------+-------------------------+-------------+ | LED_INIRQ | In an interrupt | &gt; No change | +-------------------+-------------------------+-------------+ | LED_SIGNAL | In a signal handler | &gt; No change | +-------------------+-------------------------+-------------+ | LED_ASSERTION | An assertion failed | &gt; No change | +-------------------+-------------------------+-------------+ | LED_PANIC | The system has crashed | &gt; Blinking | +-------------------+-------------------------+-------------+ | LED_IDLE | MCU is is sleep mode | &gt; Not used | +-------------------+-------------------------+-------------+</p></blockquote><p>Thus if LD3, NuttX has successfully booted and is, apparently, running normally. If LD3 is flashing at approximately 2Hz, then a fatal error has been detected and the system has halted.</p><h2 id="serial-consoles" tabindex="-1">Serial Consoles <a class="header-anchor" href="#serial-consoles" aria-label="Permalink to &quot;Serial Consoles&quot;">​</a></h2><h3 id="usart1" tabindex="-1">USART1 <a class="header-anchor" href="#usart1" aria-label="Permalink to &quot;USART1&quot;">​</a></h3><p>Pins and Connectors:</p><pre><code>RXD: PA11  CN10 pin 14
     PB7   CN7 pin 21
TXD: PA10  CN9 pin 3, CN10 pin 33
     PB6   CN5 pin 3, CN10 pin 17
</code></pre><p>NOTE: You may need to edit the include/board.h to select different USART1 pin selections.</p><p>TTL to RS-232 converter connection:</p><pre><code>Nucleo CN10 STM32L432KC
----------- ------------
Pin 21 PA9  USART1_RX   *Warning you make need to reverse RX/TX on
Pin 33 PA10 USART1_TX    some RS-232 converters
Pin 20 GND
Pin 8  U5V
</code></pre><p>To configure USART1 as the console:</p><pre><code>CONFIG_STM32_USART1=y
CONFIG_USART1_SERIALDRIVER=y
CONFIG_USART1_SERIAL_CONSOLE=y
CONFIG_USART1_RXBUFSIZE=256
CONFIG_USART1_TXBUFSIZE=256
CONFIG_USART1_BAUD=115200
CONFIG_USART1_BITS=8
CONFIG_USART1_PARITY=0
CONFIG_USART1_2STOP=0
</code></pre><h3 id="usart2" tabindex="-1">USART2 <a class="header-anchor" href="#usart2" aria-label="Permalink to &quot;USART2&quot;">​</a></h3><p>Pins and Connectors:</p><pre><code>RXD: PA3   CN9 pin 1 (See SB13, 14, 62, 63). CN10 pin 37
     PD6
TXD: PA2   CN9 pin 2(See SB13, 14, 62, 63). CN10 pin 35
     PD5
</code></pre><p>UART2 is the default in all of these configurations.</p><p>TTL to RS-232 converter connection:</p><pre><code>Nucleo CN9  STM32L432KC
----------- ------------
Pin 1  PA3  USART2_RX   *Warning you make need to reverse RX/TX on
Pin 2  PA2  USART2_TX    some RS-232 converters
</code></pre><p>Solder Bridges. This configuration requires:</p><ul><li>SB62 and SB63 Closed: PA2 and PA3 on STM32 MCU are connected to D1 and D0 (pin 7 and pin 8) on Arduino connector CN9 and ST Morpho connector CN10 as USART signals. Thus SB13 and SB14 should be OFF.</li><li>SB13 and SB14 Open: PA2 and PA3 on STM32F103C8T6 (ST-LINK MCU) are disconnected to PA3 and PA2 on STM32 MCU.</li></ul><p>To configure USART2 as the console:</p><pre><code>CONFIG_STM32_USART2=y
CONFIG_USART2_SERIALDRIVER=y
CONFIG_USART2_SERIAL_CONSOLE=y
CONFIG_USART2_RXBUFSIZE=256
CONFIG_USART2_TXBUFSIZE=256
CONFIG_USART2_BAUD=115200
CONFIG_USART2_BITS=8
CONFIG_USART2_PARITY=0
CONFIG_USART2_2STOP=0
</code></pre><h3 id="virtual-com-port" tabindex="-1">Virtual COM Port <a class="header-anchor" href="#virtual-com-port" aria-label="Permalink to &quot;Virtual COM Port&quot;">​</a></h3><p>Yet another option is to use UART2 and the USB virtual COM port. This option may be more convenient for long term development, but is painful to use during board bring-up.</p><p>Solder Bridges. This configuration requires:</p><ul><li>SB62 and SB63 Open: PA2 and PA3 on STM32 MCU are disconnected to D1 and D0 (pin 7 and pin 8) on Arduino connector CN9 and ST Morpho connector CN10.</li><li>SB13 and SB14 Closed: PA2 and PA3 on STM32F103C8T6 (ST-LINK MCU) are connected to PA3 and PA2 on STM32 MCU to have USART communication between them. Thus SB61, SB62 and SB63 should be OFF.</li></ul><p>Configuring USART2 is the same as given above.</p><p>Question: What BAUD should be configure to interface with the Virtual COM port? 115200 8N1?</p><h3 id="default" tabindex="-1">Default <a class="header-anchor" href="#default" aria-label="Permalink to &quot;Default&quot;">​</a></h3><p>As shipped, SB62 and SB63 are open and SB13 and SB14 closed, so the virtual COM port is enabled.</p><h2 id="spi-flash-support" tabindex="-1">SPI Flash support: <a class="header-anchor" href="#spi-flash-support" aria-label="Permalink to &quot;SPI Flash support:&quot;">​</a></h2><p>We can use an external SPI Serial Flash with nucleo-l432kc board. In this case we tested with AT45DB081D (8Mbit = 1MiB).</p><p>You can connect the AT45DB081D memory in the nucleo-l432kc board this way:</p><blockquote><p>Memory nucleo-l432kc</p><hr><p>SI D11 (PB5) SCK D13 (PB3) RESET 3V3 CS D10 (PA11) WP 3V3 VCC 3V3 GND GND SO D12 (PB4)</p></blockquote><p>You can start with default &quot;nucleo-l432kc/nsh&quot; configuration option and enable/disable these options using &quot;make menuconfig&quot; :</p><pre><code>System Type  ---&gt;
    STM32L4 Peripheral Support  ---&gt;
        [*] SPI1

Device Drivers  ---&gt;
    -*- Memory Technology Device (MTD) Support  ---&gt;
            -*-   SPI-based AT45DB flash
            (1000000) AT45DB Frequency

File Systems  ---&gt;
    [*] NXFFS file system

Then after compiling and flashing the file nuttx.bin you can test the flash
this way:

nsh&gt; ls /mnt
/mnt:
 at45db/

nsh&gt; echo &quot;Testing&quot; &gt; /mnt/at45db/file.txt

nsh&gt; ls /mnt/at45db
/mnt/at45db:
 file.txt

nsh&gt; cat /mnt/at45db/file.txt
Testing

nsh&gt;
</code></pre><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><h3 id="nsh" tabindex="-1">nsh: <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh:&quot;">​</a></h3><p>Configures the NuttShell (nsh) located at apps/examples/nsh for the Nucleo-L432KC board. The Configuration enables the serial interfaces on UART2. Support for builtin applications is enabled, but in the base configuration no builtin applications are selected (see NOTES below).</p><p>NOTES:</p><ol><li><p>This configuration uses the mconf-based configuration tool. To change this configuration using that tool, you should:</p><p>a. Build and install the kconfig-mconf tool. See nuttx/README.txt see additional README.txt files in the NuttX tools repository. b. Execute &#39;make menuconfig&#39; in nuttx/ in order to start the reconfiguration process.</p></li><li><p>By default, this configuration uses the ARM EABI toolchain for Linux. That can easily be reconfigured, of course.:</p><pre><code>CONFIG_HOST_LINUX=y                     : Builds under Linux
CONFIG_ARM_TOOLCHAIN_GNU_EABI=y      : GNU EABI toolchain for Linux
</code></pre></li><li><p>Although the default console is USART2 (which would correspond to the Virtual COM port) I have done all testing with the console device configured for USART1 (see instruction above under &quot;Serial Consoles). I have been using a TTL-to-RS-232 converter connected as shown below:</p><pre><code>Nucleo CN10 STM32L432KC
----------- ------------
Pin 21 PA9  USART1_RX   *Warning you make need to reverse RX/TX on
Pin 33 PA10 USART1_TX    some RS-232 converters
Pin 20 GND
Pin 8  U5V
</code></pre></li></ol><h3 id="spwm" tabindex="-1">spwm <a class="header-anchor" href="#spwm" aria-label="Permalink to &quot;spwm&quot;">​</a></h3><p>Configures the sinusoidal PWM (SPWM) example which presents a simple use case of the STM32L4 PWM lower-half driver without generic upper-half PWM logic.</p><p>It uses TIM1 to generate PWM and TIM6 to change waveform samples</p><p>At the moment, the waveform parameters are hardcoded, but it should be easy to modify this example and make it more functional.</p>`,93)]))}const m=o(a,[["render",l]]);export{p as __pageData,m as default};
