import{_ as t,c as a,al as o,o as s}from"./chunks/framework.NFAqBSgQ.js";const i="/assets/simulation.BcQmRCSU.png",m=JSON.parse('{"title":"The NuttX Simulation","description":"","frontmatter":{},"headers":[],"relativePath":"en/implementation/simulation.md","filePath":"en/implementation/simulation.md"}'),n={name:"en/implementation/simulation.md"};function l(r,e,c,h,d,p){return s(),a("div",null,e[0]||(e[0]=[o('<h1 id="the-nuttx-simulation" tabindex="-1">The NuttX Simulation <a class="header-anchor" href="#the-nuttx-simulation" aria-label="Permalink to &quot;The NuttX Simulation&quot;">​</a></h1><p>The NuttX simulation is a port of NuttX to run as a process under Linux or Cygwin and probably other POSIX contexts as well.</p><p>Reference: The <code>sim</code> configuration file [[/platform](]{.title-ref}/platform.md)s/sim/sim/index`.</p><h2 id="how-the-simulator-is-built" tabindex="-1">How the Simulator is Built <a class="header-anchor" href="#how-the-simulator-is-built" aria-label="Permalink to &quot;How the Simulator is Built&quot;">​</a></h2><p>The simulator isn&#39;t a virtual machine or anything like that. It is just a single thread that implements a non-preemptive version of NuttX using <code>setjmp</code>/<code>longjmp</code> to do the context switches.</p><p><img src="'+i+`" alt="" class="align-center"></p><h2 id="the-nuttx-rel-blob" tabindex="-1">The nuttx.rel Blob <a class="header-anchor" href="#the-nuttx-rel-blob" aria-label="Permalink to &quot;The nuttx.rel Blob&quot;">​</a></h2><p>The first thing that you have to understand is how the simulation is built. Look at <code>arch/sim/src/Makefile</code>. This target builds the NuttX executable (simplified for clarity):</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nuttx(EXEEXT): nuttx.rel (HOSTOBJS)</span></span>
<span class="line"><span>    (CC) (CCLINKFLAGS) (LIBPATHS) -o (TOPDIR)/@ nuttx.rel (HOSTOBJS) (DRVLIB) (STDLIBS)</span></span></code></pre></div></blockquote><p>The secret is <code>nuttx.rel</code>. That is a blob that contains the entire Nuttx simulation. It is built like this:</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nuttx.rel : libarch(LIBEXT) board/libboard(LIBEXT) (HOSTOS)-names.dat (LINKOBJS)</span></span>
<span class="line"><span>    (LD) -r (LDLINKFLAGS) (RELPATHS) (EXTRA_LIBPATHS) -o @ (REQUIREDOBJS) --start-group (RELLIBS) (EXTRA_LIBS) --end-group</span></span>
<span class="line"><span>    (OBJCOPY) --redefine-syms=(HOSTOS)-names.dat @</span></span></code></pre></div></blockquote><p>The first <code>(LD)</code> builds a partially linked, relocatable object (hence, the extension <code>.rel</code>). This contains all of the NuttX objects. So <code>nuttx.rel</code> is the entire &quot;fish bowl&quot; that the NuttX simulation lives.</p><p>The second <code>(OBJCOPY)</code> line is the thing the irrevocable severs the NuttX &quot;fish bowl&quot; from the host environment. It renames most of the symbols in <code>nuttx.rel</code> so that they do not collide with the symbols use by the host system. Look in <code>arch/sim/src/nuttx-names.dat</code>. So <code>open()</code> becomes <code>NXopen()</code>, <code>close()</code> becomes <code>NXclose()</code>, read becomes <code>NXread()</code>, etc.</p><h2 id="the-hostobj-blob" tabindex="-1">The (HOSTOBJ) Blob <a class="header-anchor" href="#the-hostobj-blob" aria-label="Permalink to &quot;The \\(HOSTOBJ) Blob&quot;">​</a></h2><p>The <code>(HOSTOBJS)</code> contains the final host interface. This is the host PC blob and in this one, there is no re-naming: <code>open()</code> goes to the real system <code>open()</code>, <code>close()</code> goes to the real system <code>close()</code>, etc. When these two blobs are linked together in the final <code>(CC</code>, you have the simulation.</p><h2 id="accessing-host-devices-using-fifos" tabindex="-1">Accessing Host Devices Using FIFOs? <a class="header-anchor" href="#accessing-host-devices-using-fifos" aria-label="Permalink to &quot;Accessing Host Devices Using FIFOs?&quot;">​</a></h2><h3 id="general-concepts" tabindex="-1">General Concepts <a class="header-anchor" href="#general-concepts" aria-label="Permalink to &quot;General Concepts&quot;">​</a></h3><p>When you write the code in the simulation, it runs in the NuttX blob and can only interface with NuttX interfaces. It cannot interact directly with the host system. It cannot <code>open()</code>, <code>close()</code>, <code>read()</code>, or access a host device driver in any way (because it cannot get to the host system namespace).</p><p>To further complicate things, nothing in the simulation can call into a host interface that blocks. Why? Because this is not a NuttX blocking call, this is a host system blocking call. It just not block that one NuttX thread; it blocks the entire simulation!</p><p>But you can add special, low level interface between the NuttX and the Host blobs so that they can communicate. The Host blob could access the host device in some and provide some authentic NuttX driver interface to the simulation in some fashion.</p><p>If you want to access a host device driver, then the code that does that has to reside in the Host blob (i.e., it is in <code>(HOSTOS</code>)). Only there can it interact with the host OS. And there, you can do things like create a host pthread to service a device interface. That pthread can wait for I/O without blocking the whole simulation on the main thread (that is how the simulated console I/O works, for example).</p><h2 id="toward-a-general-design" tabindex="-1">Toward a General Design <a class="header-anchor" href="#toward-a-general-design" aria-label="Permalink to &quot;Toward a General Design&quot;">​</a></h2><p>There is no design in place for accessing Host devices from the simulation. Here are some directions that I would investigate, however.</p><p>Perhaps you could create a NuttX FIFO in the NuttX blob. It would reside at, say, <code>/dev/mydevice</code> in the NuttX VFS. Perhaps this FIFO could be used in the NuttX world as your character device? Perhaps it could read and write from FIFOs to intermediate the interaction with the host PC device?</p><p>On the NuttX side the target logic would call <code>open()</code>, <code>close()</code>, <code>read()</code>, ... to access the FIFO. These are, of course, really <code>NXopen()</code>, <code>NXclose()</code>, <code>NXread()</code>, ...</p><p>On the Host PC side it would call <code>open()</code>, <code>close()</code>, <code>read()</code>, .. to access the host device driver. These are real host device accesses. But some code in the host blob should also be able to call <code>NXopen()</code>, <code>NXclose()</code>, <code>NXwrite()</code>, etc. to access the NuttX FIFO. So there might be a pthread in the host blob that does something like this:</p><ol><li>Open a real PC device O_RDONLY using open()</li><li>Open a FIFO in using NXopen()</li><li>Read from the device using read(). This blocks, but only the host pthread that is intermediating the I/O.</li><li>When read data is obtained, call NXwrite() to write the data to the NuttX FIFO</li><li>etc.</li></ol><p>In this way, the pthread in the host blob would be conduit that maps the host device to a NuttX FIFO. Within the NuttX blob, simulation logic should be able to open, close, read, etc. the FIFO just as though it were the real device.</p><blockquote><p>NuttX Target Code &lt;---&gt;NuttX FIFO&lt;---&gt;Host Interface&lt;----&gt;Host Driver</p></blockquote><h2 id="what-is-wrong-with-that" tabindex="-1">What is Wrong With That? <a class="header-anchor" href="#what-is-wrong-with-that" aria-label="Permalink to &quot;What is Wrong With That?&quot;">​</a></h2><p>There is a one big problem: if logic in the Host blob calls <code>NXwrite()</code>, that could potentially cause a NuttX context switch. Remember that a context switch is really a <code>setjmp()</code> that saves the current context followed by a <code>longjmp()</code> that switches to the new context. All of this must happen on the main thread of the simulation.</p><p>But if <code>NXwrite()</code> causes a context switch, then the switch would occur on the pthread of the Host device handler! That would be very bad. The Host driver could not return until all of the NuttX tasks finally terminate. That would need to be avoided.</p><p>The NuttX serial console interface faces all of these same problems: It simulates a NuttX device, <code>/dev/console</code> using the Host <code>stdin</code> and <code>stdout</code>. How does it avoid this problem? Not in a very pretty way. It puts the received data in a FIFO; When all of the NuttX tasks become IDLE the simulations IDLE thread runs, it empties the queued data to the console which can then cause a context switch. But now this is okay because the IDLE thread is correctly running on the main thread of the simulation.</p><p>Pretty kludgey. This just begs for a better solution. If only the simulation supported interrupts...</p><h2 id="simulated-interrupts" tabindex="-1">Simulated Interrupts <a class="header-anchor" href="#simulated-interrupts" aria-label="Permalink to &quot;Simulated Interrupts&quot;">​</a></h2><p>The current NuttX host simulation has no interrupts and, hence, is non-preemptible. Also, without simulated interrupts, there can be no high-fidelity simulated device drivers or precise timer interrupt.</p><p>Currently, all timing and serial input is simulated in the IDLE loop: When nothing is going on in the simulation, the IDLE loop runs and fakes timer and UART events.</p><p>I have been thinking about how to implement simulated interrupts in the simulation. I think a solution would work like this.</p><blockquote><ul><li><p>In the earliest initialization, simulator could start a host simulation interrupt thread and setup a signal handler to catch signals on the main thread. One signal, say <code>SIGUSER</code> could indicate a context switch. This would be a type <code>SA_SIGINFO</code> and the context switch information would be provided in the <code>sival_t</code> field of the <code>siginfo</code>.</p></li><li><p>Interrupt logic could be implemented on a host pthread. The host pthread, like a hardware interrupt, executes asynchronously outside of the operating system. The interrupt thread could wait for a host signal or a host message and, upon receipt, perform simulated interrupt logic.</p></li><li><p><code>up_interrupt_context()</code> would need to be implemented; it is only a stub now. I think this could be done with a simple global boolean like:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>bool g_in_interrupt;</span></span>
<span class="line"><span>xcpt_reg_t g_context_regs;</span></span></code></pre></div></li></ul></blockquote><p>Simulated interrupt handling logic would set <code>g_in_interrupt</code> on entry and clear it on exit (perhaps it would be better to have a counter and increment it interrupt entry and decrement it on exit?). The interrupt handler would also need to clear <code>g_context_regs</code> on entry. <code>up_interrupt_contest()</code> would then just report the state of the boolean.</p><blockquote><ul><li>All context switching functions would also need to check this boolean (<code>up_block_task()</code>, <code>up_unblock_task()</code>, <code>up_reprioritize_rtr()</code>, <code>up_releasepending()</code> and perhaps others). It set, they should not perform the context switch. Instead, they should set <code>g_context_regs</code> to the context switch register array.</li></ul><blockquote><ul><li>Before <em>returning</em> and before clearing <code>g_in_interrupt</code>, the host simulated interrupt logic would check <code>g_context_regs</code>. If non-NULL, then a context switch is required on <em>return</em> from the simulated interrupt. In this case, the simulation thread would signal the main thread with the <code>SIGUSER</code> signal.</li><li>The <code>SIGUSER</code> signal handler would perform the context with logic something like the following:</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct tcb_s *rtcb = sched_self();              /* Get the TCB of the currently executing thread */</span></span>
<span class="line"><span>xcpt_reg_t *regs = siginfo-&gt;si_value.sival_ptr; /* The new register state to be instantiated */</span></span>
<span class="line"><span>if (!up_setjump(rtcb-&gt;xcp.regs)                 /* Save the current context */</span></span>
<span class="line"><span>  {</span></span>
<span class="line"><span>    up_longjmp(regs);                           /* Instantiate the new context */</span></span>
<span class="line"><span>  }</span></span></code></pre></div></blockquote></blockquote><p>When we switch back to this thread, or course, it will appear as another return from <code>up_setjmp()</code>, but this time with a non-zero return value.</p><p>The threading is a little mind-bending. The signal handler needs to run in the context on the main thread. The main thread is actually using the allocation NuttX stack and is executed the NuttX code. When the signal handler executes, it should execute on a stack frame added to the stack of the currently executing NuttX task.</p><p>When <code>up_longjmp()</code> is executing, operation will continue under the main thread, but the context including the stack are different for the new NuttX thread. When the context finally switches back to this thread, it will appear as an appear return from <code>up_setjmp()</code> with a non-zero return value. In that case, the signal handler will just return and the normal execution of the preempted NuttX task will resume.</p><p><strong>Issues</strong>. My only real technical questions involve signal masking. When the <code>SIGUSER</code> signal handler executes, the <code>SIGUSER</code> interrupt will be masked. That would prevent any further context switches until the signal handler returns. Can we simply <em>unmask</em> <code>SIGUSER</code> signal to get more context switches? I would need to experiment to know for sure.</p><h2 id="supported-devices" tabindex="-1">Supported Devices <a class="header-anchor" href="#supported-devices" aria-label="Permalink to &quot;Supported Devices&quot;">​</a></h2><h3 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h3><p>The simulation&#39;s serial console is provided by wrapping host <em>stdin</em> and <em>stdout</em> so that it appears to be <code>/dev/console</code>. Serial data from the host <em>stdin</em> is sampled in the IDLE loop. If serial data is available, the IDLE loop will <em>post</em> simulated UART activity. The fidelity of this simulation could be improved with simulated interrupts when UART data is available.</p><h3 id="host-file-system-access" tabindex="-1">Host File System Access <a class="header-anchor" href="#host-file-system-access" aria-label="Permalink to &quot;Host File System Access&quot;">​</a></h3><p>Host file system access is supported via the <em>nxfuse</em> user-space file system that you can find in the NuttX <a href="https://bitbucket.org/nuttx/tools/src/master/nxfuse/" target="_blank" rel="noreferrer">https://bitbucket.org/nuttx/tools/src/master/nxfuse/</a> repository. Instructions for using the <em>nxfuse</em> file system can be found in a <a href="https://bitbucket.org/nuttx/tools/src/master/nxfuse/README.txt" target="_blank" rel="noreferrer">https://bitbucket.org/nuttx/tools/src/master/nxfuse/README.txt</a> in that repository directory.</p><h3 id="networking" tabindex="-1">Networking <a class="header-anchor" href="#networking" aria-label="Permalink to &quot;Networking&quot;">​</a></h3><p>Networking is supported for the simulation using TUN/TAP interface under Linux or using WPCap under Windows. A README file providing instruction for setting up the TUN/TAP interface under Linux is provided in the [[/platform](]{.title-ref}/platform.md)s/sim/sim/index\`. The network is again handled by the IDLE loop in the simulator and could benefit from simulated interrupts.</p><h3 id="usb" tabindex="-1">USB <a class="header-anchor" href="#usb" aria-label="Permalink to &quot;USB&quot;">​</a></h3><p>At one time, there was an effort underway on GitHub to port <code>libusb</code> into NuttX in order to support USB devices in the simulation. That effort was never completed although is it still a very good idea.</p><h3 id="lcd" tabindex="-1">LCD <a class="header-anchor" href="#lcd" aria-label="Permalink to &quot;LCD&quot;">​</a></h3><p>X11 framebuffers can be used to simulate NuttX graphics framebuffer devices. These are, again, managed in the IDLE loop.</p><h3 id="smp" tabindex="-1">SMP <a class="header-anchor" href="#smp" aria-label="Permalink to &quot;SMP&quot;">​</a></h3><p>There is a simulator configuration has basic support for SMP testing. The simulation supports the emulation of multiple CPUs by creating multiple pthreads, each run a copy of the simulation in the same process address space.</p><p>At present, the SMP simulation is not fully functional: It does operate on the simulated CPU threads for a few context switches then fails during a setjmp() operation. I suspect that this is not an issue with the NuttX SMP logic but more likely some chaos in the pthread controls. I have seen similar such strange behavior other times that I have tried to use setjmp/longmp from a signal handler! Like when I tried to implement simulated interrupts using signals.</p><p>Apparently, if longjmp is invoked from the context of a signal handler, the result is undefined: <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1318.htm" target="_blank" rel="noreferrer">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1318.htm</a></p><p>You can enable SMP for ostest configuration by enabling:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Add:     CONFIG_SPINLOCK=y</span></span>
<span class="line"><span>Add:     CONFIG_SMP=y</span></span>
<span class="line"><span>Add:     CONFIG_SMP_NCPUS=2</span></span>
<span class="line"><span>Add:     CONFIG_SMP_IDLETHREAD_STACKSIZE=2048</span></span></code></pre></div><p>You also must enable near-realtime-performance otherwise even long timeouts will expire before a CPU thread even has a chance to execute.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Remove:  # CONFIG_SIM_WALLTIME is not set</span></span>
<span class="line"><span>Add:     CONFIG_SIM_WALLTIME=y</span></span></code></pre></div><p>And you can enable some additional debug output with:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Remove:  # CONFIG_DEBUG_SCHED is not set</span></span>
<span class="line"><span>Add:     CONFIG_DEBUG_SCHED=y</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Remove:  # CONFIG_SCHED_INSTRUMENTATION is not set</span></span>
<span class="line"><span>Add:     CONFIG_SCHED_INSTRUMENTATION=y</span></span></code></pre></div><p>The SMP configuration will run with:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CONFIG_SMP_NCPUS=1</span></span></code></pre></div><p>In this case there is, of course, no multi-CPU processing, but this does verify the correctness of some the basic SMP logic in a simpler environment.</p><p>The NSH configuration can also be forced to run SMP, but suffers from the same quirky behavior. It can be made reliable if you modify <code>arch/sim/src/up_idle.c</code> so that the IDLE loop only runs for CPU0. Otherwise, often <code>simuart_post()</code> will be called from CPU1 and it will try to restart NSH on CPU0 and, again, the same quirkiness occurs.</p><p>But for example, this command:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>nsh&gt; sleep 1 &amp;</span></span></code></pre></div><p>will execute the sleep command on CPU1 which has worked every time that I have tried it (which is not too many times).</p>`,73)]))}const b=t(n,[["render",l]]);export{m as __pageData,b as default};
