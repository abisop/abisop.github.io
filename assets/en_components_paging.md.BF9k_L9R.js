import{_ as o,c as l,al as a,j as e,a as t,o as r}from"./chunks/framework.NFAqBSgQ.js";const f=JSON.parse('{"title":"On-Demand Paging","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/paging.md","filePath":"en/components/paging.md"}'),n={name:"en/components/paging.md"};function s(c,i,h,d,p,u){return r(),l("div",null,i[0]||(i[0]=[a('<h1 id="on-demand-paging" tabindex="-1">On-Demand Paging <a class="header-anchor" href="#on-demand-paging" aria-label="Permalink to &quot;On-Demand Paging&quot;">​</a></h1><h2 id="kernel-build-implementation" tabindex="-1">Kernel Build Implementation <a class="header-anchor" href="#kernel-build-implementation" aria-label="Permalink to &quot;Kernel Build Implementation&quot;">​</a></h2><p>On-demand paging and lazy loading are techniques used to manage physical memory. The basic idea is to allow a program to execute even though the entire program is not resident in memory. The program is loaded into memory on demand. This is a technique that is used in many operating systems to allow large programs to execute on small memory systems. Commonly, a Memory Management Unit (MMU) is used to map virtual memory into physical memory. Applications are then loaded into virtual memory address spaces and access to physical memory is managed by the MMU. If the virtual memory is not resident in physical memory, then a page fault occurs. The operating system then loads the missing page into memory and resumes execution.</p><h3 id="requirements-and-assumptions" tabindex="-1">Requirements and Assumptions <a class="header-anchor" href="#requirements-and-assumptions" aria-label="Permalink to &quot;Requirements and Assumptions&quot;">​</a></h3><p>On-demand paging requires <em>Kernel Build</em> (<code>CONFIG_BUILD_KERNEL=y</code>) mode. In this mode, no applications are built within the NuttX kernel. Instead, the applications are built as separate programs that are loaded into memory (<code>CONFIG_ELF=y</code> and <code>CONFIG_BINFMT_LOADABLE=y</code>). In this mode, each process has its own address environment (<code>CONFIG_ARCH_ADDRENV=y</code>).</p><h3 id="logic-design-description" tabindex="-1">Logic Design Description <a class="header-anchor" href="#logic-design-description" aria-label="Permalink to &quot;Logic Design Description&quot;">​</a></h3><p>When an application is being loaded <code>up_addrenv_create</code> is called to create the process&#39;s address environment. This includes mapping the commonly used <code>text</code>, <code>data</code> and <code>heap</code> sections within the virtual memory space. Without on-demand paging, the physical memory is then allocated and mapped accordingly, before the process is started. When on-demand paging is enabled, usually only one single page for each section is allocated and mapped.</p><p>The process starts executing within its address environment, accessing the virtual memory. Whenever it tries to access a virtual memory address that is not mapped in the MMU, a page fault occurs. The MMU then triggers an exception that is handled by the kernel. The kernel then checks if there are enough free physical pages available and maps the virtual memory address to it. Finally, execution is resumed from the same point where the page fault first occurred.</p><h4 id="example-risc-v" tabindex="-1">Example: RISC-V <a class="header-anchor" href="#example-risc-v" aria-label="Permalink to &quot;Example: RISC-V&quot;">​</a></h4><p>RISC-V&#39;s <code>up_addrenv_create</code> calls <code>create_region</code> (both defined in <code>arch/risc-v/src/common/riscv_addrenv.c</code>). <code>create_region</code> maps a single region to MMU by allocating physical memory for the page tables. When <code>CONFIG_PAGING=y</code> is not selected, all the physical page tables are allocated from the physical memory space and then mapped to the virtual memory space. When <code>CONFIG_PAGING=y</code> is selected, only the first page of each section is mapped to the virtual memory space. The rest of the pages are mapped to the virtual memory space only when a page fault occurs.</p><p>The page fault is handled by the <code>riscv_fillpage</code> function in the exception handler (defined in <code>arch/risc-v/src/common/riscv_exception.c</code>). Whenever a page fault occurs, the <code>riscv_fillpage</code> function is called. This function allocates a physical page and maps it to the virtual memory space that triggered the page fault exception and then resumes execution from the same point where the page fault first occurred.</p>',11),e("p",null,[e("code",{class:"interpreted-text",role:"ref"},"knsh_paging"),t(" simulates a device with 4MiB physical memory with 8MiB of virtual heap memory allocated for each process. This is possible by enabling on-demand paging.")],-1),a('<h2 id="legacy-implementation" tabindex="-1">Legacy Implementation <a class="header-anchor" href="#legacy-implementation" aria-label="Permalink to &quot;Legacy Implementation&quot;">​</a></h2><p>This legacy implementation runs on <em>Flat Build</em> (<em>Kernel Build</em> did not even exist at that time).</p><p>What kind of platforms can support NuttX legacy on-demand paging?</p><blockquote><ol><li>The MCU should have some large, probably low-cost non-volatile storage such as serial FLASH or an SD card. This storage probably does not support non-random access (otherwise, why not just execute the program directly on the storage media). SD and serial FLASH are inexpensive and do not require very many pins and SPI support is prevalent in just about all MCUs. This large serial FLASH would contain a big program. Perhaps a program of several megabytes in size.</li><li>The MCU must have a (relatively) small block of fast SRAM from which it can execute code. A size of, say 256K (or 192K as in the NXP LPC3131) would be sufficient for many applications.</li><li>The MCU has an MMU (again like the NXP LPC3131).</li></ol></blockquote><p>If the platform meets these requirements, then NuttX can provide on-demand paging: It can copy .text from the large program in non-volatile media into RAM as needed to execute a huge program from the small RAM.</p><h3 id="terminology" tabindex="-1">Terminology <a class="header-anchor" href="#terminology" aria-label="Permalink to &quot;Terminology&quot;">​</a></h3><blockquote><p><code>g_waitingforfill</code>:</p><p>: An OS list that is used to hold the TCBs of tasks that are waiting for a page fill.</p><p><code>g_pftcb</code>:</p><p>: A variable that holds a reference to the TCB of the thread that is currently be re-filled.</p><p><code>g_pgworker</code>:</p><p>: The <em>process</em> ID of the thread that will perform the page fills.</p><p><code>pg_callback()</code>:</p><p>: The callback function that is invoked from a driver when the fill is complete.</p><p><code>pg_miss()</code>:</p><p>: The function that is called from architecture-specific code to handle a page fault.</p><p><code>TCB</code>:</p><p>: Task Control Block</p></blockquote><h3 id="nuttx-common-logic-design-description" tabindex="-1">NuttX Common Logic Design Description <a class="header-anchor" href="#nuttx-common-logic-design-description" aria-label="Permalink to &quot;NuttX Common Logic Design Description&quot;">​</a></h3><h4 id="initialization" tabindex="-1">Initialization <a class="header-anchor" href="#initialization" aria-label="Permalink to &quot;Initialization&quot;">​</a></h4><p>The following declarations will be added.</p><ul><li><code>g_waitingforfill</code>. A doubly linked list that will be used to implement a prioritized list of the TCBs of tasks that are waiting for a page fill.</li><li><code>g_pgworker</code>. The <em>process</em> ID of the thread that will perform the page fills</li></ul><p>During OS initialization in <code>sched/init/nx_start.c</code>, the following steps will be performed:</p><ul><li>The <code>g_waitingforfill</code> queue will be initialized.</li><li>The special, page fill worker thread, will be started. The <code>pid</code> of the page will worker thread will be saved in <code>g_pgworker</code>. Note that we need a special worker thread to perform fills; we cannot use the &quot;generic&quot; worker thread facility because we cannot be assured that all actions called by that worker thread will always be resident in memory.</li></ul><p>Declarations for <code>g_waitingforfill</code>, <code>g_pgworker</code>, and other internal, private definitions will be provided in <code>sched/paging/paging.h</code>. All public definitions that should be used by the architecture-specific code will be available in <code>include/nuttx/page.h</code>. Most architecture-specific functions are declared in <code>include/nuttx/arch.h</code>, but for the case of this paging logic, those architecture specific functions are instead declared in <code>include/nuttx/page.h</code>.</p><h4 id="page-faults" tabindex="-1">Page Faults <a class="header-anchor" href="#page-faults" aria-label="Permalink to &quot;Page Faults&quot;">​</a></h4><p><strong>Page fault exception handling</strong>. Page fault handling is performed by the function <code>pg_miss()</code>. This function is called from architecture-specific memory segmentation fault handling logic. This function will perform the following operations:</p><ol><li><strong>Sanity checking</strong>. This function will ASSERT if the currently executing task is the page fill worker thread. The page fill worker thread is how the page fault is resolved and all logic associated with the page fill worker must be &quot;<a href="#MemoryOrg">locked</a>&quot; and always present in memory.</li><li><strong>Block the currently executing task</strong>. This function will call <code>up_switch_context()</code> to block the task at the head of the ready-to-run list. This should cause an interrupt level context switch to the next highest priority task. The blocked task will be marked with state <code>TSTATE_WAIT_PAGEFILL</code> and will be retained in the <code>g_waitingforfill</code> prioritized task list.</li><li><strong>Boost the page fill worker thread priority</strong>. Check the priority of the task at the head of the <code>g_waitingforfill</code> list. If the priority of that task is higher than the current priority of the page fill worker thread, then boost the priority of the page fill worker thread to that priority. Thus, the page fill worker thread will always run at the priority of the highest priority task that is waiting for a fill.</li><li><strong>Signal the page fill worker thread</strong>. Is there a page already being filled? If not then signal the page fill worker thread to start working on the queued page fill requests.</li></ol><p>When signaled from <code>pg_miss()</code>, the page fill worker thread will be awakenend and will initiate the fill operation.</p><p><strong>Input Parameters.</strong> None -- The head of the ready-to-run list is assumed to be that task that caused the exception. The current task context should already be saved in the TCB of that task. No additional inputs are required.</p><p><strong>Assumptions</strong>.</p><ul><li>It is assumed that this function is called from the level of an exception handler and that all interrupts are disabled.</li><li>The <code>pg_miss()</code> must be &quot;<a href="#MemoryOrg">locked</a>&quot; in memory. Calling <code>pg_miss()</code> cannot cause a nested page fault.</li><li>It is assumed that currently executing task (the one at the head of the ready-to-run list) is the one that cause the fault. This will always be true unless the page fault occurred in an interrupt handler. Interrupt handling logic must always be available and &quot;<a href="#MemoryOrg">locked</a>&quot; into memory so that page faults never come from interrupt handling.</li><li>The architecture-specific page fault exception handling has already verified that the exception did not occur from interrupt/exception handling logic.</li><li>As mentioned above, the task causing the page fault must not be the page fill worker thread because that is the only way to complete the page fill.</li></ul><h4 id="fill-initiation" tabindex="-1">Fill Initiation <a class="header-anchor" href="#fill-initiation" aria-label="Permalink to &quot;Fill Initiation&quot;">​</a></h4><p>The page fill worker thread will be awakened on one of three conditions:</p><ul><li>When signaled by <code>pg_miss()</code>, the page fill worker thread will be awakenend (see above),</li><li>From <code>pg_callback()</code> after completing last fill (when <code>CONFIG_PAGING_BLOCKINGFILL</code> is defined... see below), or</li><li>A configurable timeout expires with no activity. This timeout can be used to detect failure conditions such things as fills that never complete.</li></ul><p>The page fill worker thread will maintain a static variable called <code>struct tcb_s *g_pftcb</code>. If no fill is in progress, <code>g_pftcb</code> will be NULL. Otherwise, it will point to the TCB of the task which is receiving the fill that is in progress.</p><p>When awakened from <code>pg_miss()</code>, no fill will be in progress and <code>g_pftcb</code> will be NULL. In this case, the page fill worker thread will call <code>pg_startfill()</code>. That function will perform the following operations:</p><ul><li>Call the architecture-specific function <code>up_checkmapping()</code> to see if the page fill still needs to be performed. In certain conditions, the page fault may occur on several threads and be queued multiple times. In this corner case, the blocked task will simply be restarted (see the logic below for the case of normal completion of the fill operation).</li><li>Call <code>up_allocpage(tcb, &amp;vpage)</code>. This architecture-specific function will set aside page in memory and map to virtual address (vpage). If all available pages are in-use (the typical case), this function will select a page in-use, un-map it, and make it available.</li><li>Call the architecture-specific function <code>up_fillpage()</code>. Two versions of the up_fillpage function are supported -- a blocking and a non-blocking version based upon the configuration setting <code>CONFIG_PAGING_BLOCKINGFILL</code>. <ul><li><p>If <code>CONFIG_PAGING_BLOCKINGFILL</code> is defined, then up_fillpage is blocking call. In this case, <code>up_fillpage()</code> will accept only</p><p>(1) a reference to the TCB that requires the fill. Architecture-specific context information within the TCB will be sufficient to perform the fill. And (2) the (virtual) address of the allocated page to be filled. The resulting status of the fill will be provided by return value from <code>up_fillpage()</code>.</p></li><li><p>If <code>CONFIG_PAGING_BLOCKINGFILL</code> is defined, then up_fillpage is non-blocking call. In this case <code>up_fillpage()</code> will accept an additional argument: The page fill worker thread will provide a callback function, <code>pg_callback</code>. This function is non-blocking, it will start an asynchronous page fill. After calling the non-blocking <code>up_fillpage()</code>, the page fill worker thread will wait to be signaled for the next event -- the fill completion event. The callback function will be called when the page fill is finished (or an error occurs). The resulting status of the fill will be providing as an argument to the callback functions. This callback will probably occur from interrupt level.</p></li></ul></li></ul><p>In any case, while the fill is in progress, other tasks may execute. If another page fault occurs during this time, the faulting task will be blocked, its TCB will be added (in priority order) to <code>g_waitingforfill</code>, and the priority of the page worker task may be boosted. But no action will be taken until the current page fill completes. NOTE: The IDLE task must also be fully <a href="#MemoryOrg">locked</a> in memory. The IDLE task cannot be blocked. It the case where all tasks are blocked waiting for a page fill, the IDLE task must still be available to run.</p><p>The architecture-specific functions, <code>up_checkmapping()</code>, <code>up_allocpage(tcb, &amp;vpage)</code> and <code>up_fillpage(page, pg_callback)</code> will be prototyped in <code>include/nuttx/arch.h</code></p><h4 id="fill-complete" tabindex="-1">Fill Complete <a class="header-anchor" href="#fill-complete" aria-label="Permalink to &quot;Fill Complete&quot;">​</a></h4><p>For the blocking <code>up_fillpage()</code>, the result of the fill will be returned directly from the call to <code>up_fillpage</code>.</p><p>For the non-blocking <code>up_fillpage()</code>, the architecture-specific driver call the <code>pg_callback()</code> that was provided to <code>up_fillpage()</code> when the fill completes. In this case, the <code>pg_callback()</code> will probably be called from driver interrupt-level logic. The driver will provide the result of the fill as an argument to the callback function. NOTE: <code>pg_callback()</code> must also be <a href="#MemoryOrg">locked</a> in memory.</p><p>In this non-blocking case, the callback <code>pg_callback()</code> will perform the following operations when it is notified that the fill has completed:</p><ul><li>Verify that <code>g_pftcb</code> is non-NULL.</li><li>Find the higher priority between the task waiting for the fill to complete in <code>g_pftcb</code> and the task waiting at the head of the <code>g_waitingforfill</code> list. That will be the priority of he highest priority task waiting for a fill.</li><li>If this higher priority is higher than current page fill worker thread, then boost worker thread&#39;s priority to that level. Thus, the page fill worker thread will always run at the priority of the highest priority task that is waiting for a fill.</li><li>Save the result of the fill operation.</li><li>Signal the page fill worker thread.</li></ul><h4 id="task-resumption" tabindex="-1">Task Resumption <a class="header-anchor" href="#task-resumption" aria-label="Permalink to &quot;Task Resumption&quot;">​</a></h4><p>For the non-blocking <code>up_fillpage()</code>, the page fill worker thread will detect that the page fill is complete when it is awakened with <code>g_pftcb</code> non-NULL and fill completion status from <code>pg_callback</code>. In the non-blocking case, the page fill worker thread will know that the page fill is complete when <code>up_fillpage()</code> returns.</p><p>In this either, the page fill worker thread will:</p><ul><li>Verify consistency of state information and <code>g_pftcb</code>.</li><li>Verify that the page fill completed successfully, and if so,</li><li>Call <code>up_unblocktask(g_pftcb)</code> to make the task that just received the fill ready-to-run.</li><li>Check if the <code>g_waitingforfill</code> list is empty. If not: <ul><li>Remove the highest priority task waiting for a page fill from <code>g_waitingforfill</code>,</li><li>Save the task&#39;s TCB in <code>g_pftcb</code>,</li><li>If the priority of the thread in <code>g_pftcb</code>, is higher in priority than the default priority of the page fill worker thread, then set the priority of the page fill worker thread to that priority.</li><li>Call <code>pg_startfill()</code> which will start the next fill (as described above).</li></ul></li><li>Otherwise, <ul><li>Set <code>g_pftcb</code> to NULL.</li><li>Restore the default priority of the page fill worker thread.</li><li>Wait for the next fill related event (a new page fault).</li></ul></li></ul><h3 id="architecture-specific-support-requirements" tabindex="-1">Architecture-Specific Support Requirements <a class="header-anchor" href="#architecture-specific-support-requirements" aria-label="Permalink to &quot;Architecture-Specific Support Requirements&quot;">​</a></h3><h4 id="memory-organization" tabindex="-1">Memory Organization <a class="header-anchor" href="#memory-organization" aria-label="Permalink to &quot;Memory Organization&quot;">​</a></h4><p><strong>Memory Regions</strong>. Chip specific logic will map the virtual and physical address spaces into three general regions:</p><ol><li>A .text region containing &quot;<a href="#MemoryOrg">locked-in-memory</a>&quot; code that is always available and will never cause a page fault. This locked memory is loaded at boot time and remains resident for all time. This memory regions must include: <ul><li>All logic for all interrupt paths. All interrupt logic must be locked in memory because the design present here will not support page faults from interrupt handlers. This includes the page fault handling logic and <code>`pg_miss()</code> &lt;#PageFaults&gt;[__ that is called from the page fault handler. It also includes the ]{.title-ref}<code>pg_callback()</code> &lt;#FillComplete&gt;[__ function that wakes up the page fill worker thread and whatever architecture-specific logic that calls ]{.title-ref}[pg_callback()]{.title-ref}`.</li><li>All logic for the IDLE thread. The IDLE thread must always be ready to run and cannot be blocked for any reason.</li><li>All of the page fill worker thread must be locked in memory. This thread must execute in order to unblock any thread waiting for a fill. It this thread were to block, there would be no way to complete the fills!</li></ul></li><li>A .text region containing pages that can be assigned allocated, mapped to various virtual addresses, and filled from some mass storage medium.</li><li>And a fixed RAM space for .bss, .text, and .heap.</li></ol><p>This memory organization is illustrated in the following table. Notice that:</p><ul><li>There is a one-to-one relationship between pages in the virtual address space and between pages of .text in the non-volatile mass storage device.</li><li>There are, however, far fewer physical pages available than virtual pages. Only a subset of physical pages will be mapped to virtual pages at any given time. This mapping will be performed on-demand as needed for program execution.</li></ul><p>SRAM Virtual Address Space Non-Volatile Storage</p><hr><p>. DATA . . Virtual Page <em>n</em> (<em>n</em> &gt; <em>m</em>) Stored Page <em>n</em> . Virtual Page <em>n-1</em> Stored Page <em>n-1</em> DATA ... ... Physical Page <em>m</em> (<em>m</em> &lt; <em>n</em>) ... ... Physical Page <em>m-1</em> ... ... ... ... ... Physical Page <em>1</em> Virtual Page <em>1</em> Stored Page <em>1</em> Locked Memory Locked Memory Memory Resident</p><p><strong>Example</strong>. As an example, suppose that the size of the SRAM is 192K (as in the NXP LPC3131). And suppose further that:</p><ul><li>The size of the locked, memory resident .text area is 32K, and</li><li>The size of the DATA area is 64K.</li><li>The size of one, managed page is 1K.</li><li>The size of the whole .text image on the non-volatile, mass storage device is 1024K.</li></ul><p>Then, the size of the locked, memory resident code is 32K (<em>m</em>=32 pages). The size of the physical page region is 96K (96 pages), and the size of the data region is 64 pages. And the size of the virtual paged region must then be greater than or equal to (1024-32) or 992 pages (<em>n</em>).</p><p><strong>Building the Locked, In-Memory Image</strong>. One way to accomplish this would be a two phase link:</p><ul><li>In the first phase, create a partially linked objected containing all interrupt/exception handling logic, the page fill worker thread plus all parts of the IDLE thread (which must always be available for execution).</li><li>All of the <code>.text</code> and <code>.rodata</code> sections of this partial link should be collected into a single section.</li><li>The second link would link the partially linked object along with the remaining object to produce the final binary. The linker script should position the &quot;special&quot; section so that it lies in a reserved, &quot;non-swappable&quot; region.</li></ul><h4 id="architecture-specific-functions" tabindex="-1">Architecture-Specific Functions <a class="header-anchor" href="#architecture-specific-functions" aria-label="Permalink to &quot;Architecture-Specific Functions&quot;">​</a></h4>',53),e("p",null,[t("Most standard, architecture-specific functions are declared in "),e("code",null,"include/nuttx/arch.h"),t(". However, for the case of this paging logic, the architecture specific functions are declared in "),e("code",null,"include/nuttx/page.h"),t(". Standard, architecture-specific functions that should already be provided in the architecture port are :c"),e("code",{class:"interpreted-text",role:"func"},"up_switch_context"),t(". New, additional functions that must be implemented just for on-demand paging support are:")],-1)]))}const m=o(n,[["render",s]]);export{f as __pageData,m as default};
