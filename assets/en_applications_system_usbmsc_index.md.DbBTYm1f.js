import{_ as o,c as d,al as t,o as c}from"./chunks/framework.NFAqBSgQ.js";const _=JSON.parse('{"title":"usbmsc USB Mass Storage Device Commands","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/system/usbmsc/index.md","filePath":"en/applications/system/usbmsc/index.md"}'),s={name:"en/applications/system/usbmsc/index.md"};function i(a,e,r,n,l,S){return c(),d("div",null,e[0]||(e[0]=[t(`<h1 id="usbmsc-usb-mass-storage-device-commands" tabindex="-1"><code>usbmsc</code> USB Mass Storage Device Commands <a class="header-anchor" href="#usbmsc-usb-mass-storage-device-commands" aria-label="Permalink to &quot;\`usbmsc\` USB Mass Storage Device Commands&quot;">â€‹</a></h1><p>This add-on registers a block device driver, then exports the block the device using the USB storage class driver. In order to use this add-on, your board-specific logic must provide the function:</p><pre><code>void board_usbmsc_initialize(void);
</code></pre><p>This function will be called by the <code>system/usbmsc</code> indirectly via the <code>boardctl</code> <code>BOARDIOC_USBDEV_CONTROL</code> command in order to do the actual registration of the block device drivers. For examples of the implementation of <code>board_usbmsc_initialize()</code> see <code>boards/arm/lpc214x/mcu123-lpc214x/src/up_usbmsc.c</code> or <code>boards/arm/stm32/stm3210e-eval/src/usbmsc.c</code>.</p><p>Configuration options:</p><ul><li><code>CONFIG_NSH_BUILTIN_APPS</code> -- This add-on can be built as two NSH &quot;built-in&quot; commands if this option is selected: <code>msconn</code> will connect the USB mass storage device; <code>msdis</code> will disconnect the USB storage device.</li><li><code>CONFIG_BOARDCTL</code> -- Enables the <code>boardctl()</code> interfaces.</li><li><code>CONFIG_BOARDCTL_USBDEVCTRL</code> -- Enables the <code>BOARDIOC_USBDEV_CONTROL</code> <code>boardctl()</code> command.</li><li><code>CONFIG_SYSTEM_USBMSC_NLUNS</code> -- Defines the number of logical units (LUNs) exported by the USB storage driver. Each LUN corresponds to one exported block driver (or partition of a block driver). May be <code>1</code>, <code>2</code>, or <code>3</code>. Default is <code>1</code>.</li><li><code>CONFIG_SYSTEM_USBMSC_DEVMINOR1</code> -- The minor device number of the block driver for the first LUN. For example, <code>N</code> in <code>/dev/mmcsdN</code>. Used for registering the block driver. Default is zero.</li><li><code>CONFIG_SYSTEM_USBMSC_DEVPATH1</code> -- The full path to the registered block driver. Default is <code>/dev/mmcsd0</code></li><li><code>CONFIG_SYSTEM_USBMSC_DEVMINOR2</code> and <code>CONFIG_SYSTEM_USBMSC_DEVPATH2</code> Similar parameters that would have to be provided if <code>CONFIG_SYSTEM_USBMSC_NLUNS</code> is <code>2</code> or <code>3</code>. No defaults.</li><li><code>CONFIG_SYSTEM_USBMSC_DEVMINOR3</code> and <code>CONFIG_SYSTEM_USBMSC_DEVPATH3</code> Similar parameters that would have to be provided if <code>CONFIG_SYSTEM_USBMSC_NLUNS</code> is <code>3</code>. No defaults.</li><li><code>CONFIG_SYSTEM_USBMSC_DEBUGMM</code> -- Enables some debug tests to check for memory usage and memory leaks.</li></ul><p>If <code>CONFIG_USBDEV_TRACE</code> is enabled (or <code>CONFIG_DEBUG_FEATURES</code> and <code>CONFIG_DEBUG_USB</code>), then the code will also manage the USB trace output. The amount of trace output can be controlled using:</p><ul><li><code>CONFIG_SYSTEM_USBMSC_TRACEINIT</code> -- Show initialization events.</li><li><code>CONFIG_SYSTEM_USBMSC_TRACECLASS</code> -- Show class driver events.</li><li><code>CONFIG_SYSTEM_USBMSC_TRACETRANSFERS</code> -- Show data transfer events.</li><li><code>CONFIG_SYSTEM_USBMSC_TRACECONTROLLER</code> -- Show controller events.</li><li><code>CONFIG_SYSTEM_USBMSC_TRACEINTERRUPTS</code> -- Show interrupt-related events.</li></ul><p>Error results are always shown in the trace output</p><p><strong>Note 1</strong>: When built as an NSH add-on command (<code>CONFIG_NSH_BUILTIN_APPS=y</code>), Caution should be used to assure that the SD drive (or other storage device) is not in use when the USB storage device is configured. Specifically, the SD driver should be unmounted like:</p><pre><code>nsh&gt; mount -t vfat /dev/mmcsd0 /mnt/sdcard  # Card is mounted in NSH
...
nsh&gt; umount /mnd/sdcard                     # Unmount before connecting USB!!!
nsh&gt; msconn                                 # Connect the USB storage device
...
nsh&gt; msdis                                  # Disconnect USB storate device
nsh&gt; mount -t vfat /dev/mmcsd0 /mnt/sdcard  # Restore the mount
</code></pre><p>Failure to do this could result in corruption of the SD card format.</p><p><strong>Note 2</strong>: This add-on used internal USB device driver interfaces. As such, it relies on internal OS interfaces that are not normally available to a user-space program. As a result, this add-on cannot be used if a NuttX is built as a protected, supervisor kernel (<code>CONFIG_BUILD_PROTECTED</code> or <code>CONFIG_BUILD_KERNEL</code>).</p>`,13)]))}const u=o(s,[["render",i]]);export{_ as __pageData,u as default};
