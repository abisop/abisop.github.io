import{_ as o,c as a,al as i,j as e,a as t,o as n}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"NuttX File System","description":"","frontmatter":{},"headers":[],"relativePath":"en/components/filesystem/index.md","filePath":"en/components/filesystem/index.md"}'),r={name:"en/components/filesystem/index.md"};function l(d,s,c,p,m,h){return n(),a("div",null,s[0]||(s[0]=[i("",11),e("p",null,[t("A file list (defined in "),e("code",null,"include/nuttx/fs/fs.h"),t(") contains file structures that denote open files (along with a spinlock to manage access to the file list). With the devices listed in the "),e("code",{class:"interpreted-text",role:"ref"},"root file system <root_fs>"),t(" (on points like "),e("code",null,"/dev/led"),t(", "),e("code",null,"/dev/mmcsd0"),t(", etc. which are henceforth called blockdriver mount points) in an unmounted state, storage devices can be mounted using the "),e("code",null,"mount()"),t(" command (to any point like "),e("code",null,"/dir/abcd"),t(") with any specific supported file system, which internally calls its implemented "),e("code",null,"mountpt_operations->bind()"),t(" method and passes the blockdriver's mount point inode to it, thus creating a "),e("strong",null,"mount point"),t(". The blockdriver mount point inode will have a "),e("code",null,"mountpt->i_private"),t(" which contains any (file system dependent) information about the mount and is to be filled by the file system during the execution of "),e("code",null,"mountpt_operations->bind()"),t(" (and usually this data includes a pointer to the blockdriver mount point as well). After that, according to system calls, the other exposed functions of the filesystem are called as per need.")],-1),i("",31)]))}const y=o(r,[["render",l]]);export{u as __pageData,y as default};
