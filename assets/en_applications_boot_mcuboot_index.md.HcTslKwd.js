import{_ as a,c as t,al as o,o as i}from"./chunks/framework.NFAqBSgQ.js";const p=JSON.parse('{"title":"mcuboot MCUboot","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/boot/mcuboot/index.md","filePath":"en/applications/boot/mcuboot/index.md"}'),n={name:"en/applications/boot/mcuboot/index.md"};function r(s,e,c,l,d,m){return i(),t("div",null,e[0]||(e[0]=[o('<h1 id="mcuboot-mcuboot" tabindex="-1"><code>mcuboot</code> MCUboot <a class="header-anchor" href="#mcuboot-mcuboot" aria-label="Permalink to &quot;`mcuboot` MCUboot&quot;">​</a></h1><h2 id="description" tabindex="-1">Description <a class="header-anchor" href="#description" aria-label="Permalink to &quot;Description&quot;">​</a></h2><p>The NuttX port of MCUboot secure boot library expects that the platform provides a Flash storage with the following partitions:</p><ul><li><code>CONFIG_MCUBOOT_PRIMARY_SLOT_PATH</code>: MTD partition for the application firmware image PRIMARY slot;</li><li><code>CONFIG_MCUBOOT_SECONDARY_SLOT_PATH</code>: MTD partition for the application firmware image SECONDARY slot;</li><li><code>CONFIG_MCUBOOT_SCRATCH_PATH</code>: MTD partition for the Scratch area;</li></ul><p>Also, these are optional features that may be enabled:</p><ul><li><code>CONFIG_MCUBOOT_WATCHDOG</code>: If <code>CONFIG_WATCHDOG</code> is enabled, MCUboot shall reset the watchdog timer indicated by <code>CONFIG_MCUBOOT_WATCHDOG_DEVPATH</code> to the current timeout value, preventing any imminent watchdog timeouts.</li></ul><p>The porting layer of MCUboot library consists of the following interfaces:</p><ul><li><code>&lt;flash_map_backend/flash_map_backend.h&gt;</code>, for enabling MCUboot to manage the application firmware image slots in the device storage.</li><li><code>&lt;mcuboot_config/mcuboot_config.h&gt;</code>, for configuration of MCUboot&#39;s features.</li><li><code>&lt;mcuboot_config/mcuboot_logging.h&gt;</code>, for providing logging capabilities.</li><li><code>&lt;os/os_malloc.h&gt;</code>, for providing MCUboot access to the OS memory management interfaces.</li><li><code>&lt;sysflash/sysflash.h&gt;</code>, for configuration of the system&#39;s flash area organization.</li></ul><p>The NuttX port of MCUboot is implemented at application-level and requires minimal knowledge about characteristics of the underlying storage device. This is achieved by means of the <code>BCH</code> and <code>FTL</code> subsystems, which enable MCUboot to manage MTD partitions via character device drivers using standard POSIX filesystem operations (e.g. <code>open()</code> / <code>close()</code> / <code>read()</code> / <code>write()</code>).</p><h2 id="creating-mcuboot-compatible-application-firmware-images" tabindex="-1">Creating MCUboot-compatible application firmware images <a class="header-anchor" href="#creating-mcuboot-compatible-application-firmware-images" aria-label="Permalink to &quot;Creating MCUboot-compatible application firmware images&quot;">​</a></h2><p>One common use case for MCUboot is to integrate it to a firmware update agent, which is an important component of a secure firmware update subsystem. Through MCUboot APIs an application is able to install a newly received application firmware image and, once this application firmware image is assured to be valid, the application may confirm it as a stable image. In case that application firmware image is deemed bogus, MCUboot provides an API for invalidating that update, which will induce a rollback procedure to the most recent stable application firmware image.</p><p>The <code>CONFIG_EXAMPLES_MCUBOOT_UPDATE_AGENT</code> example demonstrates this workflow by downloading an application firmware image from a webserver, installing it and triggering the firmware update process for the next boot after a system reset. There is also the <code>CONFIG_EXAMPLES_MCUBOOT_SLOT_CONFIRM</code>, which is a fairly simple example that just calls an MCUboot API for confirming the executing application firmware image as stable.</p><p>For more information about all MCUboot examples, see <code>examples/mcuboot</code> directory.</p><h2 id="using-mcuboot-on-nuttx-as-a-secure-boot-solution" tabindex="-1">Using MCUboot on NuttX as a secure boot solution <a class="header-anchor" href="#using-mcuboot-on-nuttx-as-a-secure-boot-solution" aria-label="Permalink to &quot;Using MCUboot on NuttX as a secure boot solution&quot;">​</a></h2><p>NuttX port for MCUboot also enables the creation of a secure bootloader application requiring minimal platform-specific implementation. The logical implementation for the secure boot is performed at application-level by the MCUboot library. Once MCUboot validates the application firmware image, it delegates the loading and execution of the application firmware image to a platform-specific routine, which is accessed via <code>boardctl(BOARDIOC_BOOT_IMAGE)</code> call. Each platform must then provide an implementation for the <code>board_boot_image()</code> for executing the required actions in order to boot a new application firmware image (e.g. deinitialize peripherals, load the Program Counter register with the application firmware image entry point address).</p><p>The MCUboot bootloader application may be enabled by selecting the <code>CONFIG_MCUBOOT_BOOTLOADER</code> option.</p><h2 id="assumptions" tabindex="-1">Assumptions <a class="header-anchor" href="#assumptions" aria-label="Permalink to &quot;Assumptions&quot;">​</a></h2><h3 id="ioctl-mtd-commands" tabindex="-1">IOCTL MTD commands <a class="header-anchor" href="#ioctl-mtd-commands" aria-label="Permalink to &quot;IOCTL MTD commands&quot;">​</a></h3><p>The implementation of <code>&lt;flash_map_backend/flash_map_backend.h&gt;</code> expects that the MTD driver for a given image partition handles the following <code>ioctl</code> commands:</p><ul><li><code>MTDIOC_GEOMETRY</code>, for retrieving information about the geometry of the MTD, required for the configuration of the size of each flash area.</li><li><code>MTDIOC_ERASESTATE</code>, for retrieving the byte value of an erased cell of the MTD, required for the implementation of <code>flash_area_erased_val()</code> interface.</li></ul><h3 id="write-access-alignment" tabindex="-1">Write access alignment <a class="header-anchor" href="#write-access-alignment" aria-label="Permalink to &quot;Write access alignment&quot;">​</a></h3><p>Through <code>flash_area_align()</code> interface MCUboot expects that the implementation provides the shortest data length that may be written via <code>flash_area_write()</code> interface. The NuttX implementation passes through the <code>BCH</code> and <code>FTL</code> layers, which appropriately handle the write alignment restrictions of the underlying MTD. So The NuttX implementation of <code>flash_area_align()</code> is able to return a fixed value of 1 byte, even if the MTD does not support byte operations.</p><h2 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to &quot;Limitations&quot;">​</a></h2><h3 id="flash-map-backend-flash-map-backend-h-functions-are-not-multitasking-safe" tabindex="-1"><code>&lt;flash_map_backend/flash_map_backend.h&gt;</code> functions are not multitasking-safe <a class="header-anchor" href="#flash-map-backend-flash-map-backend-h-functions-are-not-multitasking-safe" aria-label="Permalink to &quot;`&lt;flash_map_backend/flash_map_backend.h&gt;` functions are not multitasking-safe&quot;">​</a></h3><p>MCUboot&#39;s documentation imposes no restrictions regarding the usage of its public interfaces, which doesn&#39;t mean they are thread-safe. But, regarding NuttX implementation of the <code>&lt;flash_map_backend/flash_map_backend.h&gt;</code>, it is safe to state that they are <strong>not</strong> multitasking-safe. NuttX implementation manages the MTD partitions via character device drivers. As file-descriptors cannot be shared between different tasks, if one task calls <code>flash_area_open</code> and another task calls <code>flash_area_&lt;read/write/close&gt;</code> passing the same <code>struct flash_area</code> instance, it will result in failure.</p>',25)]))}const f=a(n,[["render",r]]);export{p as __pageData,f as default};
