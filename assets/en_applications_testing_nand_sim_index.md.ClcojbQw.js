import{_ as a,c as t,al as i,o as r}from"./chunks/framework.NFAqBSgQ.js";const u=JSON.parse('{"title":"nand - NAND Flash Device Simulator","description":"","frontmatter":{},"headers":[],"relativePath":"en/applications/testing/nand_sim/index.md","filePath":"en/applications/testing/nand_sim/index.md"}'),o={name:"en/applications/testing/nand_sim/index.md"};function s(d,e,n,c,l,h){return r(),t("div",null,e[0]||(e[0]=[i('<h1 id="nand-nand-flash-device-simulator" tabindex="-1"><code>nand</code> - NAND Flash Device Simulator <a class="header-anchor" href="#nand-nand-flash-device-simulator" aria-label="Permalink to &quot;`nand` - NAND Flash Device Simulator&quot;">​</a></h1><p>In order to test the filesystems that work with NAND flash devices in a simulator, this exists to provide a virtual NAND flash device, along with its driver, to allow manual (or scripted) testing, as well as to provide an option to log the various actions performed under-the-hood along with the state of the device, which includes the read, write and erase counts of each page in the device.</p><h2 id="structure-of-nand-flash" tabindex="-1">Structure of NAND Flash <a class="header-anchor" href="#structure-of-nand-flash" aria-label="Permalink to &quot;Structure of NAND Flash&quot;">​</a></h2><p>Most NAND flashes share a common interface, specified by the <a href="https://www.onfi.org/" target="_blank" rel="noreferrer">Open NAND Flash Interface (ONFI)</a>.</p><p>The important part from it, required in this context, is that a NAND Flash is divided into a lot of blocks. And each blocks are divided into a lot of pages.</p><p>Here&#39;s the peculiar bit. If you want to erase a page, you need to erase the <em>entire</em> block that it is part of, ie. blocks are the smallest erasable units in a NAND flash. However, a page is the smallest unit to which you can write data, or read data from.</p><p>Why would you need erase operation? The Program/ Erase (P/E) cycle states that a page (and thus its block) need to be erased first before data can be written to it (Erase-Before-Write).</p><p>Each page has a data area, and a spare area. Depending on the data area&#39;s size, the spare area may have different structures (schemes). All the required schemes are defined in <code>/drivers/mtd/mtd_nandscheme.c</code> (in the <code>g_nand_sparescheme*</code> structures).</p><p>Due to the nature of NAND flash, upon testing, a manufacturer may decide that a certain block fails some test(s), and mark it as a <strong>bad block</strong> by writing a certain value in a certain position in the spare area (depends on data area&#39;s size, and thus, the spare area&#39;s scheme) of every page in it.</p><div class="note"><div class="title"><p>Note</p></div><p>* While certain blocks may <em>still work</em> even if they are marked as bad, it&#39;s inadvisable to store any data in it.</p><ul><li>The spare data is the <strong>only</strong> record of a block being bad or not. Please do not erase it.</li><li>Certain blocks may become bad after continuous usage, and would need to be marked as such by either the filesystem or the driver.</li></ul></div><p>Currently, this simulator supports only 512 B sized pages, which means it will follow the <code>g_nand_sparescheme512</code> scheme for its spare area, and thus have a bad block marker at index <code>5</code>.</p><p>If a block is <em>not</em> bad, it contains a value of <code>0xff</code> in the place of a bad block marker. Any other value denote it&#39;s a bad block.</p><h2 id="ram-to-device-lower-half" tabindex="-1">RAM to Device (Lower Half) <a class="header-anchor" href="#ram-to-device-lower-half" aria-label="Permalink to &quot;RAM to Device (Lower Half)&quot;">​</a></h2><p>Since this is an emulation, RAM of the host running the simulator is used to create the device. While the speed of operations won&#39;t be even close to the original, this being in the RAM, which works multitudes faster than actual device, the functionality on the other hand has been kept consistent to the utmost.</p><p>First, <code>/include/nuttx/mtd/nand.h</code> has a structure <code>struct nand_dev_s</code> defining a raw NAND MTD device (lowest level). Its field <code>nand_dev_s-&gt;raw</code> is of type <code>struct nand_raw_s *</code> (defined in <code>include/nuttx/mtd/nand_raw.h</code>), and this is what will hold the methods for the raw device. There are primarily 3 methods that need to be looked into:</p><ul><li>eraseblock</li><li>rawread</li><li>rawwrite</li></ul><p>Conforming to the functionality of NAND flashes, these three were implemented as <code>nand_ram_*</code> in <code>/drivers/mtd/nand_ram.c</code> to emulate RAM into a virtual NAND flash.</p><p>While in real devices, the spare area follows the data area (in most schemes) , since this is virtual, we can get away with keeping the two into two separate arrays, namely <code>nand_ram_flash_data</code> and <code>nand_ram_flash_spare</code> for data and spare respectively. Each array has as many elements as number of pages in the device.</p><p>As the spare areas has some spare bytes we can use, some space is used as counters for the reads/writes/erases each page faces, thus giving a clear picture of wear of the virtual device to the tester.</p><div class="note"><div class="title"><p>Note</p></div><p>ECC extension has not been implemented yet, so ECC bits in spare are yet to be used or initialized properly.</p></div><p>The method <code>nand_ram_initialize()</code> takes in a preallocated space for a raw device (of type <code>struct nand_raw_s</code> as defined in <code>include/nuttx/mtd/nand_raw.h</code>) and attaches these 3 custom methods as well as device information like page size, block size, etc. to it. These form the lower half of the driver.</p><h2 id="upper-half" tabindex="-1">Upper Half <a class="header-anchor" href="#upper-half" aria-label="Permalink to &quot;Upper Half&quot;">​</a></h2><p>The method <code>nand_ram_initialize()</code> also initializes a <code>struct mtd_dev_s *</code> (defined in <code>include/nuttx/mtd/mtd.h</code>), which it returns. This structure contains a reference to our custom lower half in <code>mtd_dev_s-&gt;raw</code>, as well as an upper half containing methods <code>nand_*</code> (defined in <code>drivers/mtd/mtd_nand.c</code>).</p><h2 id="wrapper-over-upper-half" tabindex="-1">Wrapper Over Upper Half <a class="header-anchor" href="#wrapper-over-upper-half" aria-label="Permalink to &quot;Wrapper Over Upper Half&quot;">​</a></h2><p>The upper half, along with the lower half attached to it, received from <code>nand_ram_initialize()</code> contains these 5 methods for the upper half:</p><ul><li>erase</li><li>bread</li><li>bwrite</li><li>ioctl</li><li>isbad</li><li>markbad</li></ul><p>Each driver&#39;s upper half needs to be registered with NuttX before it can appear in the list of devices (in <code>/dev</code>). Instead of the previously acquired upper-half, we&#39;ll be registering a wrapper over it, to improve logging. The wrapper methods are defined as <code>nand_wrapper_*</code> in <code>drivers/mtd/mtd_nandwrapper.c</code>.</p><p>Here&#39;s a complicated bit. The actual upper half is an MTD device, but more specifically, it is a NAND MTD device, which is represented by <code>struct nand_dev_s</code>. Due to how it is defined, <code>struct mtd_dev_s</code> forms the very start of <code>struct nand_dev_s</code>, and hence they can be type-casted to each other (provided required memory is accessible). Our wrapper, being a wrapper over an MTD device, is an MTD device itself as well. MTD device methods take in a <code>struct mtd_dev_s *dev</code> which describe the device itself (which is the actual device that is registered using <code>register_mtddriver</code>), which includes its methods. Our wrapper methods receive such a device as well, which contains the wrapper device including the wrapper functions. But, this way, there is no way of accessing the methods of the actual upper half itself. Thus, instead of <code>dev</code> being of type <code>struct nand_dev_s</code>, it is actually of type <code>struct nand_wrapper_dev_s</code> which is a superset of <code>struct nand_dev_s</code>, who itself is a superset of <code>struct mtd_dev_s</code>. Similar to previous case, <code>struct mtd_dev_s</code> forms the very start of <code>struct nand_wrapper_dev_s</code>, and thus the types are inter-changeable.</p><p>The methods <code>nand_wrapper_*</code> in <code>drivers/mtd/mtd_nandwrapper.c</code> all pass the parameters to corresponding method of the actual upper half after logging it. <em>But, the device passed on to the actual upper half is still the wrapper, not the actual upper half, as the upper half methods may call the other methods as well internally and we might want to log them as well</em>.</p><h2 id="registering-device-daemon" tabindex="-1">Registering Device &amp; Daemon <a class="header-anchor" href="#registering-device-daemon" aria-label="Permalink to &quot;Registering Device &amp; Daemon&quot;">​</a></h2><p>This wrapper is then registered using <code>register_mtddriver</code>, and this whole thing is converted to be a daemon, so that the device can keep running in the background.</p><p>Making it a daemon is achieved by using <code>fork()</code>, killing the parent, and using <code>daemon()</code> in child.</p><h2 id="known-issues" tabindex="-1">Known Issues <a class="header-anchor" href="#known-issues" aria-label="Permalink to &quot;Known Issues&quot;">​</a></h2><ul><li>ECC is not implemented yet.</li><li>MLC NAND Flash is not implemented yet.</li><li>Due to the fixed name of the device, there can&#39;t be more than one instance of this virtual device.</li></ul>',34)]))}const m=a(o,[["render",s]]);export{u as __pageData,m as default};
