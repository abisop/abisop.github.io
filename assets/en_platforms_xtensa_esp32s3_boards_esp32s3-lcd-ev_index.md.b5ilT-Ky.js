import{_ as a,c as t,al as o,o as n}from"./chunks/framework.NFAqBSgQ.js";const s="/assets/esp32s3_lcd_ev.DEWHRDw9.png",r="/assets/esp32-audio-config-file.BWOmnNZB.png",f=JSON.parse('{"title":"ESP32-S3-LCD-EV","description":"","frontmatter":{},"headers":[],"relativePath":"en/platforms/xtensa/esp32s3/boards/esp32s3-lcd-ev/index.md","filePath":"en/platforms/xtensa/esp32s3/boards/esp32s3-lcd-ev/index.md"}'),i={name:"en/platforms/xtensa/esp32s3/boards/esp32s3-lcd-ev/index.md"};function l(d,e,c,p,h,u){return n(),t("div",null,e[0]||(e[0]=[o('<h1 id="esp32-s3-lcd-ev" tabindex="-1">ESP32-S3-LCD-EV <a class="header-anchor" href="#esp32-s3-lcd-ev" aria-label="Permalink to &quot;ESP32-S3-LCD-EV&quot;">​</a></h1><p>chip:esp32, chip:esp32s3</p><p>The <a href="https://docs.espressif.com/projects/esp-dev-kits/en/latest/esp32s3/esp32-s3-lcd-ev-board/user_guide.html" target="_blank" rel="noreferrer">ESP32-S3-LCD-EV-Board</a> is a small-sized AI development board from Espressif featuring the ESP32-S3 CPU with a touchscreen LCD display, dual microphone, an 16 MB Octal PSRAM and an 16 MB flash.</p><hr><h2 id="" tabindex="-1"><img src="'+s+`" alt="" class="align-center"> <a class="header-anchor" href="#" aria-label="Permalink to &quot;![](esp32s3_lcd_ev.png){.align-center}&quot;">​</a></h2><h2 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h2><blockquote><ul><li>ESP32-S3 WROOM-1 Module</li><li>USB Type-C ports</li><li>Power LED</li><li>LCD Display</li><li>MEMS Microphone</li><li>16MB Octal PSRAM</li><li>16MB SPI Flash</li><li>RST and BOOT buttons (BOOT accessible to user)</li></ul></blockquote><h2 id="serial-console" tabindex="-1">Serial Console <a class="header-anchor" href="#serial-console" aria-label="Permalink to &quot;Serial Console&quot;">​</a></h2><p>UART0 is, by default, the serial console. It connects to the on-board CP2102 converter and is available on the USB connector USB CON8 (J1).</p><p>It will show up as /dev/ttyUSB[n] where [n] will probably be 0.</p><h2 id="buttons-and-leds" tabindex="-1">Buttons and LEDs <a class="header-anchor" href="#buttons-and-leds" aria-label="Permalink to &quot;Buttons and LEDs&quot;">​</a></h2><h3 id="board-buttons" tabindex="-1">Board Buttons <a class="header-anchor" href="#board-buttons" aria-label="Permalink to &quot;Board Buttons&quot;">​</a></h3><p>There are two buttons labeled Boot and EN. The EN button is not available to software. It pulls the chip enable line that doubles as a reset line.</p><p>The BOOT button is connected to IO0. On reset it is used as a strapping pin to determine whether the chip boots normally or into the serial bootloader. After reset, however, the BOOT button can be used for software input.</p><h3 id="board-leds" tabindex="-1">Board LEDs <a class="header-anchor" href="#board-leds" aria-label="Permalink to &quot;Board LEDs&quot;">​</a></h3><p>There are several on-board LEDs for that indicate the presence of power and USB activity. None of these are available for use by software. Another WS2812 LED is connected to GPIO4.</p><h2 id="configurations" tabindex="-1">Configurations <a class="header-anchor" href="#configurations" aria-label="Permalink to &quot;Configurations&quot;">​</a></h2><p>All of the configurations presented below can be tested by running the following commands:</p><pre><code> ./tools/configure.sh esp32s3-lcd-ev:&lt;config_name&gt;
 make flash ESPTOOL_PORT=/dev/ttyUSB0 -j
</code></pre><p>Where &lt;config_name&gt; is the name of board configuration you want to use, i.e.: nsh, buttons, wifi... Then use a serial console terminal like <code>picocom</code> configured to 115200 8N1.</p><h3 id="audio" tabindex="-1">audio <a class="header-anchor" href="#audio" aria-label="Permalink to &quot;audio&quot;">​</a></h3><p>This configuration uses the I2S0 peripheral and an externally connected audio codec to play an audio file streamed over an HTTP connection while connected to a Wi-Fi network.</p><p><strong>Audio Codec Setup</strong></p><p>The CS4344 audio codec is connected to the following pins:</p><p>ESP32-S3 Pin CS4344 Pin Description</p><hr><p>5 MCLK Master Clock 16 SCLK Serial Clock 7 LRCK Left Right Clock (Word Select) 6 SDIN Serial Data In on CS4344. (DOUT on ESP32-S3)</p><p><strong>Simple HTTP server</strong></p><p>Prepare a PCM-encoded ([.wav]{.title-ref}) audio file with 16 or 24 bits/sample (sampled at 16~48kHz). This file must be placed into a folder in a computer that could be accessed on the same Wi-Fi network the ESP32 will be connecting to.</p><p>Python provides a simple HTTP server. <code>cd</code> to the audio file folder on the PC and run:</p><pre><code> python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/)
</code></pre><p>Look for your PC IP address and test playing the prepared audio on your browser:</p><p><img src="`+r+`" alt="" class="align-center"></p><p>After successfully built and flashed, connect the board to the Wi-Fi network:</p><pre><code>nsh&gt; wapi psk wlan0 mypasswd 3
nsh&gt; wapi essid wlan0 myssid 1
nsh&gt; renew wlan0
</code></pre><p>Once connected, open NuttX&#39;s player and play the file according to the filename and the IP address of the HTTP server:</p><pre><code>nsh&gt; nxplayer
nxplayer&gt; play http://192.168.1.239:8000/tones.wav
</code></pre><h3 id="buttons" tabindex="-1">buttons <a class="header-anchor" href="#buttons" aria-label="Permalink to &quot;buttons&quot;">​</a></h3><p>This configuration shows the use of the buttons subsystem. It can be used by executing the <code>buttons</code> application and pressing on any of the available board buttons:</p><pre><code>nsh&gt; buttons
buttons_main: Starting the button_daemon
buttons_main: button_daemon started
button_daemon: Running
button_daemon: Opening /dev/buttons
button_daemon: Supported BUTTONs 0x01
nsh&gt; Sample = 1
Sample = 0
</code></pre><h3 id="lvgl" tabindex="-1">lvgl <a class="header-anchor" href="#lvgl" aria-label="Permalink to &quot;lvgl&quot;">​</a></h3><p>This is a demonstration of the LVGL graphics library running on the NuttX LCD driver. You can find LVGL here:</p><pre><code>https://www.lvgl.io/
https://github.com/lvgl/lvgl
</code></pre><p>This configuration uses the LVGL demonstration at [apps/examples/lvgldemo]{.title-ref}.</p><h3 id="nsh" tabindex="-1">nsh <a class="header-anchor" href="#nsh" aria-label="Permalink to &quot;nsh&quot;">​</a></h3><p>Basic NuttShell configuration (console enabled in UART0, exposed via USB connection by means of CP2102 converter, at 115200 bps).</p><h3 id="ws2812" tabindex="-1">ws2812 <a class="header-anchor" href="#ws2812" aria-label="Permalink to &quot;ws2812&quot;">​</a></h3><p>This configuration enables the usage of the RMT peripheral and the example <code>ws2812</code> to drive addressable RGB LEDs:</p><pre><code>nsh&gt; ws2812
</code></pre><p>Please note that this board contains an on-board WS2812 LED connected to GPIO38 and, by default, this config configures the RMT transmitter in the same pin.</p>`,50)]))}const m=a(i,[["render",l]]);export{f as __pageData,m as default};
